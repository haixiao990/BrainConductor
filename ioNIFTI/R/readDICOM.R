#This Method 'read.dcm' can read NIFTI S4 class from .dcm files in the folder inputPath

setGeneric("read.dcm",function(object, src)  standardGeneric("read.dcm"));

setMethod("read.dcm", signature(object = "nifti_one"), function(object, src)
{
  nii_tool <- c(
    'function varargout = nii_tool(cmd, varargin)',
    '% Basic function to create, load and save NIfTI file.',
    '% ',
    '% rst = nii_tool(cmd, para);',
    '% ',
    '% To list all command, type',
    '%  nii_tool ?',
    '% ',
    '% To get help information for each command, include \'?\' in cmd, for example:',
    '%  nii_tool init?',
    '%  nii_tool(\'init?\')',
    '% ',
    '% Here is a list of all command:',
    '% ',
    '% nii_tool(\'default\', \'version\', 1, \'rgb_dim\', 1);',
    '% nii = nii_tool(\'init\', img);',
    '% nii_tool(\'save\', nii, filename, force_3D);',
    '% hdr = nii_tool(\'hdr\', filename);',
    '% img = nii_tool(\'img\', filename_or_hdr);',
    '% ext = nii_tool(\'ext\', filename_or_hdr);',
    '% nii = nii_tool(\'load\', filename_or_hdr);',
    '% nii = nii_tool(\'cat3D\', filenames);',
    '% nii_tool(\'RGBStyle\', \'afni\');',
    '% ',
    '% Detail for each command is described below.',
    '% ',
    '% oldVal = nii_tool(\'default\', \'version\', 1, \'rgb_dim\', 1);',
    '% oldVal = nii_tool(\'default\', struct(\'version\', 1, \'rgb_dim\', 1));',
    '% ',
    '% - Set/query default NIfTI version and/or rgb_dim. To check the setting, run',
    '% nii_tool(\'default\') without other input. The input for \'default\' command can',
    '% be either a struct with fields of \'version\' and/or \'rgb_dim\', or',
    '% parameter/value pairs. See nii_tool(\'RGBstyle\') for meaning of rgb_dim.',
    '% ',
    '% Note that the setting will be saved for future use. If one wants to change the',
    '% settting temporarily, it is better to return the oldVal, and to restore it',
    '% after done:',
    '% ',
    '%  oldVal = nii_tool(\'default\', \'version\', 2); % set version 2 as default',
    '%  % \'init\' and \'save\' NIfTI using above version',
    '%  nii_tool(\'default\', oldVal); % restore default setting',
    '% ',
    '% The default version setting affects \'init\' command only. If you \'load\' a NIfTI',
    '% file, modify it, and then \'save\' it, the version will be the same as the',
    '% original file, unless it is changed explicitly (see help for \'save\' command).',
    '% All \'load\' command (\'load\', \'hdr\', \'ext\', \'img\') will read any version',
    '% correctly, regardless of version setting.',
    '% ',
    '% ',
    '% nii = nii_tool(\'init\', img, RGB_dim);',
    '% ',
    '% - Initialize nii struct based on img, normally 3D or 4D array. Most fields in',
    '% the returned nii.hdr contain default values, and need to be updated based on',
    '% dicom or other information. Important ones include pixdim and s/qform_code and',
    '% related parameters.',
    '% ',
    '% The NIfTI datatype will depend on data type of img. Most Matlab data types are',
    '% supported, including 8/16/32/64 bit signed and unsigned integers, single and',
    '% double floating numbers. Single/double complex and logical array are also',
    '% supported.',
    '% ',
    '% nii_tool returns img with the same data type as it is stored, while numeric',
    '% values in hdr are in double regardless the data type in the file.',
    '% ',
    '% The optional third input is needed only if img contains RGB/RGBA data. It',
    '% specifies which dimension in img encodes for RGB or RGBA. In other words, if a',
    '% non-empty third input is provided, img will be interpreted as RGB or RGBA',
    '% data.',
    '% ',
    '% Another way to signify RGB/RGBA data is to permute color dim to 8th-dim of img',
    '% (RGB_dim of 8 can be omitted then). Since NIfTI img can have up to 7 dim,',
    '% nii_tool chooses to store RGB/RGBA in 8th dim. Although this looks lengthy',
    '% (4th to 7th dim are often all ones), nii_tool can deal with up to 7 dim',
    '% without causing any confusion. This is why the returned nii.img will always',
    '% store RGB in 8th dim.',
    '% ',
    '% ',
    '% hdr = nii_tool(\'hdr\', filename);',
    '% ',
    '% - Return hdr struct of the provided NIfTI file.',
    '% ',
    '% ',
    '% img = nii_tool(\'img\', filename_or_hdr);',
    '% ',
    '% - Return image data in a NIfTI file. The second input can be NIfTI file name,',
    '% or hdr struct returned by nii_tool(\'hdr\', filename).',
    '% ',
    '% ',
    '% ext = nii_tool(\'ext\', filename_or_hdr);',
    '% ',
    '% - Return NIfTI extension in a NIfTI file. The second input can be NIfTI file',
    '% name, or hdr struct returned by nii_tool(\'hdr\', filename). The returned ext',
    '% will have field \'edata_decoded\' if \'ecode\' is of known type, such as dicom',
    '% (2), text (4 or 6) or Matlab (40).',
    '% ',
    '% Here is an example to add data in myFile.mat as extension to nii struct, which',
    '% can be from \'init\' or \'load\':',
    '% ',
    '%  fid = fopen(\'myFile.mat\'); % open the MAT file',
    '%  myEdata = fread(fid, inf, \'*uint8\'); % load all bytes as byte column',
    '%  fclose(fid);',
    '%  len = int32(numel(myEdata)); % number of bytes in int32',
    '%  myEdata = [typecast(len, \'uint8\')\'; myEdata]; % include len in myEdata',
    '%  nii.ext.ecode = 40; % 40 for Matlab extension',
    '%  nii.ext.edata = myEdata; % myEdata must be uint8 array',
    '% ',
    '% nii_tool will take care of rest when you \'save\' nii to a file.',
    '% ',
    '% In case a NIfTI ext causes problem (for example, some FSL builds have problem',
    '% in reading NIfTI img with ecode>30), one can remove the ext easily:',
    '% ',
    '%  nii = nii_tool(\'load\', \'file_with_ext.nii\'); % load the file with ext',
    '%  nii.ext = []; % or nii = rmfield(nii, \'ext\'); % remove ext',
    '%  nii_tool(\'save\', nii, \'file_without_ext.nii\'); % save it',
    '%',
    '% ',
    '% nii = nii_tool(\'load\', filename_or_hdr);',
    '% ',
    '% - Load NIfTI file into nii struct. The returned struct includes NIfTI \'hdr\'',
    '% and \'img\', as well as \'ext\' if the file contains NIfTI extension.',
    '% ',
    '% ',
    '% nii_tool(\'save\', nii, filename, force_3D);',
    '% ',
    '% - Save struct nii into filename. The format of the file is determined by the',
    '% file extension, such as .img, .nii, .img.gz, .nii.gz etc. If filename is not',
    '% provided, nii.hdr.file_name must contain a file name. Note that \'save\' command',
    '% always overwrites file in case of name conflict.',
    '% ',
    '% If filename has no extension, \'.nii\' will be used as default.',
    '% ',
    '% If the 4th input, force_3D, is true (default false), the output file will be',
    '% 3D only, which means multiple volume data will be split into multiple files.',
    '% This is the format SPM likes. You can use this command to convert 4D into 3D',
    '% by \'load\' a 4D file, then \'save\' it as 3D files. The 3D file names will have',
    '% 5-digit like \'_00001\' appended to indicate volume index.',
    '% ',
    '% The NIfTI version can be set by nii_tool(\'default\'). One can override the',
    '% default version by specifying it in nii.hdr.version. To convert between',
    '% versions, load a NIfTI file, specify new version, and save it. For example:',
    '% ',
    '%  nii = nii_tool(\'load\', \'file_nifti1.nii\'); % load version 1 file',
    '%  nii.hdr.version = 2; % force to NIfTI-2',
    '%  nii_tool(\'save\', nii, \'file_nifti2.nii\'); % save as version 2 file',
    '% ',
    '% Following example shows how to change data type of a nii file:',
    '%  nii = nii_tool(\'load\', \'file_int16.nii\'); % load int16 type file',
    '%  nii.img = single(nii.img); % change data type to single/float32',
    '%  nii_tool(\'save\', nii, \'file_float.nii\'); % nii_tool will take care of hdr',
    '% ',
    '% ',
    '% nii = nii_tool(\'cat3D\', files);',
    '% ',
    '% - Concatenate SPM 3D files into a 4D dataset. The input \'files\' can be cellstr',
    '% with file names, or char with wildcards (* or ?). If it is cellstr, the volume',
    '% order in the 4D data corresponds to those files. If wildcards are used, the',
    '% volume order is based on alphabetical order of file names.',
    '% ',
    '% Note that the files to be concatenated must have the same datatype, dim, voxel',
    '% size, scaling slope and intercept, transformation matrix, etc. This is true if',
    '% files are for the same series. ',
    '% ',
    '% Following example shows how to convert a series of 3D files into a 4D file:',
    '% ',
    '%  nii = nii_tool(\'cat3D\', \'./data/fSubj2-0003*.nii\'); % load files for series 3 ',
    '%  nii_tool(\'save\', nii, \'./data/fSubj2-0003_4D.nii\'); % save as a 4D file',
    '% ',
    '% ',
    '% oldStyle = nii_tool(\'RGBStyle\', \'afni\');',
    '% ',
    '% - Set/query the method to save RGB or RGBA NIfTI file. The default method can',
    '% be set by nii_tool(\'default\', \'rgb_dim\', dimN), where dimN can be 1, 3 or 4,',
    '% or \'afni\', \'mricron\' or \'fsl\', as explained below.',
    '% ',
    '% The default style is \'afni\' style (or 1), which is defined by NIfTI standard,',
    '% but is not well supported by fslview till v5.0.8 or mricron till v20140804',
    '% ',
    '% If the second input is set to \'mricron\' (or 3), nii_tool will save file',
    '% using the old RGB fashion (dim 3 for RGB). This works for mricron v20140804 or',
    '% earlier. The later mricron works for both rgb_dim of 1 and 3.',
    '% ',
    '% If the second input is set to \'fsl\' (or 4), nii_tool will save RGB or RGBA',
    '% layer into 4th dimension, and the file is not encoded as RGB data, but as',
    '% normal NIfTI. This violates the NIfTI rule, but it seems it is the only way',
    '% to work for fslview (at least till fsl v5.0.8).',
    '% ',
    '% If no new style (second input) is provided, it means to query the current',
    '% style (one of \'afni\', \'mricron\' and \'fsl\').',
    '% ',
    '% Following shows how to convert into fsl style:',
    '% ',
    '%  nii = nii_tool(\'load\', \'non_fsl_style.nii\'); % load RGB file',
    '%  nii_tool(\'RGBStyle\', \'fsl\'); % switch to fsl style for later save',
    '%  nii_tool(\'save\', nii, \'fslRGB.nii\'); % fsl can read it as RGB',
    '% ',
    '% Note that, if one wants to convert fsl style (non-RGB file by NIfTI standard)',
    '% to other styles, an extra step is needed to change the RGB dim from 4th to 8th',
    '% dim before \'save\':',
    '% ',
    '%  nii = nii_tool(\'load\', \'fslStyleFile.nii\'); % it is normal NIfTI',
    '%  nii.img = permute(nii.img, [1:3 5:8 4]); % force it to be RGB data',
    '%  nii_tool(\'RGBStyle\', \'afni\'); % switch to NIfTI RGB style',
    '%  nii_tool(\'save\', nii, \'afni_RGB.nii\'); % now AFNI can read it as RGB',
    '% ',
    '% Also note that the setting by nii_tool(\'RGBStyle\') is effective only for',
    '% current Matlab session. If one clears all or starts a new Matlab session, the',
    '% default style by nii_tool(\'default\') will take effect.',
    ' ',
    '% More information for NIfTI format:',
    '% Official NIfTI website: http://nifti.nimh.nih.gov/',
    '% Another excellent site: http://brainder.org/2012/09/23/the-nifti-file-format/',
    '',
    '% History (yymmdd)',
    '% 150109 Write it based on Jimmy Shen\'s NIfTI tool (xiangrui.li@gmail.com)',
    '% 150202 Include renamed pigz files for Windows to trick Matlab Central',
    '% 150203 Fix closeFile and deleteTmpFile order',
    '% 150205 Add hdr.machine: needed for .img fopen',
    '% 150208 Add 4th input for \'save\', allowing to save SPM 3D files',
    '% 150210 Add \'cat3D\' to load SPM 3D files',
    '% 150226 Assign all 8 char for \'magic\' (version 2 needs it)',
    '% 150321 swapbytes(nByte) for ecode=40 with big endian',
    '% 150401 Add \'default\' to set/query version and rgb_dim default setting',
    '% 150514 read_ext: decode txt edata by dicm2nii.m',
    '% 150517 fhandle: provide a way to use gunzipOS etc from outside',
    '% 150617 auto detect rgb_dim 1&3 for \'load\' etc using ChrisR method',
    '',
    'persistent C para; % C columns: name, length, format, value, offset',
    'if isempty(C), [C, para] = niiHeader; end',
    '',
    'if ~ischar(cmd)',
    '    error(\'Provide a string command as the first input for nii_tool\');',
    'end',
    'if any(cmd==\'?\'), subFuncHelp(mfilename, cmd); return; end',
    '',
    'if strcmpi(cmd, \'init\')',
    '    if nargin<2, error(\'nii_tool(\'\'%s\'\') needs second input\', cmd); end',
    '    for i = 1:size(C,1), nii.hdr.(C{i,1}) = C{i,4}; end',
    '    nii.img = varargin{1};',
    '    if numel(size(nii.img))>8',
    '        error(\'NIfTI img can have up to 7 dimension\');',
    '    end',
    '    if nargin>2',
    '        i = varargin{2};',
    '        if i<0 || i>8 || mod(i,1)>0, error(\'Invalid RGB_dim number\'); end',
    '        nii.img = permute(nii.img, [1:i-1 i+1:8 i]); % RGB to dim8',
    '    end',
    '    varargout{1} = img2datatype(nii, para); % set datatype etc ',
    '    ',
    'elseif strcmpi(cmd, \'save\')',
    '    if nargin<2, error(\'nii_tool(\'\'%s\'\') needs second input\', cmd); end',
    '    nii = varargin{1};',
    '    if ~isstruct(nii) || ~isfield(nii, \'hdr\') || ~isfield(nii, \'img\') ',
    '        error([\'nii_tool(\'\'save\'\') needs a struct from nii_tool(\'\'init\'\')\' ...',
    '            \' or nii_tool(\'\'load\'\') as the second input\']);',
    '    end',
    '    ',
    '    % Check file name to save',
    '    if nargin>2',
    '        fname = varargin{2};',
    '        if length(fname)<5 || ~ischar(fname)',
    '            error(\'Invalid name for NIfTI file: %s\', fname);',
    '        end',
    '    elseif isfield(nii.hdr, \'file_name\')',
    '        fname = nii.hdr.file_name;',
    '    else',
    '        error(\'Provide a valid file name as the third input\');',
    '    end',
    '    if ~ispc && strncmp(fname, \'~/\', 2) % matlab may err with this abbrevation',
    '        fname = [getenv(\'HOME\') fname(2:end)];',
    '    end',
    '    [pth, fname, fext] = fileparts(fname);',
    '    do_gzip = strcmpi(fext, \'.gz\');',
    '    if do_gzip',
    '        [~, fname, fext] = fileparts(fname); % get .nii .img .hdr',
    '    end',
    '    if isempty(fext), fext = \'.nii\'; end % default single .nii file',
    '    fname = fullfile(pth, fname); % without file ext',
    '    isNii = strcmpi(fext, \'.nii\'); % will use .img/.hdr if not .nii',
    '    ',
    '    % Deal with NIfTI version and sizeof_hdr',
    '    niiVer = para.version;',
    '    if isfield(nii.hdr, \'version\'), niiVer = nii.hdr.version; end',
    '    if niiVer == 1',
    '        nii.hdr.sizeof_hdr = 348; % in case it was loaded from other version',
    '    elseif niiVer == 2',
    '        nii.hdr.sizeof_hdr = 540; % version 2',
    '    else ',
    '        error(\'Unsupported NIfTI version: %g\', niiVer);',
    '    end',
    '    ',
    '    if niiVer ~= para.version',
    '        C0 = niiHeader(niiVer);',
    '    else',
    '        C0 = C;',
    '    end',
    '    ',
    '    % Update datatype/bitpix/dim in case nii.img is changed',
    '    [nii, fmt] = img2datatype(nii, para);',
    '',
    '    % This \'if\' block: lazy implementation SPM: split to 3D files',
    '    if nargin>3 && ~isempty(varargin{3}) && varargin{3} && nii.hdr.dim(5)>1',
    '        if do_gzip, fext = [fext \'.gz\']; end',
    '        nii0 = nii;',
    '        for i = 1:nii.hdr.dim(5)',
    '            fname0 = sprintf(\'%s_%05g%s\', fname, i, fext);',
    '            nii0.img = nii.img(:,:,:,i,:,:,:,:); % one vol',
    '            if i==1 && isfield(nii, \'ext\'), nii0.ext = nii.ext;',
    '            elseif i==2 && isfield(nii0, \'ext\'), nii0 = rmfield(nii0, \'ext\'); ',
    '            end',
    '            nii_tool(\'save\', nii0, fname0);',
    '        end',
    '        return;',
    '    end',
    '        ',
    '    % re-arrange img for special datatype: RGB/RGBA/Complex.',
    '    if any(nii.hdr.datatype == [128 511 2304]) % RGB or RGBA',
    '        if para.rgb_dim == 1 % AFNI style',
    '            nii.img = permute(nii.img, [8 1:7]);',
    '        elseif para.rgb_dim == 3 % old mricron style',
    '            nii.img = permute(nii.img, [1 2 8 3:7]);',
    '        elseif para.rgb_dim == 4 % for fslview',
    '            nii.img = permute(nii.img, [1:3 8 4:7]); % violate nii rule',
    '            dim = size(nii.img);',
    '            if numel(dim)>6 % dim7 is not 1',
    '                i = find(dim(5:7)==1, 1, \'last\') + 4;',
    '                nii.img = permute(nii.img, [1:i-1 i+1:8 i]);',
    '            end',
    '            nii = img2datatype(nii, para); % changed to non-RGB datatype',
    '        end',
    '    elseif any(nii.hdr.datatype == [32 1792]) % complex single/double',
    '        nii.img = [real(nii.img(:))\'; imag(nii.img(:))\'];',
    '    end',
    '    ',
    '    % Check nii extension: update esize to x16',
    '    nExt = 0; esize = 0;',
    '    nii.hdr.extension = [0 0 0 0]; % no nii ext',
    '    if isfield(nii, \'ext\') && isstruct(nii.ext) ...',
    '            && isfield(nii.ext(1), \'edata\') && ~isempty(nii.ext(1).edata)',
    '        nExt = length(nii.ext);',
    '        nii.hdr.extension = [1 0 0 0]; % there is nii ext',
    '        for i = 1:nExt',
    '            if ~isfield(nii.ext(i), \'ecode\') || ~isfield(nii.ext(i), \'edata\')',
    '                error(\'NIfTI header ext struct must have ecode and edata\');',
    '            end',
    '            ',
    '            n0 = numel(nii.ext(i).edata) + 8; % 8 byte for esize and ecode',
    '            n1 = ceil(n0/16) * 16; % esize: multiple of 16',
    '            nii.ext(i).esize = n1;',
    '            nii.ext(i).edata(end+(1:n1-n0)) = 0; % pad zeros',
    '            esize = esize + n1;',
    '        end',
    '    end',
    '    ',
    '    % Set magic, vox_offset, and open file for .nii or .hdr',
    '    if isNii',
    '        % version 1 will take only the first 4',
    '        nii.hdr.magic = sprintf(\'n+%g%s\', niiVer, char([0 13 10 26 10]));',
    '        nii.hdr.vox_offset = nii.hdr.sizeof_hdr + 4 + esize;',
    '        fid = fopen([fname fext], \'w\');',
    '    else',
    '        nii.hdr.magic = sprintf(\'ni%g%s\', niiVer, char([0 13 10 26 10]));',
    '        nii.hdr.vox_offset = 0;',
    '        fid = fopen([fname \'.hdr\'], \'w\');',
    '    end',
    '    ',
    '    % Write nii hdr',
    '    for i = 1:size(C0,1)',
    '        if isfield(nii.hdr, C0{i,1})',
    '            val = nii.hdr.(C0{i,1});',
    '        else % niiVer=2 omit some fields, also take care of other cases',
    '            val = C0{i,4};',
    '        end',
    '        n = numel(val);',
    '        len = C0{i,2};',
    '        if n>len',
    '            val(len+1:n) = []; % remove extra, normally for char',
    '        elseif n<len',
    '            val(n+1:len) = 0; % pad 0, normally for char',
    '        end',
    '        fwrite(fid, val, C0{i,3});',
    '    end',
    '    ',
    '    % Write nii ext: extension is in hdr',
    '    for i = 1:nExt % nExt may be 0',
    '        fwrite(fid, nii.ext(i).esize, \'int32\');',
    '        fwrite(fid, nii.ext(i).ecode, \'int32\');',
    '        fwrite(fid, nii.ext(i).edata, \'uint8\');',
    '    end',
    '    ',
    '    if ~isNii',
    '        fclose(fid); % done with .hdr',
    '        fid = fopen([fname \'.img\'], \'w\');',
    '    end',
    '',
    '    % Write nii image',
    '    fwrite(fid, nii.img, fmt);',
    '    fclose(fid); % all written',
    '',
    '    % gzip if asked',
    '    if do_gzip',
    '        if isNii',
    '            gzipOS([fname \'.nii\']);',
    '        else',
    '            gzipOS([fname \'.hdr\']); % better not to compress .hdr',
    '            gzipOS([fname \'.img\']);',
    '        end',
    '    end',
    '    ',
    'elseif strcmpi(cmd, \'hdr\')',
    '    if nargin<2, error(\'nii_tool(\'\'%s\'\') needs second input\', cmd); end',
    '    if ~ischar(varargin{1})',
    '        error(\'nii_tool(\'\'hdr\'\') needs nii file name as second input\'); ',
    '    end',
    '    ',
    '    fname = nii_name(varargin{1}, \'.hdr\'); % get .hdr if it is .img',
    '    [fid, clnObj, niiVer] = fopen_nii(fname); %#ok<ASGLU>',
    '    varargout{1} = read_hdr(fid, niiVer, C, fname);',
    '   ',
    'elseif any(strcmpi(cmd, {\'ext\' \'img\' \'load\'})) ',
    '    if nargin<2, error(\'nii_tool(\'\'%s\'\') needs second input\', cmd); end',
    '    if ischar(varargin{1})',
    '        fname = nii_name(varargin{1}, \'.hdr\');',
    '    elseif isstruct(varargin{1}) && isfield(varargin{1}, \'file_name\')',
    '        fname = varargin{1}.file_name;',
    '    else        ',
    '        error([\'nii_tool(\'\'%s\'\') needs a file name or hdr struct from \' ...',
    '            \'nii_tool(\'\'hdr\'\') as second input\'], cmd); ',
    '    end',
    '    ',
    '    [fid, clnObj, niiVer, isNii] = fopen_nii(fname); %#ok<ASGLU>',
    '    nii.hdr = read_hdr(fid, niiVer, C, fname);',
    '    ',
    '    if strcmpi(cmd, \'ext\') || strcmpi(cmd, \'load\') ',
    '        if ~isempty(nii.hdr.extension) && nii.hdr.extension(1)',
    '            nii.ext = read_ext(fid, nii.hdr);',
    '            if strcmpi(cmd, \'ext\')',
    '                varargout{1} = nii.ext;',
    '                return; ',
    '            end',
    '        elseif strcmpi(cmd, \'ext\')',
    '            varargout{1} = []; ',
    '            return; ',
    '        end',
    '    end',
    '    ',
    '    if strcmpi(cmd, \'load\') || strcmpi(cmd, \'img\')',
    '        if ~isNii % close .hdr file, and open .img file',
    '            fname = nii_name(fname, \'.img\');',
    '            [fid, clnObj] = fopen_nii(fname, nii.hdr.machine); %#ok<NASGU>',
    '        end',
    '        nii.img = read_img(fid, nii.hdr, para);',
    '        if strcmpi(cmd, \'img\')',
    '            varargout{1} = nii.img;',
    '        else % load',
    '            varargout{1} = nii;',
    '        end',
    '    end',
    'elseif strcmpi(cmd, \'RGBStyle\')',
    '    styles = {\'afni\' \'\' \'mricron\' \'fsl\'};',
    '    curStyle = styles{para.rgb_dim};',
    '    if nargin<2, varargout{1} = curStyle; return; end % query only',
    '    irgb = varargin{1};',
    '    if isempty(irgb), irgb = 1; end % default as \'afni\'',
    '    if ischar(irgb)',
    '        if strncmpi(irgb, \'fsl\', 3), irgb = 4;',
    '        elseif strncmpi(irgb, \'mricron\', 4), irgb = 3;',
    '        else irgb = 1;',
    '        end',
    '    end',
    '    if ~any(irgb == [1 3 4])',
    '        error(\'nii_tool(\'\'RGBStyle\'\') can have 1, 3, or 4 as second input\'); ',
    '    end',
    '    if nargout, varargout{1} = curStyle; end % return old one',
    '    para.rgb_dim = irgb;',
    'elseif strcmpi(cmd, \'cat3D\')',
    '    if nargin<2, error(\'nii_tool(\'\'%s\'\') needs second input\', cmd); end',
    '    fnames = varargin{1};',
    '    if ischar(fnames) % guess it is like run1*.nii',
    '        f = dir(fnames);',
    '        f = sort({f.name});',
    '        fnames = strcat([fileparts(fnames) \'/\'], f);',
    '    end',
    '    ',
    '    n = length(fnames);',
    '    if n<2 || ~iscellstr(fnames)',
    '        error(\'Invalid input for nii_tool(\'\'cat3D\'\'): %s\', varargin{1});',
    '    end',
    '',
    '    nii = nii_tool(\'load\', fnames{1}); % all for first file',
    '    nii.img(:,:,:,2:n) = 0; % pre-allocate',
    '    % For now, omit all consistence check between files',
    '    for i = 2:n, nii.img(:,:,:,i) = nii_tool(\'img\', fnames{i}); end',
    '    varargout{1} = img2datatype(nii, para); % update dim',
    'elseif strcmpi(cmd, \'default\')',
    '    flds = {\'version\' \'rgb_dim\'}; % may add more in the future',
    '    for i = 1:length(flds), val.(flds{i}) = para.(flds{i}); end',
    '    if nargin<2, varargout{1} = val; return; end % query only',
    '    if nargout, varargout{1} = val; end % return old val',
    '    in2 = varargin;',
    '    if ~isstruct(in2), in2 = struct(in2{:}); end',
    '    nam = fieldnames(in2);',
    '    for i = 1:length(nam)',
    '        if strcmpi(nam{i}, \'rgb_dim\')',
    '            nii_tool(\'RGBstyle\', in2.(nam{i}));',
    '            continue;',
    '        end',
    '        ind = strcmpi(nam{i}, flds);',
    '        if isempty(ind), continue; end',
    '        para.(flds{ind}) = in2.(nam{i});',
    '    end',
    '    if val.version ~= para.version, C = niiHeader(para.version); end',
    '    ',
    '    fname = [fileparts(which(mfilename)) \'/nii_tool_para.mat\'];',
    '    fid = fopen(fname, \'w\'); % check writing permission',
    '    if fid<1',
    '        fname = [getenv(\'HOME\') \'/nii_tool_para.mat\'];',
    '    else',
    '        fclose(fid);',
    '    end',
    '    try',
    '        save(fname, \'-struct\', \'para\', flds{:}); % overwrite',
    '    catch me',
    '        fprintf(2, \'Failed to save default parameters for future use.\\n\');',
    '        fprintf(2, \'%s\\n\', me.message);',
    '    end',
    'elseif strcmpi(cmd, \'func_handle\') % make a local function avail to outside ',
    '    varargout{1} = eval([\'@\' varargin{1}]);',
    'else',
    '    error(\'Invalid command for nii_tool: %s\', cmd);',
    'end',
    '% End of main function',
    '',
    '%% Subfunction: all nii header in the order in NIfTI-1/2 file',
    'function [C, para] = niiHeader(niiVer)',
    'rgb_dim = 1;',
    'if nargin<1 || isempty(niiVer)',
    '    fname = [getenv(\'HOME\') \'/nii_tool_para.mat\'];',
    '    if ~exist(fname, \'file\')',
    '        fname = [fileparts(which(mfilename)) \'/nii_tool_para.mat\'];',
    '    end',
    '',
    '    try',
    '        val = load(fname);',
    '        niiVer = val.version;',
    '        rgb_dim = val.rgb_dim;',
    '    catch',
    '        niiVer = 1;',
    '    end',
    'end',
    '',
    'if niiVer == 1',
    '    C = {',
    '    % name              len  format     value           offset',
    '    \'sizeof_hdr\'        1   \'int32\'     348             0',
    '    \'data_type\'         10  \'char*1\'    \'\'              4                                          ',
    '    \'db_name\'           18  \'char*1\'    \'\'              14',
    '    \'extents\'           1   \'int32\'     16384           32',
    '    \'session_error\'     1   \'int16\'     0               36',
    '    \'regular\'           1   \'char*1\'    \'r\'             38',
    '    \'dim_info\'          1   \'uint8\'     0               39',
    '    \'dim\'               8   \'int16\'     ones(1,8)       40',
    '    \'intent_p1\'         1   \'single\'    0               56',
    '    \'intent_p2\'         1   \'single\'    0               60',
    '    \'intent_p3\'         1   \'single\'    0               64',
    '    \'intent_code\'       1   \'int16\'     0               68',
    '    \'datatype\'          1   \'int16\'     0               70',
    '    \'bitpix\'            1   \'int16\'     0               72',
    '    \'slice_start\'       1   \'int16\'     0               74',
    '    \'pixdim\'            8   \'single\'    zeros(1,8)      76',
    '    \'vox_offset\'        1   \'single\'    0               108',
    '    \'scl_slope\'         1   \'single\'    1               112',
    '    \'scl_inter\'         1   \'single\'    0               116',
    '    \'slice_end\'         1   \'int16\'     0               120',
    '    \'slice_code\'        1   \'uint8\'     0               122',
    '    \'xyzt_units\'        1   \'uint8\'     0               123',
    '    \'cal_max\'           1   \'single\'    0               124',
    '    \'cal_min\'           1   \'single\'    0               128',
    '    \'slice_duration\'    1   \'single\'    0               132',
    '    \'toffset\'           1   \'single\'    0               136',
    '    \'glmax\'             1   \'int32\'     0               140',
    '    \'glmin\'             1   \'int32\'     0               144',
    '    \'descrip\'           80  \'char*1\'    \'\'              148',
    '    \'aux_file\'          24  \'char*1\'    \'\'              228',
    '    \'qform_code\'        1   \'int16\'     0               252',
    '    \'sform_code\'        1   \'int16\'     0               254',
    '    \'quatern_b\'         1   \'single\'    0               256',
    '    \'quatern_c\'         1   \'single\'    0               260',
    '    \'quatern_d\'         1   \'single\'    0               264',
    '    \'qoffset_x\'         1   \'single\'    0               268',
    '    \'qoffset_y\'         1   \'single\'    0               272',
    '    \'qoffset_z\'         1   \'single\'    0               276',
    '    \'srow_x\'            4   \'single\'    [1 0 0 0]       280',
    '    \'srow_y\'            4   \'single\'    [0 1 0 0]       296',
    '    \'srow_z\'            4   \'single\'    [0 0 1 0]       312',
    '    \'intent_name\'       16  \'char*1\'    \'\'              328',
    '    \'magic\'             4   \'char*1\'    \'\'              344',
    '    \'extension\'         4   \'uint8\'     [0 0 0 0]       348',
    '    };',
    '',
    'elseif niiVer == 2',
    '    C = {',
    '    \'sizeof_hdr\'        1   \'int32\'     540             0',
    '    \'magic\'             8   \'char*1\'    \'\'              4',
    '    \'datatype\'          1   \'int16\'     0               12',
    '    \'bitpix\'            1   \'int16\'     0               14',
    '    \'dim\'               8   \'int64\'     ones(1,8)       16',
    '    \'intent_p1\'         1   \'double\'    0               80',
    '    \'intent_p2\'         1   \'double\'    0               88',
    '    \'intent_p3\'         1   \'double\'    0               96',
    '    \'pixdim\'            8   \'double\'    zeros(1,8)      104',
    '    \'vox_offset\'        1   \'int64\'     0               168',
    '    \'scl_slope\'         1   \'double\'    1               176',
    '    \'scl_inter\'         1   \'double\'    0               184',
    '    \'cal_max\'           1   \'double\'    0               192',
    '    \'cal_min\'           1   \'double\'    0               200',
    '    \'slice_duration\'    1   \'double\'    0               208',
    '    \'toffset\'           1   \'double\'    0               216',
    '    \'slice_start\'       1   \'int64\'     0               224',
    '    \'slice_end\'         1   \'int64\'     0               232',
    '    \'descrip\'           80  \'char*1\'    \'\'              240',
    '    \'aux_file\'          24  \'char*1\'    \'\'              320',
    '    \'qform_code\'        1   \'int32\'     0               344',
    '    \'sform_code\'        1   \'int32\'     0               348',
    '    \'quatern_b\'         1   \'double\'    0               352',
    '    \'quatern_c\'         1   \'double\'    0               360',
    '    \'quatern_d\'         1   \'double\'    0               368',
    '    \'qoffset_x\'         1   \'double\'    0               376',
    '    \'qoffset_y\'         1   \'double\'    0               384',
    '    \'qoffset_z\'         1   \'double\'    0               392',
    '    \'srow_x\'            4   \'double\'    [1 0 0 0]       400',
    '    \'srow_y\'            4   \'double\'    [0 1 0 0]       432',
    '    \'srow_z\'            4   \'double\'    [0 0 1 0]       464',
    '    \'slice_code\'        1   \'int32\'     0               496',
    '    \'xyzt_units\'        1   \'int32\'     0               500',
    '    \'intent_code\'       1   \'int32\'     0               504',
    '    \'intent_name\'       16  \'char*1\'    \'\'              508',
    '    \'dim_info\'          1   \'uint8\'     0               524',
    '    \'unused_str\'        15  \'char*1\'    0               525',
    '    \'extension\'         4   \'uint8\'     [0 0 0 0]       540',
    '    };',
    'else',
    '    error(\'Nifti version %g is not supported\', niiVer);',
    'end',
    'if nargout<2, return; end',
    '',
    '%   class      datatype bitpix  valpix',
    'D = {',
    '    \'ubit1\'     1       1       1 % neither mricron nor fsl support this',
    '    \'uint8\'     2       8       1',
    '    \'int16\'     4       16      1',
    '    \'int32\'     8       32      1',
    '    \'single\'    16      32      1',
    '    \'single\'    32      64      2 % complex',
    '    \'double\'    64      64      1',
    '    \'uint8\'     128     24      3 % RGB',
    '    \'int8\'      256     8       1',
    '    \'single\'    511     96      3 % RGB, not in NIfTI standard?',
    '    \'uint16\'    512     16      1',
    '    \'uint32\'    768     32      1',
    '    \'int64\'     1024    64      1',
    '    \'uint64\'    1280    64      1',
    '%     \'float128\'  1536    128     1 % long double, for 22nd century?',
    '    \'double\'    1792    128     2 % complex',
    '%     \'float128\'  2048    256     2 % long double complex',
    '    \'uint8\'     2304    32      4 % RGBA',
    '    };',
    '',
    'para.format   =  D(:,1)\';',
    'para.datatype = [D{:,2}];',
    'para.bitpix   = [D{:,3}];',
    'para.valpix   = [D{:,4}];',
    'para.rgb_dim  = rgb_dim; % dim of RGB/RGBA in NIfTI FILE',
    'para.version  = niiVer;',
    '',
    '%% Subfunction: update hdr based on image class for \'init\' and \'save\'',
    'function [nii, fmt] = img2datatype(nii, para)',
    'dim = size(nii.img);',
    'ndim = numel(dim);',
    'dim(ndim+1:7) = 1;',
    '',
    'if ndim == 8 % RGB/RGBA data, we change img type to uint8 or single if needed',
    '    valpix = dim(8);',
    '    if valpix == 4 % RGBA',
    '        typ = \'RGBA\'; % error info only',
    '        nii.img = uint8(nii.img); % NIfTI only support uint8 for RGBA',
    '    elseif valpix == 3 % RGB, must be single or uint8',
    '        typ = \'RGB\';',
    '        if max(nii.img(:))>1, nii.img = uint8(nii.img);',
    '        else nii.img = single(nii.img);',
    '        end',
    '    else',
    '        error(\'Color dimension must have length of 3 for RGB and 4 for RGBA\');',
    '    end',
    '',
    '    dim(8) = []; % remove color-dim so numel(dim)=7 for nii.hdr',
    '    ndim = find(dim>1, 1, \'last\'); % update it',
    'elseif isreal(nii.img)',
    '    typ = \'real\';',
    '    valpix = 1; ',
    'else',
    '    typ = \'complex\';',
    '    valpix = 2; ',
    'end',
    '',
    'if islogical(nii.img), imgFmt = \'ubit1\'; ',
    'else imgFmt = class(nii.img);',
    'end',
    'ind = find(strcmp(para.format, imgFmt) & para.valpix==valpix);',
    '',
    'if isempty(ind) % only RGB and complex can have this problem',
    '    error(\'nii_tool does not support %s image of \'\'%s\'\' type\', typ, imgFmt);',
    'elseif numel(ind)>1 % unlikely',
    '    error(\'Non-unique datatype found for %s image of \'\'%s\'\' type\', typ, imgFmt);',
    'end',
    '',
    'fmt = para.format{ind};',
    'nii.hdr.datatype = para.datatype(ind);',
    'nii.hdr.bitpix = para.bitpix(ind);',
    'nii.hdr.dim = [ndim dim];',
    '',
    'if nii.hdr.sizeof_hdr == 348',
    '    nii.hdr.glmax = round(double(max(nii.img(:)))); % we may remove these',
    '    nii.hdr.glmin = round(double(min(nii.img(:))));',
    'end',
    '',
    '%% Subfunction: use pigz or system gzip if available (faster)',
    'function gzipOS(fname)',
    'persistent cmd; % command to run gzip',
    'if isempty(cmd)',
    '    cmd = check_gzip;',
    '    if ischar(cmd)',
    '    	cmd = [cmd \' -f \']; % overwrite if exist',
    '    elseif islogical(cmd) && ~cmd',
    '        fprintf(2, [\'None of system pigz, gzip or Matlab gzip available. \' ...',
    '            \'Files are not compressed into gz.\\n\']);',
    '    end',
    'end',
    '',
    'if islogical(cmd)',
    '    if cmd, gzip(fname); delete(fname); end',
    '    return;',
    'end',
    'if ispc',
    '	[err, str] = system([\'start "" /B \' cmd \'"\' fname \'"\']); % background',
    'else',
    '    [err, str] = system([cmd \'"\' fname \'" &\']);',
    'end',
    '% [err, str] = system([cmd \'"\' fname \'"\']);',
    'if err, errorLog([\'Error during compression: \' str]); end',
    '',
    '% Deal with pigz/gzip on path or in nii_tool folder, and matlab gzip/gunzip',
    'function cmd = check_gzip',
    '% first, try system pigz',
    '[err, ~] = system(\'pigz -V 2>&1\');',
    'if ~err, cmd = \'pigz -n\'; return; end',
    '',
    '% next, try pigz included with nii_tool',
    'm_dir = fileparts(which(mfilename));',
    'if ismac % pigz for mac is not included in the package',
    '    fprintf(2, [\' Please install pigz for fast compression: \' ...',
    '        \'http://rudix.org/packages/pigz.html\\n\']);',
    'elseif ispc % rename back pigz for Windows. Renamed to trick Matlab Central',
    '    try %#ok<TRYNC>',
    '        fname = [m_dir \'\\pigz.win\'];',
    '        if exist(fname, \'file\')',
    '            movefile(fname, [m_dir \'\\pigz.exe\'], \'f\');',
    '        end',
    '        fname = [m_dir \'\\pthreadGC2.win\'];',
    '        if exist(fname, \'file\')',
    '            movefile(fname, [m_dir \'\\pthreadGC2.dll\'], \'f\');',
    '        end',
    '    end',
    'end',
    '',
    'cmd = fullfile(m_dir, \'pigz -n\');',
    '[err, ~] = system([cmd \' -V 2>&1\']);',
    'if ~err, return; end',
    '',
    '% Third, try system gzip',
    '[err, ~] = system(\'gzip -V 2>&1\'); % gzip on system path?',
    'if ~err, cmd = \'gzip -n\'; return; end',
    '',
    '% Lastly, try to use Matlab gzip/gunzip. Check only one, since they are paired',
    'if isempty(which(\'gunzip\')) || ~usejava(\'jvm\')',
    '    cmd = false; % none of de/compress tools available',
    '    return;',
    'end',
    '    ',
    'cmd = true; % use slower matlab gzip/gunzip',
    '',
    '%% Try to use in order of pigz, system gunzip, then matlab gunzip',
    'function outName = gunzipOS(fname)',
    'persistent cmd; % command to run gupzip',
    'if isempty(cmd)',
    '    cmd = check_gzip;',
    '    if ischar(cmd)',
    '    	cmd = [cmd \' -f -d \']; % overwrite if exist',
    '    elseif islogical(cmd) && ~cmd',
    '        error(\'None of system pigz, gunzip or Matlab gunzip is available\');',
    '    end',
    'end',
    'pth = tempdir; % unzip into temp dir',
    '',
    'if islogical(cmd)',
    '    if cmd, outName = gunzip(fname, pth); end',
    '    return;',
    'end',
    '',
    '[pth1, outName, ext] = fileparts(fname);',
    'outName = fullfile(pth, outName);',
    'if ~strcmp([pth1 filesep], pth), copyfile(fname, [outName ext], \'f\'); end',
    '[err, str] = system([cmd \'"\' outName ext \'"\']); % overwrite if exist',
    'if err, fprintf(2, \'Error during decompression:\\n%s\\n\', str); end',
    '',
    '%% subfunction: read hdr',
    'function hdr = read_hdr(fid, niiVer, C, fname)',
    'if niiVer>1, C = niiHeader(niiVer); end % C defaults for version 1',
    'fseek(fid, 0, \'bof\');',
    'for i = 1:size(C,1)',
    '    hdr.(C{i,1}) = fread(fid, C{i,2}, C{i,3})\';',
    '    if strcmp(C{i,3}, \'char*1\')',
    '        hdr.(C{i,1}) = deblank(char(hdr.(C{i,1})));',
    '    end',
    'end',
    '',
    'hdr.version = niiVer; % for \'save\', unless user asks to change',
    '[~, ~, hdr.machine]= fopen(fid); % use it for .img file',
    '',
    '[pth, nam, ext] = fileparts(fname); % fname may be .gz',
    'if isempty(pth)',
    '    [pth, nam, ext] = fileparts(which(fname)); % in current folder or path',
    'end',
    'pth = fullfile(getfield(what(pth), \'path\')); % full path',
    'hdr.file_name = fullfile(pth, [nam ext]); % fname with full path',
    '',
    '%% subfunction: read ext, and decode it if known ecode',
    'function ext = read_ext(fid, hdr)',
    'ext = []; % to avoid error, such as no ext but hdr.extension(1) was set',
    'fseek(fid, hdr.sizeof_hdr+4, \'bof\'); % +4 skip hdr.extension',
    'nEnd = hdr.vox_offset;',
    'if nEnd == 0 % .hdr file',
    '    nEnd = getfield(dir(fopen(fid)), \'bytes\'); % total bytes of the .hdr file',
    'end',
    'i = 1; % nExt. It would be nice if hdr.extension(2) stores nExt',
    'while ftell(fid) < nEnd',
    '    esize = fread(fid, 1, \'int32\'); % multiple of 16',
    '    if isempty(esize) || mod(esize,16), break; end % just to be safe',
    '    ext(i).esize = esize; %#ok<*AGROW>',
    '    ext(i).ecode = fread(fid, 1, \'int32\'); ',
    '    ext(i).edata = fread(fid, ext(i).esize-8, \'*uint8\'); % -8 for esize & ecode',
    '',
    '    % Decode edata if we know ecode',
    '    if ext(i).ecode == 40 % Matlab: any kind of matlab variable',
    '        nByte = typecast(ext(i).edata(1:4), \'int32\'); % num of bytes of MAT data',
    '        if strcmp(hdr.machine, \'ieee-be\'), nByte = swapbytes(nByte); end',
    '        tmp = [tempname \'.mat\']; % temp MAT file to save edata',
    '        fid1 = fopen(tmp, \'w\');',
    '        fwrite(fid1, ext(i).edata(5:nByte+4)); % exclude padded zeros',
    '        fclose(fid1);',
    '        deleteMat = onCleanup(@() delete(tmp)); % delete temp file after done',
    '        ext(i).edata_decoded = load(tmp); % load into struct',
    '    elseif ext(i).ecode == 6 % plain text',
    '        str = char(ext(i).edata\');',
    '        if isempty(strfind(str, \'dicm2nii.m\'))',
    '            ext(i).edata_decoded = deblank(str);',
    '        else % created by dicm2nii.m',
    '            ss = struct;',
    '            ind = strfind(str, [\';\' char([0 10])]); % strsplit error in Octave',
    '            ind = [-2 ind]; % -2+3=1: start of first para',
    '            for j = 1:numel(ind)-1',
    '                a = str(ind(j)+3 : ind(j+1));',
    '                a(a==0) = []; % to be safe. strtrim wont remove null',
    '                a = strtrim(a);',
    '                if isempty(a), continue; end',
    '                try ',
    '                    eval([\'ss.\' a]); % put all into struct',
    '                catch me',
    '                    fprintf(2, \'%s\\n\', me.message);',
    '                    fprintf(2, \'Unrecognized text: %s\\n\', a);',
    '                end',
    '            end',
    '            flds = fieldnames(ss); % make all vector column',
    '            for j = 1:length(flds)',
    '                val = ss.(flds{j});',
    '                if isnumeric(val) && isrow(val), ss.(flds{j}) = val\'; end',
    '            end',
    '            ext(i).edata_decoded = ss;',
    '        end',
    '    elseif ext(i).ecode == 4 % AFNI',
    '        ext(i).edata_decoded = deblank(char(ext(i).edata)\');',
    '    elseif ext(i).ecode == 2 % dicom',
    '        no_dicm_hdr = isempty(which(\'dicm_hdr\'));',
    '        if no_dicm_hdr && isempty(which(\'dicominfo\')), return; end ',
    '        tmp = [tempname \'.dcm\'];',
    '        fid1 = fopen(tmp, \'w\');',
    '        fwrite(fid1, ext(i).edata);',
    '        fclose(fid1);',
    '        deleteDcm = onCleanup(@() delete(tmp));',
    '        if no_dicm_hdr',
    '            ext(i).edata_decoded = dicominfo(tmp);',
    '        else',
    '            ext(i).edata_decoded = dicm_hdr(tmp);',
    '        end',
    '    end',
    '    i = i + 1;',
    'end',
    '',
    '%% subfunction: read img',
    'function img = read_img(fid, hdr, para)',
    'ind = para.datatype == hdr.datatype;',
    'if ~any(ind)',
    '    error(\'Datatype %g is not supported by nii_tool.\', hdr.datatype);',
    'end',
    '',
    'dim = hdr.dim(2:8);',
    'dim(hdr.dim(1)+1:7) = 1; % avoid some error in file',
    'dim(dim<1) = 1;',
    'valpix = para.valpix(ind);',
    'n = prod(dim); % num of values',
    'fseek(fid, hdr.vox_offset, \'bof\');',
    'img = fread(fid, n*valpix, [\'*\' para.format{ind}]); % * to keep original class',
    '',
    'if any(hdr.datatype == [128 511 2304]) % RGB or RGBA',
    '    a = reshape(single(img), valpix, n); % assume rgbrgbrgb...',
    '    d1 = abs(a - a(:,[2:end 1])); % how similar are voxels to their neighbor',
    '    a = reshape(a, prod(dim(1:2)), valpix*prod(dim(3:7))); % rr...rgg...gbb...b',
    '    d2 = abs(a - a([2:end 1],:));',
    '    j = (sum(d1(:))>sum(d2(:)))*2 + 1; % 1 for afni, 3 for mricron',
    '    dim = [dim(1:j-1) valpix dim(j:7)]; % length=8 now',
    '    img = reshape(img, dim);',
    '    img = permute(img, [1:j-1 j+1:8 j]); % put RGB(A) to dim8',
    'elseif any(hdr.datatype == [32 1792]) % complex single/double',
    '    img = reshape(img, [2 dim]);',
    '    img = complex(permute(img(1,:,:,:,:,:,:,:), [2:8 1]), ... % real',
    '                  permute(img(2,:,:,:,:,:,:,:), [2:8 1]));    % imag',
    'else % all others: valpix=1',
    '    if hdr.datatype==1, img = logical(img); end',
    '    img = reshape(img, dim);',
    'end',
    '',
    '%% Return requested fname with ext, useful for .hdr and .img files',
    'function fname = nii_name(fname, ext)',
    '[~, f, e] = fileparts(fname);',
    'n = length(fname);',
    'if strcmpi(e, \'.gz\')',
    '    n = n - 3; % 3 is length(\'.gz\')',
    '    [~, ~, e] = fileparts(f); % .nii/.hdr/.img',
    'end',
    'if strcmpi(e, \'.nii\') || strcmpi(e, ext), return; end',
    'if ~strcmpi(e, \'.hdr\') && ~strcmpi(e, \'.img\')',
    '    error([\'Invalid NIfTI file name: \' fname]); ',
    'end',
    'fname(n+(-3:0)) = ext; % if not return or error, change it',
    ' ',
    '%% fopen NIfTI file, check endian, niiVer and nii/hdr by \'magic\' for header file',
    '% clnObj takes care of fclose(fid) and delete(fopen(fid)) if isGz ',
    'function [fid, clnObj, niiVer, isNii] = fopen_nii(fname, endian)',
    'if nargin<2, endian = \'ieee-le\'; end % only provided for .img fopen',
    '[fid, err] = fopen(fname, \'r\', endian);',
    'if fid<1, error([err \': \' fname]); end',
    '',
    'n = fread(fid, 4, \'*uint8\')\'; % sizeof_hdr or signature',
    'isGz = isequal(n(1:2), [31 139]); % gz, tgz, tar file',
    'fnameIn = fname; % for error msg',
    'if isGz',
    '    fclose(fid); % close .gz file',
    '    fname = gunzipOS(fname); % guzipped file, return unzipped fname',
    '    fid = fopen(fname, \'r\', endian);',
    '    n = fread(fid, 4, \'*uint8\')\';',
    'end',
    '',
    'if nargout<3 % must return here for .img',
    '    clnObj = onCleanup(@()closeFile(fid, isGz));',
    '    return;',
    'end',
    '',
    '% NIfTI: isBigEndian = dim(1)<0 || dim(1)>7; ',
    'if isequal(n, [92 1 0 0]) % LE 348, nifti 1 ',
    '    niiVer = 1;',
    'elseif isequal(n, [0 0 1 92]) % BE 348, nifti 1',
    '    niiVer = 1;',
    '    fclose(fid);',
    '    fid = fopen(fname, \'r\', \'ieee-be\');',
    'elseif isequal(n, [28 2 0 0]) % LE 540, nifti 2',
    '    niiVer = 2;',
    'elseif isequal(n, [0 0 2 28]) % BE 540, nifti 2',
    '    niiVer = 2;',
    '    fclose(fid);',
    '    fid = fopen(fname, \'r\', \'ieee-be\');',
    'else',
    '    fclose(fid);',
    '    error(\'Not valid NIfTI file: %s\', fnameIn);',
    'end',
    'clnObj = onCleanup(@()closeFile(fid, isGz)); % return it to auto-close file',
    '',
    'if niiVer == 1, fseek(fid, 344, \'bof\'); end',
    'magic = fread(fid, 3, \'*char\')\';',
    'vStr = num2str(niiVer);',
    'if strcmp(magic, [\'n+\' vStr])',
    '    isNii = true;',
    'elseif strcmp(magic, [\'ni\' vStr])',
    '    isNii = false;',
    'else % likely wrong magic. Warn user and use file ext for nii detection',
    '    fprintf(2, \'Inconsistent sizeof_hdr and magic string for file %s\\n\', fnameIn);',
    '    fprintf(2, \'sizeof_hdr: %g; magic: %s\\n\', typecast(n, \'int32\'), magic);',
    '    isNii = strcmpi(fname(end+(-3:0)), \'.nii\');',
    'end',
    '',
    '%% fclose and delete ungzipped file if isGz',
    'function closeFile(fid, isGz)',
    'if isGz % close fid then delete tmp',
    '    fname = fopen(fid); % ungzipped file',
    '    fclose(fid);',
    '    delete(fname);',
    'else % only close fid',
    '    fclose(fid);',
    'end',
    '',
    '%% subfunction: get help for a command',
    'function subFuncHelp(mfile, subcmd)',
    'fid = fopen(which(mfile));',
    'if fid<1, error(\' %s not exists.\', mfile); end',
    'clnObj = onCleanup(@()fclose(fid));',
    'while 1 % find first % line',
    '    ln = strtrim(fgetl(fid));',
    '    if feof(fid), fprintf(2, \' No help text found.\\n\'); return; end',
    '    if ~isempty(ln) && ln(1) == \'%\', break; end',
    'end',
    '',
    'cr = char(10);',
    'str = [ln(2:end) cr];',
    'while 1',
    '    ln = strtrim(fgetl(fid));',
    '    if isempty(ln) || ln(1) ~= \'%\', break; end % first non % line',
    '    str = [str ln(2:end) cr];',
    'end',
    '',
    '% detect topic line before formating the str: try each in order',
    'topicChar = [cr \' - \']; % we rely on this for each topic: see help',
    'str = strrep(str, [cr \' -- \'], topicChar); % \' -- \' is also fine',
    'ind = strfind(str, topicChar);',
    'if isempty(ind), disp(str); return; end % no topicChar found. Show all help text',
    '',
    'fakeChar = repmat(char(1), 1, numel(topicChar));',
    'str = strrep(str, topicChar, fakeChar); % will restore later',
    '',
    '% format for reliable syntax and paragraph detection (order is important):',
    'cr1 = [cr \' \']; % cr with a space',
    'chars = {[mfile \'  \']   [mfile \' \']; % reduce multiple space after mfile to one',
    '         [mfile \' (\']   [mfile \'(\']; % remove space between mfile and (',
    '         [mfile \'( \']   [mfile \'(\']; % remove space after mfile(',
    '         [cr \'    \']    [cr char(9)]; % replace 4 space with tab for beauty',
    '         cr1            cr; % remove space after cr',
    '         };',
    'for i = 1:size(chars, 1)',
    '    while ~isempty(strfind(str, chars{i,1}))',
    '        str = strrep(str, chars{i,1}, chars{i,2}); % regexprep error in Octave',
    '    end',
    'end',
    'str = strrep(str, cr, cr1); % restore one space after cr',
    '',
    'dashes = strfind(str, fakeChar); % index for \' - \' after formating',
    'str = strrep(str, fakeChar, topicChar); % restore \' - \'',
    '',
    'prgrfs = strfind(str, [cr1 cr1]); % double blank lines',
    'nTopic = numel(dashes);',
    'topics = ones(1, nTopic+1); % syntax \'mfile(\' before each \'-\' line',
    'for i = 1:nTopic',
    '    ind = strfind(str(1:dashes(i)), [mfile \'(\']); % syntax before \' - \'',
    '    if isempty(ind), continue; end % no syntax before \' - \', assume start with 1',
    '    ind = find(prgrfs < ind(end), 1, \'last\'); % previous paragraph',
    '    if isempty(ind), continue; end',
    '    topics(i) = prgrfs(ind) + 1; % start of this topic ',
    'end',
    'topics(nTopic+1) = length(str); % set last topic to the end',
    '',
    'cmd = strrep(subcmd, \'?\', \'\'); % remove ? in case it is in subcmd',
    'if isempty(cmd) % help for main function',
    '    disp(str(1:topics(1))); % text before first topic',
    '    return;',
    'end',
    '',
    '% find a topic with cmd syntax, and the syntax is prior to \' - \'',
    'cmd = sprintf(\'%s(\'\'%s\'\'\', mfile, cmd);',
    'for i = 1:nTopic',
    '    ind = strfind(lower(str(topics(i):dashes(i))), lower(cmd));',
    '    if ~isempty(ind) % found the syntax in the topic',
    '        disp(str(topics(i):topics(i+1)));',
    '        return;',
    '    end',
    'end',
    '',
    '% if we reach here, no subcmd found in syntax',
    'fprintf(2, \' Unknown command for %s: %s\\n\', mfile, subcmd);'
  )

  dicm2nii <- c(
    'function varargout = dicm2nii(src, dataFolder, varargin)',
    '% Convert dicom and more into nii or img/hdr files. ',
    '% ',
    '% DICM2NII(dcmSource, niiFolder, outFormat, MoCoOption)',
    '% ',
    '% The input arguments are all optional:',
    '%  1. source file or folder. It can be a zip or tgz file, a folder containing',
    '%     dicom files, or other convertible files. It can also contain wildcards',
    '%     like \'run1_*\' for all files start with \'run1_\'.',
    '%  2. folder to save result files.',
    '%  3. output file format:',
    '%      0 or \'nii\'           for single nii uncompressed.',
    '%      1 or \'nii.gz\'        for single nii compressed (default).',
    '%      2 or \'hdr\'           for hdr/img pair uncompressed.',
    '%      3 or \'hdr.gz\'        for hdr/img pair compressed.',
    '%      4 or \'3D.nii\'        for 3D nii uncompressed (SPM12).',
    '%      5 or \'3D.nii.gz\'     for 3D nii compressed.',
    '%      6 or \'3D.hdr\'        for 3D hdr/img pair uncompressed (SPM8).',
    '%      7 or \'3D.hdr.gz\'     for 3D hdr/img pair compressed.',
    '%  4. MoCo series options:',
    '%      0 create files for both original and MoCo series.',
    '%      1 ignore MoCo series if both present (default).',
    '%      2 ignore original series if both present.',
    '%     Note that if only one of the two series is present, it will be converted',
    '%     always. In the future, this option may be removed, and all files will be',
    '%     converted. ',
    '% ',
    '% The optional output is converted PatientName(s).',
    '% ',
    '% Typical examples:',
    '%  dicm2nii; % bring up user interface if there is no input argument',
    '%  dicm2nii(\'D:/myProj/zip/subj1.zip\', \'D:/myProj/subj1/data\'); % zip file',
    '%  dicm2nii(\'D:/myProj/subj1/dicom/\', \'D:/myProj/subj1/data\'); % folder',
    '% ',
    '% Less useful examples:',
    '%  dicm2nii(\'D:/myProj/dicom/\', \'D:/myProj/subj2/data\', \'nii\'); % no gz compress',
    '%  dicm2nii(\'D:/myProj/dicom/run2*\', \'D:/myProj/subj/data\'); % convert run2 only',
    '%  dicm2nii(\'D:/dicom/\', \'D:/data\', \'3D.nii\'); % SPM style files',
    '% ',
    '% If there is no input, or any of the first two input is empty, the graphic user',
    '% interface will appear.',
    '% ',
    '% If the first input is a zip/tgz file, such as those downloaded from dicom',
    '% server, DICM2NII will extract files into a temp folder, create NIfTI files',
    '% into the data folder, and then delete the temp folder. For this reason, it is',
    '% better to keep the compressed file as backup.',
    '% ',
    '% If a folder is the data source, DICM2NII will convert all files in the folder',
    '% and its subfolders (there is no need to sort files for different series).',
    '% ',
    '% Please note that, if a file in the middle of a series is missing, the series',
    '% will normally be skipped without converting, and a warning message in red text',
    '% will be shown in Command Windows, and the message will also be saved into a',
    '% text file under the data folder.',
    '% ',
    '% For MoCo series, motion parameters, RBMoCoTrans and RBMoCoRot, are also saved.',
    '% ',
    '% A Matlab data file, dcmHeaders.mat, is always saved into the data folder. This',
    '% file contains dicom header from the first file for created series and some',
    '% information from last file in field LastFile. Some extra information may also',
    '% be saved into this file.',
    '% ',
    '% Slice timing information, if available, is stored in nii header, such as',
    '% slice_code and slice_duration. But the simple way may be to use the field',
    '% SliceTiming in dcmHeaders.mat. That timing is actually those numbers for FSL',
    '% when using custom slice timing. This is the universal method to specify any',
    '% kind of slice order, and for now, is the only way which works for multiband.',
    '% Slice order is one of the most confusing parameters, and it is recommended to',
    '% use this method to avoid mistake. Following shows how to convert this timing',
    '% into slice timing in ms and slice order for SPM:',
    '%   ',
    '%  load(\'dcmHeaders.mat\'); % or drag and drop the MAT file into Matlab',
    '%  s = h.myFuncSeries; % field name is the same as nii file name',
    '%  spm_ms = (0.5 - s.SliceTiming) * s.RepetitionTime;',
    '%  [~, spm_order] = sort(-s.SliceTiming);',
    '% ',
    '% Some information, such as TE, phase encoding direction and effective dwell',
    '% time are stored in descrip of nii header. These are useful for fieldmap B0',
    '% unwarp correction. Acquisition start time and date are also stored, and this',
    '% may be useful if one wants to align the functional data to some physiological',
    '% recording, like pulse, respiration or ECG.',
    '% ',
    '% If there is DTI series, bval and bvec files will be generated for FSL etc. For',
    '% DTI series, B_value and DiffusionGradientDirection for all directions are',
    '% saved into the dcmHeaders.mat file.',
    '% ',
    '% Starting from 20150514, the converter stores some useful information in NIfTI',
    '% text extension (ecode=6). nii_tool can decode these information easily:',
    '%  ext = nii_tool(\'ext\', \'myNiftiFile.nii\'); % read NIfTI extension',
    '% ext.edata_decoded contains all above mentioned information, and more.',
    '% ',
    '% Please note that some information, such as the slice order information, phase',
    '% encoding direction and DTI bvec are in image reference, rather than NIfTI',
    '% coordinate system. This is because most analysis packages require information',
    '% in image space. For this reason, in case the image in a NIfTI file is flipped',
    '% or re-oriented, these information may not be correct anymore.',
    '% ',
    '% The output file names adopt SeriesDescription or ProtocolName of each series',
    '% used on scanner console. If both original and MoCo series are requested,',
    '% \'_MoCo\' will be appended for MoCo series. For phase image, such as those from',
    '% field map, \'_phase\' will be appended to the name. If multiple subjects data',
    '% are mixed (strongly discouraged), subject name will be in file name. In case',
    '% of name conflict, SeriesNumber, such as \'_s005\', will be appended to make file',
    '% names unique. It is suggested to use short and descriptive SeriesDescription',
    '% on the scanner console, and use names containing only letters, numbers and',
    '% underscores.',
    '% ',
    '% For SPM 3D files, the file names will have volume index in format of \'_00001\'',
    '% appended to above name.',
    '% ',
    '% Please report any bug to xiangrui.li@gmail.com or at',
    '% http://www.mathworks.com/matlabcentral/fileexchange/42997',
    '',
    '% Thanks to:',
    '% Jimmy Shen\'s Tools for NIfTI and ANALYZE image,',
    '% Chris Rorden\'s dcm2nii pascal source code,',
    '% Przemyslaw Baranski for direction cosine matrix to quaternions. ',
    '',
    '% History (yymmdd):',
    '% 130512 Publish to CCBBI users (Xiangrui Li).',
    '% 130513 Convert img from uint16 to int16 if range allows;',
    '%        Support output file format of img/hdr/mat.',
    '% 130515 Change creation order to acquisition order (more natural).',
    '%        If MoCo series is included, append _MoCo in file names.',
    '% 130516 Use SpacingBetweenSlices, if exists, for SliceThickness. ',
    '% 130518 Use NumberOfImagesInMosaic in CSA header (work for some old data).',
    '% 130604 Add scl_inter/scl_slope and special naming for fieldmap.',
    '% 130614 Work out the way to get EffectiveEchoSpacing for B0 unwarp.',
    '% 130616 Add needed dicom field check, so it won\'t err later.',
    '% 130618 Reorient if non-mosaic or slice_dim is still 3 and no slice flip.',
    '% 130619 Simplify DERIVED series detection. No \'_mag\' in fieldmap name.',
    '% 130629 Improve the method to get phase direction;',
    '%        Permute img dim1&2 (no -90 rotation) & simplify xform accordingly.',
    '% 130711 Make MoCoOption smarter: create nii if only 1 of 2 series exists.',
    '% 130712 Remove 5th input (allHeader). Save memory by using partial header.',
    '% 130712 Bug fix: dim_info with reorient. No problem since no EPI reorient.',
    '% 130715 Use 2 slices for xform. No slice flip needed except revNum mosaic.',
    '% 130716 Take care of lower/upper cases for output file names;',
    '%        Apply scl_slope and inter to img if range allows and no rounding;',
    '%        Save motion parameters, if any, into dcmHeader.mat.',
    '% 130722 Ugly fix for isMos, so it works for \'2004A 4VA25A\' phase data;',
    '%        Store dTE instead of TE if two TE are used, such as fieldmap.',
    '% 130724 Add two more ways for dwell time, useful for \'2004A 4VA25A\' dicom.',
    '% 130801 Can\'t use DERIVED since MoCoSeries may be labeled as DERIVED.',
    '% 130807 Check PixelSpacing consistency for a series;',
    '%        Prepare to publish to Matlab Central.',
    '% 130809 Add 5th input for subjName, so one can choose a subject.',
    '% 130813 Store ImageComments, if exists and is meaningful, into aux_file.',
    '% 130818 Expand source to dicom file(s) and wildcards like run1*.dcm.',
    '%        Update fields in dcmHeader.mat, rather than overwriting the file.',
    '%        Include save_nii etc in the code for easy distribution.',
    '% 130821 Bug fix for cellstr input as dicom source.',
    '%        Change file name from dcm2nii.m to reduce confusion from MRICron.',
    '%        GUI implemented into the single file.',
    '% 130823 Remove dependency on Image Processing Toolbox.',
    '% 130826 Bug fix for \'*\' src input. Minor improvement for dicm_hdr.',
    '% 130827 Try and suggest to use pigz for compression (thanks Chris R.).',
    '% 130905 Avoid the missing-field error for DTI data with 2 excitations.',
    '%        Protect GUI from command line plotting.',
    '% 130912 Use lDelayInTR for slice_dur, possibly useful for old data.',
    '% 130916 Store B_matrix for DTI image, if exists.',
    '% 130919 Make the code work for GE and Philips dicom at Chris R website.',
    '% 130922 Remove dependence on normc from nnet toolbox (thank Zhiwei);',
    '%        Prove no slice order info in Philips, at least for Intera 10.4.1.',
    '% 130923 Make the code work for Philips PAR/REC pair files.',
    '% 130926 Take care of non-mosaic DTI for Siemens (img/bval/bvec);',
    '% 130930 Use verify_slice_dir subfun to get slice_dir even for a single file.',
    '% 131001 dicm_hdr can deal with VR of SQ. This slows down it a little.',
    '% 131002 Avoid fullfile for cellstr input (not supported in old ver matlab).',
    '% 131006 Tweak dicm_hdr for multiframe dicom (some bug fixes);',
    '%        First working version for multiframe (tested with Philips dicom).',
    '% 131009 Put dicm_hdr, dicm_img, dicm_dict outside this file;',
    '%        dicm_hdr can read implicit VR, and is faster with single fread;',
    '%        Fix problem in gzipOS when folder name contains space.',
    '% 131020 Make TR & ProtocolName non-mandatory; Set cal_min & cal_max.',
    '% 131021 Check SamplesPerPixel, skip run if it is 1+.',
    '% 131021 Implement conversion for AFNI HEAD/BRIK.',
    '% 131024 Bug fix for dealing with current folder as src folder.',
    '% 131029 Bug fix: Siemens, 2D, non-mosaic, rev-num slices were flipped.',
    '% 131105 DTI parameters: field names more consistent; read DTI flds in',
    '%        save_dti_para for GE/Philips (make others faster); convert Philips',
    '%        bvec from deg into vector (need to be verified).',
    '% 131114 Treak for multiframe dicm_hdr: MUCH faster by using only 1,2,n frames;',
    '%        Bug fix for Philips multiframe DTI parameters;',
    '%        Split multiframe Philips B0 map into mag and phase nii.',
    '% 131117 Make the order of phase/mag image in Philips B0 map irrelevant.',
    '% 131219 Write warning message to a file in data folder (Gui\'s suggestion).',
    '% 140120 Bug fix in save_dti_para due to missing Manufacturer (Thank Paul).',
    '% 140121 Allow missing instance at beginning of a series.',
    '% 140123 save_nii: bug fix for gzip.m detection, take care of ~ as home dir.',
    '% 140206 bug fix: MoCo detetion bug introduced by removing empty cell earlier.',
    '% 140223 add missing-file check for Philips data by slice locations.',
    '% 140312 use slice timing to set slice_code for both GE and Siemens.',
    '%        Interleaved order was wrong for GE data with even number of slices. ',
    '% 140317 Use MosaicRefAcqTimes from last vol for multiband (thank Chris).',
    '%        Don\'t re-orient fieldmap, so make FSL happy in case of non_axial. ',
    '%        Ugly fix for wrong dicom item VR \'OB\': Avoid using main header ',
    '%        in csa_header(), convert DTI parameters to correct type. There may',
    '%        be other wrong parameters we don\'t realize. ',
    '% 140319 Store SliceTiming field in dcmHeaders.mat for FSL custom slice timing.',
    '%        Re-orient even if flipping slices for 2D MRAcquisitionType.',
    '% 140324 Not set cal_min, cal_max anymore.',
    '% 140327 Return unconverted subject names in 2nd output.',
    '% 140401 Always flip image so phase dir is correct.',
    '% 140409 Store nii extension (not enabled due to nifti ext issue).',
    '% 140501 Fix for GE: use LocationsInAcquisition to replace ImagesInAcquisition;',
    '%            isDTI=DiffusionDirection>0; Gradient already in image reference.',
    '% 140505 Always re-orient DTI. bvec fix for GE DTI (thx Chris).',
    '% 140506 Remove last DTI vol if it is computed ADC (as dcm2niix);',
    '%        Use SeriesDescription to replace ProtocolName for file name;',
    '%        Improved dim_info and phase direction.',
    '% 140512 Decode GE ProtocolDataBlock for phase direction;',
    '%        strtrim SeriesDescription for nii file name.',
    '% 140513 change stored phase direction to image space for FSL unwarp;',
    '%        Simplify code for dim_info.',
    '% 140516 Switch back to ProtocolName for SIEMENS to take care of MOCO series;',
    '%        Detect Philips Dim3IsVolume (for multi files) during dicom check; ',
    '%        Work for GE interleaved slices even if InstanceNumber is in time order;',
    '%        Do ImagePositionPatient check for all vendors;',
    '%        Simplify code for save_dti_para.',
    '% 140517 Store img with first dim flipped, to take care of DTI bvec problems. ',
    '% 140522 Use SliceNormalVector for mosaic slice_dir, so no worry for revNumb;',
    '%        Bug fix for interleaved descending slice_code.',
    '% 140525 xform sliceCenter to SliceLocation in verify_slice_dir. ',
    '% 140526 Take care of non-unique ixyz. ',
    '% 140608 Bug fix for GE interleaved slices;',
    '%        Take care all ixyz, put verify_slice_dir into xform_mat.',
    '% 140610 Compute readout time for DTI, rather than dwell time.',
    '% 140621 Support tgz file as data source.',
    '% 140716 Bug fix due to empty src for GUI subject option.',
    '% 140808 Simplify mosaic detection, and remove isMosaic.',
    '% 140816 Simplify DTI detection.',
    '% 140911 Minor fix for Siemens ProtocolName for error message.',
    '% 141016 Remember GUI settings from last conversion;',
    '%        Make multi-subject error message friendly.',
    '% 141021 Show percent progress for validating dicom files.',
    '% 141023 Get LocationsInAcquisition for GE multiframe dicom.',
    '% 141024 Use unique ImagePositionPatient to determine LocationsInAcquisition.',
    '% 141028 Use matlabpool if available and worthy.',
    '% 141125 Store NumberOfTemporalPositions in dicom header.',
    '% 141128 Minor tweaks for Octave 3.8.1 command line (GUI not working).',
    '% 141216 Use ImagePositionPatient to derive SliceThickness if possible.',
    '% 141217 Override LocationsInAcquisition with computed nSL (thx Luigi);',
    '%        Check RescaleIntercept and RescaleSlope consistency.',
    '% 141218 Allow 1e-4 diff for ImagePositionPatient of same slice location.',
    '% 141223 multiFrameFields: return earlier if only single frame (thx Sander);',
    '%        No re-orient for single slice (otherwise problem for mricron to read).',
    '% 141224 mos2vol: use nSL loop (faster unless many slices).',
    '% 141229 Save nii ext (ecode=40) if FSL is detected & it is not 5.0.5/5.0.6.',
    '% 141230 nojvm: no matlabpool; no dicm_hdr progress due to \'\\b\' issue for WIN.',
    '% 150109 dicm_img(s, 0) to follow the update for dicm_img.',
    '% 150112 Use nii_tool.m, remove make_nii, save_nii etc from this file.',
    '% 150115 Allow SamplesPerPixel>1, but likely not very useful.',
    '% 150117 Store seq name in intent_name.',
    '% 150119 Add phase img detection for Philips (still need it for GE).',
    '% 150120 No file skip by EchoTime: keep all data by using EchoNumber.',
    '% 150209 Add more output format for SPM style: 3D output;',
    '%        GUI includes SPM 3D, separates GZ option. ',
    '% 150211 No missing file check for all vendors, relying on ImagePosition check;',
    '%        csa_header() relies on dicm_hdr decoding (avoid error on old data);',
    '%        Deal with dim3-RGB and dim4-frames due to dicm_img.m update.',
    '% 150222 Remove useless, mis-used TriggerTime for partial hdr; also B_matrix.',
    '% 150302 No hardcoded sign change for DTI bvec, except for GE;',
    '%        set_nii_header: do flip only once after permute;',
    '% 150303 Bug fix for phPos: result was right by lucky mistake;',
    '%        Progress shows nii dim, more informative than number of files.',
    '% 150305 Replace null with cross: null gives inconsistent signs;',
    '%        Use SPM method for xform: account for shear; no qform setting if shear.',
    '% 150306 GE: fully sort slices by loc to ease bvec sign (test data needed);',
    '%        bvec sign simplified by above sort & corrected R for Philips/Siemens.',
    '% 150309 GUI: added the little popup for \'about/license\'.  ',
    '% 150323 Siemens non-mosaic: RefAcqTimes from ucMode, AcquisitionTime(disabled).   ',
    '% 150324 mandatory flds reduced to 5; get info by asc_header if possible;',
    '% 150325 Use SeriesInstanceUID to take care of multiple Study and PatientName; ',
    '%        Remove 5th input (subj); GUI updated; subjName in file name if needed;',
    '%        Deal with MoCo series by output file names;',
    '%        Convert GLM and DTI junk too; no Manufacturer check in advance.',
    '% 150405 Implement BrainVoyager dmr/fmr/vmr conversion; GUI updated accordingly. ',
    '% 150413 InstanceNumber is not mandatory (now total 4);',
    '%        Check missing files for non-DTI mosaic by InstanceNumber.',
    '% 150418 phaseDirection: bug fix for Philips, simplify for others.',
    '% 150420 store raw timing in RefAcqTimes, avoid confusion with SliceTiming.',
    '% 150423 fix matlabpool for later matlab versions; no auto-close anymore;',
    '%        GUI figure handle can\'t be uint32 for matlab 2015;',
    '%        Turn off saveExt40: FSL 5.0.8 may read vox_offset as 352.',
    '% 150430 xform_mat: GE, no LastScanLoc needed since sorted by ImagePosition. ',
    '% 150508 csa2pos: bug fix for revNum, iSL==1; treat dInPlaneRot specially.',
    '% 150514 set_nii_ext: start to store txt edata (ecode=6).',
    '%        Avoid dict change in dicm_hdr due to vendor change (GE/Philips faster);',
    '% 150517 Octave compatibility fix in multiple files.',
    '% 150526 multiFrameFields: LocationsInAcquisition by ImagePosition if needed.',
    '% 150531 Check slice loc for all volumes to catch missing files (thx CarloR).',
    '% 150604 phaseDirection: typo fix for Philips \'RLAPFH\'; Show converter version.',
    '% 150606 csa_header read both CSA image/series header.',
    '% 150609 No t_unit and SliceTiming for DTI.',
    '% 150613 mb_slicetiming: try to fix SOME broken multiband slice timing.',
    '% 150620 use \'bval\' for nii.ext and dcmHeaders.mat, so keep original B_value.',
    '% End of history. Don\'t edit this line!',
    '',
    'if nargout, varargout{1} = \'\'; end',
    'if nargin==3 && ischar(varargin{1}) % mis-use 3rd input for GUI and func handle',
    '    if strcmp(varargin{1}, \'gui_callback\')',
    '        dicm2nii_gui(dataFolder);',
    '        return;',
    '    elseif strcmp(varargin{1}, \'func_handle\')',
    '        if strcmp(dataFolder, \'all\') % for command line test',
    '            fcns = localfunctions; % only for Matlab since 2013b',
    '            for i = 1:length(fcns)',
    '                nam = func2str(fcns{i});',
    '                assignin(\'base\', nam, eval([\'@\' nam]));',
    '            end',
    '        else',
    '            varargout{1} = eval([\'@\' dataFolder]);',
    '        end',
    '        return;',
    '    end',
    'end',
    '',
    '%% Deal with output format first, and error out if invalid',
    'if nargin<3 || isempty(varargin{1}), fmt = 1; % default .nii.gz',
    'else fmt = varargin{1};',
    'end',
    '',
    'if (isnumeric(fmt) && any(fmt==[0 1 4 5])) || ...',
    '      (ischar(fmt) && ~isempty(regexpi(fmt, \'nii\')))',
    '    ext = \'.nii\';',
    'elseif (isnumeric(fmt) && any(fmt==[2 3 6 7])) || (ischar(fmt) && ...',
    '        (~isempty(regexpi(fmt, \'hdr\')) || ~isempty(regexpi(fmt, \'img\'))))',
    '    ext = \'.img\';',
    'else',
    '    error(\' Invalid output file format (the 3rd input).\');',
    'end',
    '',
    'if (isnumeric(fmt) && mod(fmt,2)) || (ischar(fmt) && ~isempty(regexpi(fmt, \'.gz\')))',
    '    ext = [ext \'.gz\']; % gzip file',
    'end',
    '',
    'rst3D = (isnumeric(fmt) && fmt>3) || (ischar(fmt) && ~isempty(regexpi(fmt, \'3D\')));',
    '',
    '%% Deal with MoCo option',
    'if nargin<4 || isempty(varargin{2})',
    '    MoCo = 1; % by default, use original series if both present ',
    'else',
    '    MoCo = varargin{2};',
    '    if ~any(MoCo==0:2)',
    '        error(\' Invalid MoCoOption. The 4th input must be 0, 1 or 2.\');',
    '    end',
    'end',
    '',
    '%% Deal with data source',
    'if nargin<1 || isempty(src) || (nargin<2 || isempty(dataFolder))',
    '    create_gui; % show GUI if input is not enough',
    '    return;',
    'end',
    '',
    'tic;',
    'unzip_cmd = \'\';',
    'if isnumeric(src)',
    '    error(\'Invalid dicom source.\');    ',
    'elseif iscellstr(src) % multiple files',
    '    dcmFolder = folderFromFile(src{1});',
    '    n = length(src);',
    '    fnames = src;',
    '    for i = 1:n',
    '        foo = dir(src{i});',
    '        if isempty(foo), error(\'%s does not exist.\', src{i}); end',
    '        fnames{i} = fullfile(dcmFolder, foo.name); ',
    '    end',
    'elseif ~exist(src, \'file\') % like input: run1*.dcm',
    '    fnames = dir(src);',
    '    if isempty(fnames), error(\'%s does not exist.\', src); end',
    '    fnames([fnames.isdir]) = [];',
    '    dcmFolder = folderFromFile(src);',
    '    fnames = strcat(dcmFolder, filesep, {fnames.name});    ',
    'elseif isdir(src) % folder',
    '    dcmFolder = src;',
    'elseif ischar(src) % 1 dicom or zip/tgz file',
    '    dcmFolder = folderFromFile(src);',
    '    unzip_cmd = compress_func(src);',
    '    if isempty(unzip_cmd)',
    '        fnames = dir(src);',
    '        fnames = strcat(dcmFolder, filesep, {fnames.name});',
    '    end',
    'else ',
    '    error(\'Unknown dicom source.\');',
    'end',
    'dcmFolder = fullfile(getfield(what(dcmFolder), \'path\'));',
    '',
    '%% Deal with dataFolder',
    'if ~isdir(dataFolder), mkdir(dataFolder); end',
    'dataFolder = fullfile([getfield(what(dataFolder), \'path\') filesep]);',
    'converter = [\'dicm2nii.m 20\' reviseDate];',
    'if errorLog(\'\', dataFolder) % let it remember dataFolder for later call',
    '    more off;',
    '    disp([\'Xiangrui Li\'\'s \' converter \' (feedback to xiangrui.li@gmail.com)\']);',
    'end',
    '',
    '%% Unzip if compressed file is the source',
    'if ~isempty(unzip_cmd)',
    '    [~, fname, ext1] = fileparts(src);',
    '    dcmFolder = sprintf(\'%stmpDcm%s/\', dataFolder, fname);',
    '    if ~isdir(dcmFolder), mkdir(dcmFolder); end',
    '    disp([\'Extracting files from \' fname ext1 \' ...\']);',
    '',
    '    if strcmp(unzip_cmd, \'unzip\')',
    '        cmd = sprintf(\'unzip -qq -o %s -d %s\', src, dcmFolder);',
    '        err = system(cmd); % first try system unzip',
    '        if err, unzip(src, dcmFolder); end % Matlab\'s unzip is too slow',
    '    elseif strcmp(unzip_cmd, \'untar\')',
    '        if isempty(which(\'untar\')), error(\'No untar found in matlab path.\'); end',
    '        untar(src, dcmFolder);',
    '    end',
    '    drawnow;',
    'end ',
    '',
    '%% Get all file names including those in subfolders, if not specified',
    'if ~exist(\'fnames\', \'var\')',
    '    dirs = genpath(dcmFolder);',
    '    dirs = textscan(dirs, \'%s\', \'Delimiter\', pathsep);',
    '    dirs = dirs{1}; % cell str',
    '    fnames = {};',
    '    for i = 1:length(dirs)',
    '        curFolder = [dirs{i} filesep];',
    '        foo = dir(curFolder); % all files and folders',
    '        foo([foo.isdir]) = []; % remove folders',
    '        foo = strcat(curFolder, {foo.name});',
    '        fnames = [fnames foo]; %#ok<*AGROW>',
    '    end',
    'end',
    'nFile = length(fnames);',
    'if nFile<1, error(\' No files found in the data source.\'); end',
    '',
    '%% Check each file, store partial header in cell array hh',
    '% first 4 fields are must to be valid dicom',
    'flds = {\'SeriesInstanceUID\' \'Columns\' \'Rows\' \'BitsAllocated\' \'InstanceNumber\' ...',
    '    \'ImageOrientationPatient\' \'ImagePositionPatient\' \'PixelSpacing\' ...',
    '    \'PixelRepresentation\' \'BitsStored\' \'HighBit\' \'SamplesPerPixel\' ...',
    '    \'PlanarConfiguration\' \'EchoNumber\' \'RescaleIntercept\' \'RescaleSlope\' ...',
    '    \'NumberOfFrames\' \'B_value\' \'DiffusionGradientDirection\' ...',
    '    \'RTIA_timer\' \'RBMoCoTrans\' \'RBMoCoRot\' ...',
    '    \'SliceThickness\' \'SpacingBetweenSlices\'};',
    'dict = dicm_dict(\'SIEMENS\', flds); % dicm_hdr will update vendor if needed',
    '',
    '% read header for all files, use parpool if available and worthy',
    'fprintf(\'Validating %g files ...\\n\', nFile);',
    'hh = cell(1, nFile); errStr = cell(1, nFile);',
    'doPar = useParTool(nFile>1000); % use it if already open or nFile>1000',
    'for k = 1:nFile',
    '    [hh{k}, errStr{k}, dict] = dicm_hdr(fnames{k}, dict);',
    '    if doPar && ~isempty(hh{k}) % parfor wont allow updating dict',
    '        parfor i = k+1:nFile',
    '            [hh{i}, errStr{i}] = dicm_hdr(fnames{i}, dict); ',
    '        end',
    '        break; ',
    '    end',
    'end',
    '',
    '%% sort headers into cell h by SeriesInstanceUID, EchoNumber and InstanceNumber',
    'h = {}; % in case of no dicom files at all',
    'errInfo = \'\';',
    'seriesUIDs = {};',
    'for k = 1:nFile',
    '    s = hh{k};',
    '    if isempty(s) || any(~isfield(s, flds(1:4))) % || isType(s, junk)',
    '        if ~isempty(errStr{k}) % && isempty(strfind(errInfo, errStr{k}))',
    '            errInfo = sprintf(\'%s\\n%s\\n\', errInfo, errStr{k});',
    '        end',
    '        continue; % skip the file',
    '    end',
    '',
    '    m = find(strcmp(s.SeriesInstanceUID, seriesUIDs));',
    '    if isempty(m)',
    '        m = length(seriesUIDs)+1;',
    '        seriesUIDs{m} = s.SeriesInstanceUID;',
    '    end',
    '    ',
    '    % EchoNumber is needed for Siemens fieldmap mag series',
    '    i = tryGetField(s, \'EchoNumber\', 1); if i<1, i = 1; end',
    '    j = tryGetField(s, \'InstanceNumber\');',
    '    if isempty(j) || j<1',
    '        try j = length(h{m}{i}) + 1;',
    '        catch, j = 1; ',
    '        end',
    '    end',
    '    h{m}{i}{j} = s; % store partial header',
    'end',
    'clear hh errStr;',
    '',
    '%% Check headers: remove file-missing and dim-inconsistent series',
    'nRun = length(h);',
    'if nRun<1',
    '    errorLog(sprintf(\'No valid files found:\\n%s.\', errInfo)); ',
    '    return;',
    'end',
    'keep = true(1, nRun); % true for useful runs',
    'subjs = cell(1, nRun); vendor = cell(1, nRun);',
    'sNs = ones(1, nRun); studyIDs = cell(1, nRun);',
    'fldsCk = {\'ImageOrientationPatient\' \'NumberOfFrames\' \'Columns\' \'Rows\' ...',
    '          \'PixelSpacing\' \'RescaleIntercept\' \'RescaleSlope\' \'SamplesPerPixel\' ...',
    '          \'SpacingBetweenSlices\' \'SliceThickness\'}; % last for thickness',
    'for i = 1:nRun',
    '    h{i} = [h{i}{:}]; % concatenate different EchoNumber',
    '    ind = cellfun(@isempty, h{i});',
    '    h{i}(ind) = []; % remove all empty cell for all vendors',
    '    ',
    '    s = h{i}{1};',
    '    if ~isfield(s, \'LastFile\') % avoid re-read for PAR/HEAD/BV file',
    '        s = dicm_hdr(s.Filename); % full header for 1st file',
    '    end',
    '    if ~isfield(s, \'Manufacturer\'), s.Manufacturer = \'Unknown\'; end',
    '    subjs{i} = PatientName(s);',
    '    vendor{i} = s.Manufacturer;',
    '    sNs(i) = tryGetField(s, \'SeriesNumber\', 1);',
    '    studyIDs{i} = tryGetField(s, \'StudyID\', \'1\');',
    '    series = sprintf(\'Subject %s, %s (Series %g)\', subjs{i}, ProtocolName(s), sNs(i));',
    '    s = multiFrameFields(s); % no-op if non multi-frame',
    '    if isempty(s), keep(i) = 0; continue; end % invalid multiframe series',
    '    s.isDTI = isDTI(s);',
    '    h{i}{1} = s; % update record in case of full hdr or multiframe',
    '    ',
    '    % check consistency in \'fldsCk\'',
    '    nFile = length(h{i});',
    '    if nFile<2, continue; end',
    '    nFlds = length(fldsCk);',
    '    if isfield(s, \'SpacingBetweenSlices\'), nFlds = nFlds - 1; end % check 1 of 2',
    '    for k = 1:nFlds',
    '        val1  = tryGetField(s, fldsCk{k});',
    '        if isempty(val1), continue; end',
    '        for j = 2:nFile',
    '            % At least some GE ImageOrientationPatient can have diff of 1e-6',
    '            val2 = tryGetField(h{i}{j}, fldsCk{k});',
    '            if isempty(val2) || any(abs(val1 - val2) > 1e-4)',
    '                errorLog([\'Inconsistent \'\'\' fldsCk{k} \'\'\' for \' series \'. Series skipped.\']);',
    '                keep(i) = 0;',
    '                break;',
    '            end',
    '        end',
    '        if ~keep(i), break; end % skip',
    '    end',
    '    ',
    '    if ~isempty(csa_header(s, \'NumberOfImagesInMosaic\'))',
    '        if s.isDTI, continue; end % allow missing directions for DTI',
    '        a = zeros(1, nFile);',
    '        for j = 1:nFile, a(j) = tryGetField(h{i}{j}, \'InstanceNumber\', 1); end',
    '        if any(diff(a) ~= 1)',
    '            errorLog([\'Missing file(s) detected for \' series \'. Series skipped.\']);',
    '            keep(i) = 0;',
    '        end',
    '        continue; % no other check for mosaic',
    '    end',
    '        ',
    '    if ~keep(i) || any(~isfield(s, {\'ImagePositionPatient\' \'ImageOrientationPatient\'}))',
    '        continue;',
    '    end',
    '    ',
    '    iSL = xform_mat(s); iSL = iSL(3);',
    '    a = zeros(1, nFile);',
    '    for j = 1:nFile, a(j) = h{i}{j}.ImagePositionPatient(iSL); end',
    '    nSL = sum(diff(sort(a)) > 1e-4) + 1; % allow minor diff',
    '    nVol = nFile / nSL;',
    '    if mod(nVol, 1) > 0',
    '        errorLog([\'Missing file(s) detected for \' series \'. Series skipped.\']);',
    '        keep(i) = 0; continue; % skip',
    '    end',
    '    ',
    '    fld = \'LocationsInAcquisition\';',
    '    if isfield(s, fld) && s.(fld)~=nSL % warning but override it',
    '        errorLog(sprintf([\'%s: the number of slices (%g) in dicom header \' ...',
    '            \'seems wrong. nSL = %g is used. Please check the result.\'], ...',
    '            series, s.(fld), nSL));',
    '    end',
    '    h{i}{1}.(fld) = uint16(nSL); % best way for nSL?',
    '',
    '    % re-order as Slice then Volume if Dim3IsVolume (likely Philips)',
    '    if abs(a(1)-a(2)) < 1e-4 % the same slice location',
    '        ind = reshape(1:nFile, [nVol nSL])\';',
    '        h{i} = h{i}(ind(:)); a = a(ind(:));',
    '        h{i}{1}.Dim3IsVolume = true; % not needed, info only',
    '    end',
    '        ',
    '    % re-order slices within volume by slice locations',
    '    if strncmpi(s.Manufacturer, \'GE\', 2)',
    '        [~, ind] = sort(a(1:nSL)); % slice locations for first volume',
    '        % if iSL==1, ind = ind(nSL:-1:1); end % need to confirm for SAG slice',
    '        if ~isequal(ind, 1:nSL)',
    '            inc = repmat((0:nVol-1)*nSL, nSL, 1);',
    '            ind = repmat(ind, 1, nVol) + inc(:)\';',
    '            h{i} = h{i}(ind); % sorted by slice locations',
    '            if ind(1)>1 % first file changed: update info for h{i}{1}',
    '                h{i}{1} = dicm_hdr(h{i}{1}.Filename); % read full hdr',
    '                s = h{i}{ind==1}; % original first file',
    '                h{i}{1}.isDTI = s.isDTI;',
    '                h{i}{1}.LocationsInAcquisition = s.LocationsInAcquisition;',
    '                h{i}{1}.AcquisitionDateTime = [ ... % useless based on GE data',
    '                    tryGetField(s, \'AcquisitionDate\', \'\') ...',
    '                    tryGetField(s, \'AcquisitionTime\', \'\')];',
    '            end',
    '        end',
    '    end',
    '    ',
    '    [~, ind] = sort(a(1:nSL));',
    '    if ~isequal(ind, 1:nSL) && ~isequal(ind, nSL:-1:1)',
    '        errorLog([\'Missing file(s) detected for \' series \'. Series skipped.\']);',
    '        keep(i) = 0; continue; % skip',
    '    end',
    '    ',
    '    for j = 2:nVol',
    '        [~, ind1] = sort(a((1:nSL)+(j-1)*nSL));',
    '        if isequal(ind, ind1), continue; end',
    '        errorLog([\'Missing file(s) detected for \' series \'. Series skipped.\']);',
    '        keep(i) = 0; break; % skip',
    '    end',
    'end',
    'h = h(keep); sNs = sNs(keep); studyIDs = studyIDs(keep); ',
    'subjs = subjs(keep); vendor = vendor(keep);',
    '',
    '%% sort h by PatientName, then StudyID, then SeriesNumber',
    '% Also get correct order for subjs/studyIDs/nStudy/sNs for nii file names',
    '[subjs, ind] = sort(subjs);',
    'subj = unique(subjs); ',
    'h = h(ind); sNs = sNs(ind); studyIDs = studyIDs(ind); % by subjs now',
    'nStudy = ones(1, nRun); % one for each series',
    'for i = 1:length(subj)',
    '    iSub = find(strcmp(subj{i}, subjs));',
    '    study = studyIDs(iSub);',
    '    [study, iStudy] = sort(study); % by study for each subject',
    '    a = h(iSub);   h(iSub)   = a(iStudy);',
    '    a = sNs(iSub); sNs(iSub) = a(iStudy);',
    '    studyIDs(iSub) = study; % done for h/sNs/studyIDs by studyIDs for a subj',
    '    uID = unique(study);',
    '    nStudy(iSub) = length(uID);',
    '    for k = 1:length(uID) % now sort h/sNs by sNs for each studyID',
    '        iStudy = strcmp(uID{k}, study);',
    '        ind = iSub(iStudy); ',
    '        [sNs(ind), iSN] = sort(sNs(ind));',
    '        a = h(ind); h(ind) = a(iSN);',
    '    end',
    'end',
    '',
    '%% Generate unique result file names',
    '% Unique names are in format of SeriesDescription_s007. Special cases are: ',
    '%  for phase image, such as field_map phase, append \'_phase\' to the name;',
    '%  for MoCo series, append \'_MoCo\' to the name if both series are created.',
    '%  for multiple subjs, it is SeriesDescription_subj_s007',
    '%  for multiple Study, it is SeriesDescription_subj_Study1_s007',
    'nRun = length(h); % update it, since we have removed some',
    'if nRun<1',
    '    errorLog(\'No valid series found\');',
    '    return;',
    'end',
    'rNames = cell(1, nRun);',
    'isMoCo = false(1, nRun);',
    'multiSubj = length(subj)>1; ',
    'for i = 1:nRun',
    '    s = h{i}{1};',
    '    a = strtrim(ProtocolName(s));',
    '    if isType(s, \'\\P\\\') || strcmpi(tryGetField(s, \'ComplexImageComponent\', \'\'), \'PHASE\')',
    '        a = [a \'_phase\']; % phase image',
    '    end',
    '    isMoCo(i) = isType(s, \'\\MOCO\\\');',
    '    if MoCo==0 && isMoCo(i), a = [a \'_MoCo\']; end',
    '    if multiSubj, a = [a \'_\' subjs{i}]; end',
    '    if nStudy(i)>1, a = [a \'_Study\' studyIDs{i}]; end',
    '    a(~isstrprop(a, \'alphanum\')) = \'_\'; % make str valid for field name',
    '    while true % remove repeated underscore',
    '        ind = strfind(a, \'__\');',
    '        if isempty(ind), break; end',
    '        a(ind) = \'\';',
    '    end',
    '    sN = sNs(i);',
    '    if sN>100 && strncmp(s.Manufacturer, \'Philips\', 7)',
    '        sN = tryGetField(s, \'AcquisitionNumber\', floor(sN/100));',
    '    end',
    '    rNames{i} = sprintf(\'%s_s%03.0f\', a, sN);',
    'end',
    'rNames = genvarname(rNames); % add \'x\' if started with a digit, and more',
    '',
    '% deal with MoCo series',
    'if MoCo>0 && any(isMoCo)',
    '    keep = true(1, nRun);',
    '    for i = 2:nRun',
    '        if isMoCo(i) && sNs(i)==sNs(i-1)+1 && ...',
    '                strcmp(rNames{i}(1:end-5), rNames{i-1}(1:end-5))',
    '            if MoCo==1',
    '                keep(i) = 0; % skip MOCO',
    '            elseif MoCo==2',
    '                keep(i-1) = 0; % skip original',
    '            end',
    '        end',
    '    end',
    '    h = h(keep); rNames = rNames(keep);',
    '    vendor = vendor(keep); subj = unique(subjs(keep));',
    '    nRun = length(h);',
    'end',
    '',
    'vendor = strtok(unique(vendor));',
    'if nargout>0, varargout{1} = subj; end % return converted subject IDs',
    'if nargout>1, varargout{2} = {}; end % will remove in the future',
    '',
    '% After following sort, we need to compare only neighboring names. Remove',
    '% _s007 if there is no conflict. Have to ignore letter case for Windows & MAC',
    'fnames = rNames; % copy it, keep letter cases',
    '[rNames, iRuns] = sort(lower(fnames));',
    'for i = 1:nRun',
    '    a = rNames{i}(1:end-5); % remove _s003',
    '    % no conflict with both previous and next name',
    '    if nRun==1 || ... % only one run',
    '         (i==1    && ~strcmpi(a, rNames{2}(1:end-5))) || ... % first',
    '         (i==nRun && ~strcmpi(a, rNames{i-1}(1:end-5))) || ... % last',
    '         (i>1 && i<nRun && ~strcmpi(a, rNames{i-1}(1:end-5)) ...',
    '                        && ~strcmpi(a, rNames{i+1}(1:end-5))); % middle ones',
    '        fnames{iRuns(i)}(end+(-4:0)) = [];',
    '    end',
    'end',
    'fmtStr = sprintf(\' %%-%gs %%gx%%gx%%gx%%g\\n\', max(cellfun(@length, fnames))+6);',
    '',
    '%% Now ready to convert nii series by series',
    'subjStr = sprintf(\'\'\'%s\'\', \', subj{:}); subjStr(end+(-1:0)) = [];',
    'vendor = sprintf(\'%s, \', vendor{:}); vendor(end+(-1:0)) = [];',
    'fprintf(\'Converting %g series (%s) into %g-D %s: subject %s\\n\', ...',
    '            nRun, vendor, 4-rst3D, ext, subjStr);',
    'for i = 1:nRun',
    '    nFile = length(h{i});',
    '    s = h{i}{1};',
    '    img = dicm_img(s, 0); % initialize with proper data type and img size',
    '',
    '    if nFile > 1',
    '        if ~isfield(s, \'LastFile\')',
    '            h{i}{1}.LastFile = h{i}{nFile}; % store partial last header into 1st',
    '        end',
    '        n = ndims(img);',
    '        if n == 2 % for most dicom files',
    '            img(:, :, 2:nFile) = 0; % pre-allocate',
    '            for j = 2:nFile, img(:,:,j) = dicm_img(h{i}{j}, 0); end',
    '        elseif n == 3 % SamplesPerPixel>1 is the only case I know for now',
    '            img(:, :, :, 2:nFile) = 0; % pre-allocate',
    '            for j = 2:nFile, img(:,:,:,j) = dicm_img(h{i}{j}, 0); end',
    '        else % err out, likely won\'t work for other series',
    '            error(\'dicm2nii can\'\'t deal with multiple %g-dim dicom image\', n);',
    '        end',
    '    elseif size(img,3) == 1 % single gray file (multi-frame dicm, par or brik)',
    '        img = permute(img, [1 2 4 3]); % put frames into dim3',
    '    end',
    '    ',
    '    nSL = csa_header(s, \'NumberOfImagesInMosaic\', 1);',
    '    if nSL>1 % SIEMENS mosaic',
    '        img = mos2vol(img, nSL); % mosaic to volume',
    '    elseif ndims(img)==4 && tryGetField(s, \'Dim3IsVolume\', false) % BV/BRIK',
    '        img = permute(img, [1 2 4 3]);',
    '    elseif ndims(img) == 3 % may need to reshape to 4D',
    '        nSL = double(tryGetField(s, \'LocationsInAcquisition\'));        ',
    '        if nSL>1',
    '            dim = size(img);',
    '            dim(3:4) = [nSL dim(3)/nSL]; % verified integer earlier',
    '            if nFile==1 && tryGetField(s, \'Dim3IsVolume\', false)',
    '                % for PAR and single multiframe dicom',
    '                img = reshape(img, dim([1 2 4 3]));',
    '                img = permute(img, [1 2 4 3]);',
    '            else',
    '                img = reshape(img, dim);',
    '            end',
    '        end',
    '    end',
    '    % This \'if\' block takes care of SamplesPerPixel>1',
    '    if tryGetField(s, \'SamplesPerPixel\', 1) > 1',
    '        img = permute(img, [1 2 4:8 3]); % put RGB into dim8 for nii_tool',
    '    end',
    '    dim = size(img);',
    '    if numel(dim)<3, dim(3) = 1; end',
    '    fld = \'NumberOfTemporalPositions\';',
    '    if ~isfield(s, fld) && numel(dim)>3 && dim(4)>1, h{i}{1}.(fld) = dim(4); end',
    '',
    '    if any(~isfield(s, {\'ImageOrientationPatient\' \'ImagePositionPatient\'}))',
    '        h{i}{1} = csa2pos(s, dim(3));',
    '    end',
    '    ',
    '    % Store GE slice timing. No slice order info for Philips at all!',
    '    if isfield(s, \'RTIA_timer\') && ~s.isDTI',
    '        t = zeros(dim(3), 1);',
    '        for j = 1:dim(3), t(j) = tryGetField(h{i}{j}, \'RTIA_timer\', nan); end',
    '        if ~all(diff(t)==0), h{i}{1}.RefAcqTimes = t/10; end % in ms',
    '        ',
    '%     % Get slice timing for non-mosaic Siemens file. Could remove Manufacturer',
    '%     % check, but GE/Philips AcquisitionTime seems useless',
    '%     elseif numel(dim)>3 && dim(4)>2 && ~isfield(s, \'MosaicRefAcqTimes\') ...',
    '%             && strncmpi(s.Manufacturer, \'SIEMENS\', 7) && ~s.isDTI',
    '%         dict = dicm_dict(\'\', {\'AcquisitionDate\' \'AcquisitionTime\'});',
    '%         t = zeros(dim(3), 1);',
    '%         for j = 1:dim(3)',
    '%             s1 = dicm_hdr(h{i}{j}.Filename, dict);',
    '%             str = [s1.AcquisitionDate s1.AcquisitionTime];',
    '%             t(j) = datenum(str, \'yyyymmddHHMMSS.fff\');',
    '%         end',
    '%         h{i}{1}.RefAcqTimes = (t - min(t)) * 24 * 3600 * 1000; % day to ms',
    '    end',
    '    ',
    '    % Store motion parameters for MoCo series',
    '    if all(isfield(s, {\'RBMoCoTrans\' \'RBMoCoRot\'})) && numel(dim)>3',
    '        inc = nFile / dim(4);',
    '        trans = zeros(dim(4), 3);',
    '        rotat = zeros(dim(4), 3);',
    '        for j = 1:inc:nFile',
    '            trans(j,:) = tryGetField(h{i}{j}, \'RBMoCoTrans\', [0 0 0]);',
    '            rotat(j,:) = tryGetField(h{i}{j}, \'RBMoCoRot\',   [0 0 0]);',
    '        end',
    '        h{i}{1}.RBMoCoTrans = trans;',
    '        h{i}{1}.RBMoCoRot = rotat;',
    '    end',
    '    ',
    '    if isa(img, \'uint16\') && max(img(:))<32768',
    '        img = int16(img); % use int16 if lossless. seems always true',
    '    end',
    '    ',
    '    nii = nii_tool(\'init\', img); % create nii struct based on img',
    '    fname = [dataFolder fnames{i}]; % name without ext',
    '',
    '    % Compute bval & bvec in dicom image reference for DTI series',
    '    if s.isDTI, [h{i}, nii] = get_dti_para(h{i}, nii); end',
    '    ',
    '    [nii, h{i}{1}] = set_nii_header(nii, h{i}{1}); % set most nii header',
    '    h{i}{1}.NiftiCreator = converter;',
    '    nii.ext = set_nii_ext(h{i}{1}); % NIfTI extension',
    '',
    '    % Save bval and bvec files after bvec perm/sign adjusted in set_nii_header',
    '    if s.isDTI, save_dti_para(h{i}{1}, fname); end',
    '',
    '    [nii, niiP] = split_philips_phase(nii, s); % split Philips mag&phase img',
    '    if ~isempty(niiP)',
    '        fprintf(fmtStr, [fnames{i} \'_phase\'], niiP.hdr.dim(2:5));',
    '        nii_tool(\'save\', niiP, [fname \'_phase\' ext], rst3D); % save phase nii',
    '    end',
    '    ',
    '    fprintf(fmtStr, fnames{i}, nii.hdr.dim(2:5)); % show info and progress',
    '    nii_tool(\'save\', nii, [fname ext], rst3D);',
    '    h{i} = h{i}{1}; % keep 1st dicm header only',
    '    if isnumeric(h{i}.PixelData), h{i} = rmfield(h{i}, \'PixelData\'); end % BV',
    'end',
    '',
    'h = cell2struct(h, fnames, 2); % convert into struct',
    'fname = [dataFolder \'dcmHeaders.mat\'];',
    'if exist(fname, \'file\') % if file exists, we update fields only',
    '    S = load(fname);',
    '    for i = 1:length(fnames), S.h.(fnames{i}) = h.(fnames{i}); end',
    '    h = S.h; %#ok',
    'end',
    'save(fname, \'h\', \'-v7\'); % -v7 better compatibility',
    'fprintf(\'Elapsed time by dicm2nii is %.1f seconds\\n\\n\', toc);',
    'if ~isempty(unzip_cmd), rmdir(dcmFolder, \'s\'); end % delete tmp dicom folder',
    'return;',
    '',
    '%% Subfunction: return folder name for a file name',
    'function folder = folderFromFile(fname)',
    'folder = fileparts(fname);',
    'if isempty(folder), folder = pwd; end',
    '',
    '%% Subfunction: return PatientName',
    'function subj = PatientName(s)',
    'subj = tryGetField(s, \'PatientName\');',
    'if isempty(subj), subj = tryGetField(s, \'PatientID\', \'Anonymous\'); end',
    '',
    '%% Subfunction: return SeriesDescription',
    'function name = ProtocolName(s)',
    'name = tryGetField(s, \'SeriesDescription\');',
    'if isempty(name) || (strncmp(s.Manufacturer, \'SIEMENS\', 7) && ...',
    '        numel(name)>9 && strcmp(name(end+(-9:0)), \'MoCoSeries\'))',
    '    name = tryGetField(s, \'ProtocolName\');',
    'end',
    'if isempty(name), [~, name] = fileparts(s.Filename); end',
    '',
    '%% Subfunction: return true if any of keywords is in s.ImageType',
    'function tf = isType(s, keywords)',
    'typ = tryGetField(s, \'ImageType\', \'\');',
    'if ischar(keywords) % single keyword',
    '    tf = ~isempty(strfind(typ, keywords));',
    '    return;',
    'end',
    'for i = 1:length(keywords)',
    '    tf = ~isempty(strfind(typ, keywords{i}));',
    '    if tf, return; end',
    'end',
    '',
    '%% Subfunction: return true if series is DTI',
    'function tf = isDTI(s)',
    'tf = isType(s, \'\\DIFFUSION\'); % Siemens, Philips',
    'if tf, return; end',
    'if strncmp(s.Manufacturer, \'GE\', 2) % not labeled as /DIFFISION',
    '    tf = tryGetField(s, \'DiffusionDirection\', 0)>0;',
    'elseif strncmpi(s.Manufacturer, \'Philips\', 7)',
    '    tf = strcmp(tryGetField(s, \'MRSeriesDiffusion\', \'N\'), \'Y\');',
    'else % Some Siemens DTI are not labeled as \\DIFFUSION',
    '    tf = ~isempty(csa_header(s, \'B_value\'));',
    'end',
    '        ',
    '%% Subfunction: get field if exist, return default value otherwise',
    'function val = tryGetField(s, field, dftVal)',
    'if isfield(s, field), val = s.(field); ',
    'elseif nargin>2, val = dftVal;',
    'else val = [];',
    'end',
    '',
    '%% Subfunction: Set most nii header and re-orient img',
    'function [nii, s] = set_nii_header(nii, s)',
    '% Transformation matrix: most important feature for nii',
    'dim = nii.hdr.dim(2:4); % space dim, set by nii_tool according to img',
    '[ixyz, R, pixdim, xyz_unit] = xform_mat(s, dim);',
    'R(1:2,:) = -R(1:2,:); % dicom LPS to nifti RAS, xform matrix before reorient',
    '',
    '% dim_info byte: freq_dim, phase_dim, slice_dim low to high, each 2 bits',
    '[phPos, iPhase] = phaseDirection(s); % phPos relative to image in FSL feat!',
    'if     iPhase == 2, fps_bits = [1 4 16];',
    'elseif iPhase == 1, fps_bits = [4 1 16]; ',
    'else                fps_bits = [0 0 16];',
    'end',
    '',
    '% set TR and slice timing related info before re-orient',
    '[s, nii.hdr] = sliceTiming(s, nii.hdr);',
    'nii.hdr.xyzt_units = xyz_unit + nii.hdr.xyzt_units; % normally: mm (2) + sec (8)',
    '',
    '% Reorient if MRAcquisitionType==3D || isDTI && nSL>1',
    '% If FSL etc can read dim_info for STC, we can always reorient.',
    '[~, perm] = sort(ixyz); % may permute 3 dimensions in this order',
    'if (strcmp(tryGetField(s, \'MRAcquisitionType\', \'\'), \'3D\') || s.isDTI) && ...',
    '        dim(3)>1 && (~isequal(perm, 1:3)) % skip if already standard view',
    '    R(:, 1:3) = R(:, perm); % xform matrix after perm',
    '    fps_bits = fps_bits(perm);',
    '    ixyz = ixyz(perm); % 1:3 after perm',
    '    dim = dim(perm);',
    '    pixdim = pixdim(perm);',
    '    nii.hdr.dim(2:4) = dim;',
    '    nii.img = permute(nii.img, [perm 4:8]);',
    '    if isfield(s, \'bvec\'), s.bvec = s.bvec(:,perm); end',
    'end',
    'iSL = find(fps_bits==16);',
    'iPhase = find(fps_bits==4); % axis index for phase_dim in re-oriented img',
    '',
    'nii.hdr.dim_info = (1:3) * fps_bits\'; % useful for EPI only',
    'nii.hdr.pixdim(2:4) = pixdim; % voxel zize',
    '',
    '% Flip image to make first axis negative and other two positive',
    'ind4 = ixyz + [0 4 8]; % index in 4xN matrix',
    'flp = R(ind4)<0; % flip an axis if true',
    'flp(1) = ~flp(1); % first axis negative: comment this to make all positive',
    'rotM = diag([1-flp*2 1]); % 1 or -1 on diagnal',
    'rotM(1:3, 4) = (dim-1) .* flp; % 0 or dim-1',
    'R = R / rotM; % xform matrix after flip',
    'for k = 1:3, if flp(k), nii.img = flipdim(nii.img, k); end; end',
    'if flp(iPhase), phPos = ~phPos; end',
    'if isfield(s, \'bvec\'), s.bvec(:, flp) = -s.bvec(:, flp); end',
    'if isfield(s, \'SliceTiming\') && flp(iSL) % slices flipped',
    '    s.SliceTiming = s.SliceTiming(end:-1:1);',
    '    sc = nii.hdr.slice_code;',
    '    if sc>0, nii.hdr.slice_code = sc+mod(sc,2)*2-1; end % 1<->2, 3<->4, 5<->6',
    'end',
    '',
    '% sform',
    'frmCode = all(isfield(s, {\'ImageOrientationPatient\' \'ImagePositionPatient\'}));',
    'frmCode = tryGetField(s, \'TemplateSpace\', frmCode); % 1: SCANNER_ANAT',
    'nii.hdr.sform_code = frmCode;',
    'nii.hdr.srow_x = R(1,:);',
    'nii.hdr.srow_y = R(2,:);',
    'nii.hdr.srow_z = R(3,:);',
    '',
    '% qform',
    'if abs(sum(R(:,iSL).^2) - pixdim(iSL)^2) < 0.01 % no shear at slice direction',
    '    nii.hdr.qform_code = frmCode;',
    '    nii.hdr.qoffset_x = R(1,4);',
    '    nii.hdr.qoffset_y = R(2,4);',
    '    nii.hdr.qoffset_z = R(3,4);',
    '',
    '    R = R(1:3, 1:3); % for quaternion',
    '    R = bsxfun(@rdivide, R, sqrt(sum(R.^2))); % normalize',
    '    [q, nii.hdr.pixdim(1)] = dcm2quat(R); % 3x3 dir cos matrix to quaternion',
    '    nii.hdr.quatern_b = q(2);',
    '    nii.hdr.quatern_c = q(3);',
    '    nii.hdr.quatern_d = q(4);',
    'end',
    '',
    '% store some possibly useful info in descrip and other text hdr',
    'str = tryGetField(s, \'ImageComments\');',
    'if isType(s, \'\\MOCO\\\'), str = \'\'; end % useless for MoCo',
    'foo = tryGetField(s, \'StudyComments\');',
    'if ~isempty(foo), str = [str \';\' foo]; end',
    'str = [str \';\' strtok(s.Manufacturer)];',
    'foo = tryGetField(s, \'ProtocolName\');',
    'if ~isempty(foo), str = [str \';\' foo]; end',
    'nii.hdr.aux_file = str; % char[24], info only',
    'seq = asc_header(s, \'tSequenceFileName\'); % like \'%SiemensSeq%\\ep2d_bold\'',
    'if isempty(seq), seq = tryGetField(s, \'ScanningSequence\'); ',
    'else [~, seq] = strtok(seq, \'\\\'); seq = strtok(seq, \'\\\'); % like \'ep2d_bold\'',
    'end',
    'nii.hdr.db_name = PatientName(s); % char[18], optional',
    'nii.hdr.intent_name = seq; % char[16], meaning of the data',
    '',
    'if ~isfield(s, \'AcquisitionDateTime\') && isfield(s, \'AcquisitionTime\')',
    '    s.AcquisitionDateTime = [tryGetField(s, \'AcquisitionDate\', \'\') ...',
    '                             tryGetField(s, \'AcquisitionTime\', \'\')];',
    'end',
    'foo = tryGetField(s, \'AcquisitionDateTime\');',
    'descrip = sprintf(\'time=%s;\', foo(1:min(18,end))); ',
    'TE0 = asc_header(s, \'alTE[0]\')/1000; % s.EchoTime stores only 1 TE',
    'dTE = abs(asc_header(s, \'alTE[1]\')/1000 - TE0); % TE difference',
    'if isempty(TE0), TE0 = tryGetField(s, \'EchoTime\'); end % GE, philips',
    'if isempty(dTE) && tryGetField(s, \'NumberOfEchoes\', 1)>1',
    '    dTE = tryGetField(s, \'SecondEchoTime\') - TE0; % need to update',
    'end',
    'if ~isempty(dTE)',
    '    descrip = sprintf(\'dTE=%.4g;%s\', dTE, descrip);',
    '    s.deltaTE = dTE;',
    'elseif ~isempty(TE0)',
    '    descrip = sprintf(\'TE=%.4g;%s\', TE0, descrip);',
    'end',
    '',
    '% Get dwell time',
    'if ~strcmp(tryGetField(s, \'MRAcquisitionType\'), \'3D\') && ~isempty(iPhase)',
    '    hz = csa_header(s, \'BandwidthPerPixelPhaseEncode\');',
    '    dwell = 1000 ./ hz / dim(iPhase); % in ms',
    '    if isempty(dwell) % true for syngo MR 2004A',
    '        % ppf = [1 2 4 8 16] represent [4 5 6 7 8] 8ths PartialFourier',
    '        % ppf = asc_header(s, \'sKSpace.ucPhasePartialFourier\');',
    '        lns = asc_header(s, \'sKSpace.lPhaseEncodingLines\');',
    '        dur = csa_header(s, \'SliceMeasurementDuration\');',
    '        dwell = dur ./ lns; % ./ (log2(ppf)+4) * 8;',
    '    end',
    '    if isempty(dwell) % next is not accurate, so as last resort',
    '        dur = csa_header(s, \'RealDwellTime\') * 1e-6; % ns to ms',
    '        dwell = dur * asc_header(s, \'sKSpace.lBaseResolution\');',
    '    end',
    '    if isempty(dwell)',
    '        dwell = double(tryGetField(s, \'EffectiveEchoSpacing\')) / 1000; % GE',
    '    end',
    '    % http://www.spinozacentre.nl/wiki/index.php/NeuroWiki:Current_developments',
    '    if isempty(dwell) % Philips',
    '        wfs = tryGetField(s, \'WaterFatShift\');',
    '        epiFactor = tryGetField(s, \'EPIFactor\');',
    '        dwell = wfs ./ (434.215 * (double(epiFactor)+1)) * 1000;',
    '    end',
    '    if ~isempty(dwell)',
    '        if s.isDTI',
    '            % ppf = asc_header(s, \'sKSpace.ucPhasePartialFourier\');',
    '            % lns = asc_header(s, \'sKSpace.lPhaseEncodingLines\');',
    '            % pat = asc_header(s, \'sPat.ucPATMode\');',
    '            % readout = dwell*pat * (lns * (log2(ppf)+4)/8 / pat - 1) / 1000;',
    '            readout = dwell * dim(iPhase) / 1000; % in sec',
    '            descrip = sprintf(\'readout=%.3g;%s\', readout, descrip);',
    '            s.ReadoutSeconds = readout;',
    '        else',
    '            descrip = sprintf(\'dwell=%.3g;%s\', dwell, descrip);',
    '            s.EffectiveEPIEchoSpacing = dwell;',
    '        end',
    '    end',
    'end',
    '',
    'if ~isempty(iPhase)',
    '    if isempty(phPos), pm = \'?\'; elseif phPos, pm = \'\'; else pm = \'-\'; end',
    '    axes = \'xyz\';',
    '    phDir = [pm axes(iPhase)];',
    '    s.UnwarpDirection = phDir;',
    '    descrip = sprintf(\'phase=%s;%s\', phDir, descrip);',
    'end',
    'nii.hdr.descrip = descrip; % char[80], drop from end if exceed',
    '',
    '% data slope and intercept: apply to img if no rounding error ',
    'nii.hdr.scl_slope = 1; % default scl_inter is 0',
    'if any(isfield(s, {\'RescaleSlope\' \'RescaleIntercept\'}))',
    '    slope = tryGetField(s, \'RescaleSlope\', 1); ',
    '    inter = tryGetField(s, \'RescaleIntercept\', 0); ',
    '    val = sort([max(nii.img(:)) min(nii.img(:))] * slope + inter);',
    '    dClass = class(nii.img);',
    '    if isa(nii.img, \'float\') || (mod(slope,1)==0 && mod(inter,1)==0 ... ',
    '            && val(1)>=intmin(dClass) && val(2)<=intmax(dClass))',
    '        nii.img = nii.img * slope + inter; % apply to img if no rounding',
    '    else',
    '        nii.hdr.scl_slope = slope;',
    '        nii.hdr.scl_inter = inter;',
    '    end',
    'end',
    '',
    '% Possible patient position: HFS/HFP/FFS/FFP / HFDR/HFDL/FFDR/FFDL',
    '% Seems dicom takes care of this, and maybe nothing needs to do here.',
    '% patientPos = tryGetField(s, \'PatientPosition\', \'\');',
    '',
    '%% Subfunction, reshape mosaic into volume, remove padded zeros',
    'function vol = mos2vol(mos, nSL)',
    'nMos = ceil(sqrt(nSL)); % always nMos x nMos tiles',
    '[nr, nc, nv] = size(mos); % number of row, col and vol in mosaic',
    '',
    'nr = nr / nMos; nc = nc / nMos; % number of row and col in slice',
    'vol = zeros([nr nc nSL nv], class(mos));',
    'for i = 1:nSL',
    '    r =    mod(i-1, nMos) * nr + (1:nr); % 2nd slice is tile(2,1)',
    '    c = floor((i-1)/nMos) * nc + (1:nc);',
    '    % r = floor((i-1)/nMos) * nr + (1:nr); % 2nd slice is tile(1,2)',
    '    % c =    mod(i-1, nMos) * nc + (1:nc);',
    '    vol(:, :, i, :) = mos(r, c, :);',
    'end',
    '',
    '%% subfunction: set slice timing related info',
    'function [s, hdr] = sliceTiming(s, hdr)',
    'TR = tryGetField(s, \'RepetitionTime\'); % in ms',
    'if isempty(TR), TR = tryGetField(s, \'TemporalResolution\', 0); end',
    'if TR == 0, return; end',
    'hdr.pixdim(5) = TR / 1000;',
    'if tryGetField(s, \'isDTI\', 0), return; end',
    'hdr.xyzt_units = 8; % seconds',
    'if hdr.dim(5)<3, return; end % skip structual, fieldmap etc',
    '',
    't = csa_header(s, \'MosaicRefAcqTimes\'); % in ms',
    'delay = asc_header(s, \'lDelayTimeInTR\')/1000; % in ms now',
    'if isempty(delay), delay = 0; end',
    'TA = TR - delay;',
    'if ~isempty(t) && isfield(s, \'LastFile\') && max(t)-min(t)>TA % MB wrong vol 1',
    '    try t = mb_slicetiming(s); end',
    'end',
    'if isempty(t), t = tryGetField(s, \'RefAcqTimes\'); end % GE or Siemens non-mosaic',
    '',
    'nSL = hdr.dim(4);',
    'if isempty(t) % non-mosaic Siemens: create \'t\' based on ucMode',
    '    ucMode = asc_header(s, \'sSliceArray.ucMode\'); % 1/2/4: Asc/Desc/Inter',
    '    if isempty(ucMode), return; end',
    '    t = linspace(0, TA, nSL+1)\'; t(end) = [];',
    '    if ucMode==2',
    '        t = t(nSL:-1:1);',
    '    elseif ucMode==4',
    '        if mod(nSL,2), t([1:2:nSL 2:2:nSL]) = t;',
    '        else t([2:2:nSL 1:2:nSL]) = t;',
    '        end',
    '    end',
    '    if asc_header(s, \'sSliceArray.ucImageNumb\'), t = t(nSL:-1:1); end % rev-num',
    '    s.RefAcqTimes = t;',
    'end',
    '',
    'if numel(t)<2, return; end',
    't = t - min(t); % it may be relative to 1st slice',
    '',
    't1 = sort(t);',
    'dur = mean(diff(t1));',
    'dif = mean(diff(t));',
    'if dur==0 || (t1(end)>TA), sc = 0; % no useful info, or bad timing MB',
    'elseif t1(1) == t1(2), sc = 7; % timing available MB, madeup code 7',
    'elseif abs(dif-dur)<1e-3, sc = 1; % ascending',
    'elseif abs(dif+dur)<1e-3, sc = 2; % descending',
    'elseif t(1)<t(3) % ascending interleaved',
    '    if t(1)<t(2), sc = 3; % odd slices first',
    '    else sc = 5; % Siemens even number of slices',
    '    end',
    'elseif t(1)>t(3) % descending interleaved',
    '    if t(1)>t(2), sc = 4;',
    '    else sc = 6; % Siemens even number of slices',
    '    end',
    'else sc = 0; % unlikely to reach',
    'end',
    '',
    's.SliceTiming = 0.5 - t/TR; % as for FSL custom timing',
    'hdr.slice_code = sc;',
    'hdr.slice_end = nSL-1; % 0-based, slice_start default to 0',
    'hdr.slice_duration = min(diff(t1))/1000;',
    '',
    '%% subfunction: extract bval & bvec, store in 1st header',
    'function [h, nii] = get_dti_para(h, nii)',
    'nSL = nii.hdr.dim(4);',
    'nDir = nii.hdr.dim(5);',
    'if nDir<2, return; end',
    'bval = nan(nDir, 1);',
    'bvec = nan(nDir, 3);',
    's = h{1};',
    '',
    'if isfield(s, \'bvec_original\')',
    '    bval = s.B_value;',
    '    bvec = tryGetField(s, \'bvec_original\');',
    'elseif isfield(s, \'PerFrameFunctionalGroupsSequence\')',
    '    fld = \'PerFrameFunctionalGroupsSequence\';',
    '    if tryGetField(s, \'Dim3IsVolume\', false), iDir = 1:nDir;',
    '    else iDir = 1:nSL:nSL*nDir;',
    '    end',
    '    dict = dicm_dict(s.Manufacturer, {fld \'B_value\' \'MRDiffusionSequence\' ...',
    '        \'DiffusionGradientDirectionSequence\' \'DiffusionGradientDirection\'});',
    '    s2 = dicm_hdr(s.Filename, dict, iDir); % re-read needed frames',
    '    sq = s2.(fld);',
    '    for j = 1:nDir',
    '        item = sprintf(\'Item_%g\', iDir(j));',
    '        try',
    '            a = sq.(item).MRDiffusionSequence.Item_1;',
    '            bval(j) = a.B_value;',
    '            a = a.DiffusionGradientDirectionSequence.Item_1;',
    '            bvec(j,:) = a.DiffusionGradientDirection;',
    '        end',
    '    end',
    'else % multiple files: order already in slices then volumes',
    '    dict = dicm_dict(s.Manufacturer, {\'B_value\' \'B_factor\' \'SlopInt_6_9\' ...',
    '       \'DiffusionDirectionX\' \'DiffusionDirectionY\' \'DiffusionDirectionZ\'});',
    '    iDir = (0:nDir-1) * length(h)/nDir + 1; % could be mosaic ',
    '    for j = 1:nDir % no these values for 1st file of each excitation',
    '        s2 = h{iDir(j)};',
    '        val = tryGetField(s2, \'B_value\');',
    '        if val == 0, continue; end',
    '        vec = tryGetField(s2, \'DiffusionGradientDirection\');',
    '        imgRef = isempty(vec); % likely GE if true. B_value=0 won\'t reach here',
    '        if isempty(val) || isempty(vec) % likely GE',
    '            s2 = dicm_hdr(s2.Filename, dict);',
    '        end',
    '        ',
    '        if isempty(val), val = tryGetField(s2, \'B_factor\'); end % old Philips',
    '        if isempty(val) && isfield(s2, \'SlopInt_6_9\') % GE',
    '            val = s2.SlopInt_6_9(1);',
    '        end',
    '        if isempty(val), val = 0; end % may be B_value=0',
    '        bval(j) = val;',
    '        ',
    '        if isempty(vec) % GE, old Philips',
    '            vec(1) = tryGetField(s2, \'DiffusionDirectionX\', 0);',
    '            vec(2) = tryGetField(s2, \'DiffusionDirectionY\', 0);',
    '            vec(3) = tryGetField(s2, \'DiffusionDirectionZ\', 0);',
    '        end',
    '        bvec(j,:) = vec;',
    '    end',
    'end',
    '',
    'if all(isnan(bval)) && all(isnan(bvec(:)))',
    '    errorLog([\'Failed to get DTI parameters: \' ProtocolName(s)]);',
    '    return; ',
    'end',
    'bval(isnan(bval)) = 0;',
    'bvec(isnan(bvec)) = 0;',
    '',
    'if strncmpi(s.Manufacturer, \'Philips\', 7)',
    '    if max(sum(bvec.^2, 2)) > 2 % guess in degree',
    '        for j = 1:nDir, bvec(j,:) = ang2vec(bvec(j,:)); end % deg to dir cos mat',
    '        errorLog([\'Please validate bvec (direction in deg): \' ProtocolName(s)]);',
    '    end',
    '    fld = \'DiffusionDirectionality\';',
    '    if bval(nDir)~=0 && all(abs(bvec(nDir,:))<1e-4)',
    '        if ~isfield(s, \'LastFile\') || ~isfield(s.LastFile, fld) || ...',
    '                ~strncmpi(s.LastFile.(fld), \'ISO\', 3)',
    '            % Remove last vol if it is computed ADC',
    '            bval(nDir) = [];',
    '            bvec(nDir,:) = [];',
    '            nii.img(:,:,:,nDir) = [];',
    '            nDir = nDir - 1;',
    '            nii.hdr.dim(5) = nDir;',
    '        end',
    '    end',
    'end',
    '',
    'h{1}.bval = bval; % store all into header of 1st file',
    'h{1}.bvec_original = bvec; % original from dicom',
    '',
    '% http://wiki.na-mic.org/Wiki/index.php/NAMIC_Wiki:DTI:DICOM_for_DWI_and_DTI',
    'if exist(\'imgRef\', \'var\') && imgRef % GE bvec already in image reference',
    '    % Following sign change is based on FSL result. non-axial slice not tested',
    '    % GE slices have been sorted by ImagePositionPatient',
    '    if strcmp(tryGetField(s, \'InPlanePhaseEncodingDirection\'), \'ROW\')',
    '        bvec = bvec(:, [2 1 3]);',
    '        bvec(:, 2:3) = -bvec(:, 2:3);',
    '    else',
    '        bvec(:, 1:2) = -bvec(:, 1:2);',
    '    end',
    'else % Siemens/Philips',
    '    [~, R] = xform_mat(s, nii.hdr.dim(2:4)); % R takes care of slice dir',
    '    R = R(1:3, 1:3);',
    '    R = bsxfun(@rdivide, R, sqrt(sum(R.^2))); % normalize',
    '    bvec = bvec * R; % dicom plane to image plane',
    'end',
    '',
    'h{1}.bvec = bvec; % computed bvec',
    '',
    '%% subfunction: save bval & bvec files',
    'function save_dti_para(s, fname)',
    'if ~isfield(s, \'bvec\') || all(s.bvec(:)==0), return; end',
    'if isfield(s, \'bval\')',
    '    fid = fopen([fname \'.bval\'], \'w\');',
    '    fprintf(fid, \'%g \', s.bval); % one row',
    '    fclose(fid);',
    'end',
    '',
    'str = repmat(\'%.6g \', 1, size(s.bvec,1));',
    'fid = fopen([fname \'.bvec\'], \'w\');',
    'fprintf(fid, [str \'\\n\'], s.bvec); % 3 rows by # direction cols',
    'fclose(fid);',
    '',
    '%% Subfunction: convert rotation angles to vector',
    'function vec = ang2vec(ang)',
    '% do the same as in philips_par: not sure it is right',
    'ca = cosd(ang); sa = sind(ang);',
    'rx = [1 0 0; 0 ca(1) -sa(1); 0 sa(1) ca(1)]; % standard 3D rotation',
    'ry = [ca(2) 0 sa(2); 0 1 0; -sa(2) 0 ca(2)];',
    'rz = [ca(3) -sa(3) 0; sa(3) ca(3) 0; 0 0 1];',
    'R = rx * ry * rz;',
    '% [~, iSL] = max(abs(R(:,3)));',
    '% if iSL == 1 % Sag',
    '%     R(:,[1 3]) = -R(:,[1 3]);',
    '%     R = R(:, [2 3 1]);',
    '% elseif iSL == 2 % Cor',
    '%     R(:,3) = -R(:,3);',
    '%     R = R(:, [1 3 2]);',
    '% end',
    '% http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm',
    'vec = [R(3,2)-R(2,3); R(1,3)-R(3,1); R(2,1)-R(1,2)];',
    'vec = vec / sqrt(sum(vec.^2));',
    '',
    '%% Subfunction, return a parameter from CSA Image/Series header',
    'function val = csa_header(s, key, dft)',
    'if isfield(s, \'CSAImageHeaderInfo\') && isfield(s.CSAImageHeaderInfo, key)',
    '    val = s.CSAImageHeaderInfo.(key);',
    'elseif isfield(s, \'CSASeriesHeaderInfo\') && isfield(s.CSASeriesHeaderInfo, key)',
    '    val = s.CSASeriesHeaderInfo.(key);',
    'elseif nargin>2',
    '    val = dft;',
    'else',
    '    val = [];',
    'end',
    '',
    '%% Subfunction, Convert 3x3 direction cosine matrix to quaternion',
    '% Simplied from Quaternions by Przemyslaw Baranski ',
    'function [q, proper] = dcm2quat(R)',
    'proper = sign(det(R)); % always -1 if flip_dim1',
    'if proper<0, R(:,3) = -R(:,3); end',
    '',
    'q = sqrt([1 1 1; 1 -1 -1; -1 1 -1; -1 -1 1] * diag(R) + 1) / 2;',
    'if ~isreal(q(1)), q(1) = 0; end % if trace(R)+1<0, zero it',
    '[m, ind] = max(q);',
    '',
    'switch ind',
    '    case 1',
    '        q(2) = (R(3,2) - R(2,3)) /m/4;',
    '        q(3) = (R(1,3) - R(3,1)) /m/4;',
    '        q(4) = (R(2,1) - R(1,2)) /m/4;',
    '    case 2',
    '        q(1) = (R(3,2) - R(2,3)) /m/4;',
    '        q(3) = (R(1,2) + R(2,1)) /m/4;',
    '        q(4) = (R(3,1) + R(1,3)) /m/4;',
    '    case 3',
    '        q(1) = (R(1,3) - R(3,1)) /m/4;',
    '        q(2) = (R(1,2) + R(2,1)) /m/4;',
    '        q(4) = (R(2,3) + R(3,2)) /m/4;',
    '    case 4',
    '        q(1) = (R(2,1) - R(1,2)) /m/4;',
    '        q(2) = (R(3,1) + R(1,3)) /m/4;',
    '        q(3) = (R(2,3) + R(3,2)) /m/4;',
    'end',
    'if q(1)<0, q = -q; end % as MRICron',
    '',
    '%% Subfunction: get dicom xform matrix and related info',
    'function [ixyz, R, pixdim, xyz_unit] = xform_mat(s, dim)',
    'R = reshape(tryGetField(s, \'ImageOrientationPatient\', [1 0 0 0 1 0]), 3, 2);',
    'R(:,3) = cross(R(:,1), R(:,2)); % right handed, but sign may be wrong',
    'foo = abs(R);',
    '[~, ixyz] = max(foo); % orientation info: perm of 1:3',
    'if ixyz(2) == ixyz(1), foo(ixyz(2),2) = 0; [~, ixyz(2)] = max(foo(:,2)); end',
    'if any(ixyz(3) == ixyz(1:2)), ixyz(3) = setdiff(1:3, ixyz(1:2)); end',
    'if nargout<2, return; end',
    'iSL = ixyz(3); % 1/2/3 for Sag/Cor/Tra slice',
    'cosSL = R(iSL, 3);',
    '',
    'thk = tryGetField(s, \'SpacingBetweenSlices\');',
    'if isempty(thk), thk = tryGetField(s, \'SliceThickness\'); end',
    'pixdim = tryGetField(s, \'PixelSpacing\');',
    'if isempty(thk) || isempty(pixdim), xyz_unit = 0; else xyz_unit = 2; end % mm',
    'if isempty(thk), thk = 1; end',
    'if isempty(pixdim), pixdim = [1 1]; end',
    'pixdim = [pixdim(:); thk];',
    'R = R * diag(pixdim); % apply vox size',
    '% Next is almost dicom xform matrix, except mosaic trans and unsure slice_dir',
    'R = [R tryGetField(s, \'ImagePositionPatient\', [0 0 0]\'); 0 0 0 1];',
    '',
    '% rest are former: R = verify_slice_dir(R, s, dim, iSL)',
    'if dim(3)<2, return; end % don\'t care direction for single slice',
    '',
    'if s.Columns > dim(1) % Siemens mosaic: use dim(1) since no transpose to img',
    '    R(:,4) = R * [ceil(sqrt(dim(3))-1)*dim(1:2)/2 0 1]\'; % real slice location',
    '    vec = csa_header(s, \'SliceNormalVector\'); % mosaic has this',
    '    if ~isempty(vec) % exist for all tested data',
    '        if sign(vec(iSL)) ~= sign(cosSL), R(:,3) = -R(:,3); end',
    '        return;',
    '    end',
    'elseif isfield(s, \'LastFile\') && isfield(s.LastFile, \'ImagePositionPatient\')',
    '    R(1:3, 3) = (s.LastFile.ImagePositionPatient - R(1:3,4)) / (dim(3)-1);',
    '    pixdim(3) = abs(R(iSL,3) / cosSL); % override slice thickness of dcm hdr',
    '    return; % almost all non-mosaic images return from here',
    'end',
    '',
    '% Rest of the code is almost unreachable',
    'if isfield(s, \'CSASeriesHeaderInfo\') % Siemens',
    '    ori = {\'Sag\' \'Cor\' \'Tra\'}; ori = ori{iSL};',
    '    sNormal = asc_header(s, [\'sSliceArray.asSlice[0].sNormal.d\' ori]);',
    '    % csa_header(s, \'ProtocolSliceNumber\') won\'t work for Mprage ',
    '    if asc_header(s, [\'sSliceArray.ucImageNumb\' ori]), sNormal = -sNormal; end',
    '    if sign(sNormal) ~= sign(cosSL), R(:,3) = -R(:,3); end',
    '    return;',
    'end',
    '',
    '% GE: sorted by ImagePosition, so slice dir is determined',
    'if strncmpi(tryGetField(s, \'Manufacturer\', \'\'),  \'GE\', 2)',
    '    % if iSL==1, cosSL = -cosSL; end % turn on this if SAG sorted descending',
    '    if cosSL<0, R(:,3) = -R(:,3); end',
    '    return;',
    'end',
    '',
    'pos = []; % SliceLocation for last or center slice we try to retrieve',
    '% if isempty(pos) && isfield(s, \'LastScanLoc\') && isfield(s, \'FirstScanLocation\')',
    '%     pos = [s.LastScanLoc s.FirstScanLocation];',
    '%     if iSL<3, pos = -pos; end % RAS convention!',
    '%     % if iSL==1, pos = -pos; end',
    '%     pos = max(pos);',
    '%     pos = [R(iSL, 1:2) pos] * [-(dim(1:2)-1)/2 1]\'; % 1st or last SliceLocation',
    '% end',
    '',
    '% May be useful for Philips dicom: use volume centre info',
    'if isempty(pos) && isfield(s, \'Stack\')',
    '    ori = {\'RL\' \'AP\' \'FH\'}; ori = ori{iSL};',
    '    pos = tryGetField(s.Stack.Item_1, [\'MRStackOffcentre\' ori]);',
    '    if ~isempty(pos)',
    '        pos = [R(iSL, 1:2) pos] * [-dim(1:2)/2 1]\'; % mid-slice location',
    '    end',
    'end',
    '',
    'if ~isempty(pos) % have SliceLocation for last/center slice',
    '    flp = sign(pos-R(iSL,4)) ~= sign(cosSL); % same direction?',
    'else % we do some guess work and warn user',
    '    errorLog([\'Please check whether slices are flipped: \' ProtocolName(s)]);',
    '    pos1 = R(iSL, 3:4) * [dim(3)-1 1]\'; % last SliceLocation based on current R',
    '    pos2 = R(iSL, 3:4) * [1-dim(3) 1]\'; % opposite slice direction',
    '    % if pos1 is larger than the other dir, and is way outside head',
    '    flp = all(abs(pos1) > [abs(pos2) 150]); % arbituary 150 mm',
    'end',
    'if flp, R(:,3) = -R(:,3); end % change to opposite direction',
    '',
    '%% Subfunction: get a parameter in CSA series ASC header: MrPhoenixProtocol',
    'function val = asc_header(s, key)',
    'val = []; ',
    'fld = \'CSASeriesHeaderInfo\';',
    'if ~isfield(s, fld), return; end',
    'if isfield(s.(fld), \'MrPhoenixProtocol\')',
    '    str = s.(fld).MrPhoenixProtocol;',
    'elseif isfield(s.(fld), \'MrProtocol\') % older version dicom',
    '    str = s.(fld).MrProtocol;',
    'else',
    '    str = char(s.(fld)\');',
    '    k0 = strfind(str, \'### ASCCONV BEGIN ###\');',
    '    k  = strfind(str, \'### ASCCONV END ###\');',
    '    str = str(k0:k); % avoid key before BEGIN and after END',
    'end',
    'k = strfind(str, [char(10) key]); % start with new line: safer',
    'if isempty(k), return; end',
    'str = strtok(str(k(1):end), char(10)); % the line',
    '[~, str] = strtok(str, \'=\'); % \'=\' and the vaule',
    'str = strtrim(strtok(str, \'=\')); % remvoe \'=\' and space ',
    '',
    'if strncmp(str, \'""\', 2) % str parameter',
    '    val = str(3:end-2);',
    'elseif strncmp(str, \'"\', 1) % str parameter for version like 2004A',
    '    val = str(2:end-1);',
    'elseif strncmp(str, \'0x\', 2) % hex parameter, convert to decimal',
    '    val = sscanf(str(3:end), \'%x\', 1);',
    'else % decimal',
    '    val = str2double(str);',
    'end',
    '',
    '%% Subfunction: return matlab decompress command if the file is compressed',
    'function func = compress_func(fname)',
    'func = \'\';',
    'fid = fopen(fname);',
    'if fid<0, return; end',
    'sig = fread(fid, 2, \'*uint8\')\';',
    'fclose(fid);',
    'if isequal(sig, [80 75]) % zip file',
    '    func = \'unzip\';',
    'elseif isequal(sig, [31 139]) % gz, tgz, tar',
    '    func = \'untar\';',
    'end',
    '% ! "c:\\program Files (x86)\\7-Zip\\7z.exe" x -y -oF:\\tmp\\ F:\\zip\\3047ZL.zip',
    '',
    '%% Subfuction: for GUI subfunctions',
    'function dicm2nii_gui(cmd, hs)',
    'if nargin<2',
    '    fh = figure(\'dicm\' * 256.^(0:3)\'); % arbitury integer',
    '    hs = guidata(fh); ',
    'end',
    'drawnow;',
    'switch cmd',
    '    case \'do_convert\'',
    '        if get(hs.srcType, \'Value\') > 2 % dicom, PAR, HEAD files',
    '            src = get(hs.src, \'UserData\');',
    '        else',
    '            src = get(hs.src, \'String\');',
    '        end',
    '        dst = get(hs.dst, \'String\');',
    '        if isempty(src) || isempty(dst)',
    '            str = \'Dicom source and Result folder must be specified\';',
    '            errordlg(str, \'Error Dialog\');',
    '            return;',
    '        end',
    '        rstFmt = (get(hs.rstFmt, \'Value\') - 1) * 2; % 0 or 2',
    '        if get(hs.gzip,  \'Value\'), rstFmt = rstFmt + 1; end % 1 or 3 ',
    '        if get(hs.rst3D, \'Value\'), rstFmt = rstFmt + 4; end % 4 to 7',
    '        mocoOpt = get(hs.mocoOpt, \'Value\') - 1;',
    '        set(hs.convert, \'Enable\', \'off\', \'string\', \'Conversion in progress\');',
    '        clnObj = onCleanup(@()set(hs.convert, \'Enable\', \'on\', \'String\', \'Start conversion\')); ',
    '        drawnow;',
    '        dicm2nii(src, dst, rstFmt, mocoOpt);',
    '        ',
    '        para.srcType = get(hs.srcType, \'Value\');',
    '        para.rstFmt = get(hs.rstFmt, \'Value\');',
    '        para.rst3D = get(hs.rst3D, \'Value\');',
    '        para.gzip = get(hs.gzip, \'Value\');',
    '        para.mocoOpt = get(hs.mocoOpt, \'Value\');',
    '        para.src = get(hs.src, \'String\');',
    '        para.dst = get(hs.dst, \'String\');',
    '        try save(get(hs.convert, \'UserData\'), \'para\'); end %#ok<*TRYNC>        ',
    '    case \'srcType\'',
    '        i = get(hs.srcType, \'Value\');',
    '        txt = {\'Source folder\' \'Zip / tar file\' \'Dicom files\' \'PAR files\' \'HEAD files\' \'BV files\'};',
    '        set(hs.srcTxt, \'String\' , txt{i});',
    '        srcdir = isdir(get(hs.src, \'String\'));',
    '        if (i==1 && ~srcdir) || (i>1 && srcdir)',
    '            set(hs.src, \'String\', \'\');',
    '        end',
    '    case \'dstDialog\'',
    '        folder = get(hs.dst, \'String\'); % current folder',
    '        if ~isdir(folder), folder = get(hs.src, \'String\'); end',
    '        if ~isdir(folder), folder = fileparts(folder); end',
    '        if ~isdir(folder), folder = pwd; end',
    '        dst = uigetdir(folder, \'Select a folder to save data files\');',
    '        if isnumeric(dst), return; end',
    '        set(hs.dst, \'String\' , dst);',
    '    case \'srcDialog\'',
    '        folder = get(hs.src, \'String\'); % initial folder',
    '        if ~isdir(folder), folder = fileparts(folder); end',
    '        if ~isdir(folder), folder = pwd; end',
    '        i = get(hs.srcType, \'Value\');',
    '        if i == 1 % folder',
    '            src = uigetdir(folder, \'Select a folder containing convertible files\');',
    '            if isnumeric(src), return; end',
    '            set(hs.src, \'UserData\', src);',
    '        elseif i == 2 % zip/tgz file',
    '            [src, folder] = uigetfile([folder \'/*.zip;*.tgz;*.tar;*.tar.gz\'], ...',
    '                \'Select the compressed file containing data files\');',
    '            if isnumeric(src), return; end',
    '            src = fullfile(folder, src);',
    '            set(hs.src, \'UserData\', src);',
    '        elseif i == 3 % dicom files',
    '            [src, folder] = uigetfile([folder \'/*.dcm\'], ...',
    '                \'Select one or more DICOM files\', \'MultiSelect\', \'on\');',
    '            if isnumeric(src), return; end',
    '            src = cellstr(src); % in case only 1 file selected',
    '            src = strcat(folder, filesep, src);',
    '            set(hs.src, \'UserData\', src);',
    '            src = src{1};',
    '        elseif i == 4 % PAR',
    '            [src, folder] = uigetfile([folder \'/*.PAR\'], ...',
    '                \'Select one or more PAR files\', \'MultiSelect\', \'on\');',
    '            if isnumeric(src), return; end',
    '            src = cellstr(src); % in case only 1 file selected',
    '            src = strcat(folder, src);',
    '            set(hs.src, \'UserData\', src);',
    '            src = src{1};',
    '        elseif i == 5 % HEAD/BRIK',
    '            [src, folder] = uigetfile([folder \'/*.HEAD\'], ...',
    '                \'Select one or more HEAD files\', \'MultiSelect\', \'on\');',
    '            if isnumeric(src), return; end',
    '            src = cellstr(src); % in case only 1 file selected',
    '            src = strcat(folder, src);',
    '            set(hs.src, \'UserData\', src);',
    '            src = src{1};',
    '        elseif i == 6 % BV files',
    '            [src, folder] = uigetfile([folder \'/*.fmr;*.vmr;*.dmr\'], ...',
    '                \'Select one or more BrainVoyager fmr/vmr/dmr files\', \'MultiSelect\', \'on\');',
    '            if isnumeric(src), return; end',
    '            src = cellstr(src); % in case only 1 file selected',
    '            src = strcat(folder, src);',
    '            set(hs.src, \'UserData\', src);',
    '            src = src{1};',
    '        end',
    '        set(hs.src, \'String\' , src);',
    '    case \'set_src\'',
    '        str = get(hs.src, \'String\');',
    '        if ~exist(str, \'file\')',
    '            val = dir(str);',
    '            folder = fileparts(str);',
    '            if isempty(val)',
    '                val = get(hs.src, \'UserData\');',
    '                if iscellstr(val), val = val{1}; end',
    '                set(hs.src, \'String\', val);',
    '                errordlg(\'Invalid input\', \'Error Dialog\');',
    '                return;',
    '            end',
    '            str = {val.name};',
    '            str = strcat(folder, filesep, str);',
    '        end',
    '        set(hs.src, \'UserData\', str);',
    '    case \'set_dst\'',
    '        str = get(hs.dst, \'String\');',
    '        if isempty(str), return; end',
    '        if ~exist(str, \'file\') && ~mkdir(str)',
    '            set(hs.dst, \'String\', \'\');',
    '            errordlg([\'Invalid folder name \'\'\' str \'\'\'\'], \'Error Dialog\');',
    '            return;',
    '        end',
    '    case \'SPMStyle\' % turn off compression',
    '        if get(hs.rst3D, \'Value\'), set(hs.gzip, \'Value\', 0); end',
    '    case \'about\'',
    '        if get(hs.about, \'Value\')==1',
    '            str = sprintf([\'dicm2nii.m by Xiangrui Li\\n\\n\' ...',
    '                \'Feedback to: xiangrui.li@gmail.com\\n\\n\' ...',
    '                \'Last updated on 20%s\\n\'], reviseDate);',
    '            helpdlg(str, \'About dicm2nii\')',
    '        else',
    '            fid = fopen([fileparts(which(mfilename)) \'/license.txt\']);',
    '            if fid<1',
    '                str = \'license.txt file not found\';',
    '            else',
    '                str = strtrim(fread(fid, \'*char\')\');',
    '                fclose(fid);',
    '            end',
    '            helpdlg(str, \'License\')',
    '        end',
    '        set(hs.about, \'Value\', 1);',
    '    otherwise',
    '        create_gui;',
    'end',
    '',
    '%% Subfuction: create GUI or bring it to front if exists',
    'function create_gui',
    'fh = figure(\'dicm\' * 256.^(0:3)\'); % arbitury integer',
    'if strcmp(\'dicm2nii_fig\', get(fh, \'Tag\')), return; end',
    '',
    'fnameH = [getenv(\'HOME\') \'/dicm2nii_gui_para.mat\'];',
    'fname = fnameH;',
    'if ~exist(fname, \'file\')',
    '    fname = [fileparts(which(mfilename)) \'/dicm2nii_gui_para.mat\'];',
    '    if ~exist(fname, \'file\')',
    '        fid = fopen(fname, \'w\'); % check permission',
    '        if fid<1',
    '            fname = fnameH;',
    '        else',
    '            fclose(fid); delete(fname);',
    '        end',
    '    end',
    'end',
    '',
    'scrSz = get(0, \'ScreenSize\');',
    'set(fh, \'Toolbar\', \'none\', \'Menubar\', \'none\', \'Resize\', \'off\', ...',
    '    \'Tag\', \'dicm2nii_fig\', \'Position\', [200 scrSz(4)-500 420 256], ...',
    '    \'Name\', \'DICOM to NIfTI Converter\', \'NumberTitle\', \'off\');',
    'clr = get(fh, \'color\');',
    '',
    'str = \'Choose what kind of data source you are using\';',
    'uicontrol(\'Style\', \'text\', \'Position\', [10 206 90 30], ...',
    '    \'FontSize\', 9, \'HorizontalAlignment\', \'left\', ...',
    '    \'String\', \'Source type\', \'Background\', clr, \'TooltipString\', str);',
    'uicontrol(\'Style\', \'popup\', \'Background\', \'white\', \'Tag\', \'srcType\', ...',
    '    \'String\', [\' Folder containing convertible files and/or folders|\' ...',
    '               \' Compressed file containing data|\' ...',
    '               \' Dicom files|\' ...',
    '               \' Philips PAR files|\' ...',
    '               \' AFNI HEAD files|\' ...',
    '               \' BrainVoyager dmr/fmr/vmr files\'], ...',
    '    \'Position\', [88 210 320 30], \'TooltipString\', str, ...',
    '    \'Callback\', \'dicm2nii([],\'\'srcType\'\',\'\'gui_callback\'\');\');',
    '',
    'str = \'Enter or browse the data source according to the source type\';',
    'uicontrol(\'Style\', \'text\', \'Position\', [10 166 90 30], ...',
    '    \'Tag\', \'srcTxt\', \'FontSize\', 9, \'HorizontalAlignment\', \'left\', ...',
    '    \'String\', \'Source folder\', \'Background\', clr, \'TooltipString\', str);',
    'uicontrol(\'Style\', \'edit\', \'Position\', [88 176 296 24],\'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'Background\', \'white\', \'Tag\', \'src\', ...',
    '    \'TooltipString\', str, ...',
    '    \'Callback\', \'dicm2nii([],\'\'set_src\'\',\'\'gui_callback\'\');\');',
    'uicontrol(\'Style\', \'pushbutton\', \'Position\', [384 177 24 22], ...',
    '    \'FontSize\', 9, \'String\', \'...\', ...',
    '    \'TooltipString\', \'Browse dicom source\', ...',
    '    \'Callback\', \'dicm2nii([],\'\'srcDialog\'\',\'\'gui_callback\'\');\');',
    '',
    'str = \'Enter or browse a folder to save result files\';',
    'uicontrol(\'Style\', \'text\', \'Position\', [10 126 90 30], ...',
    '    \'FontSize\', 9, \'HorizontalAlignment\', \'left\', ...',
    '    \'String\', \'Result folder\', \'Background\', clr, \'TooltipString\', str);',
    'uicontrol(\'Style\', \'edit\', \'Position\', [88 136 296 24], \'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'Background\', \'white\', ...',
    '    \'Tag\', \'dst\', \'TooltipString\', str, ...',
    '    \'Callback\', \'dicm2nii([],\'\'set_dst\'\',\'\'gui_callback\'\');\');',
    'uicontrol(\'Style\', \'pushbutton\', \'Position\', [384 137 24 22], ...',
    '    \'FontSize\', 9, \'String\', \'...\', ...',
    '    \'TooltipString\', \'Browse result folder\', ...',
    '    \'Callback\', \'dicm2nii([],\'\'dstDialog\'\',\'\'gui_callback\'\');\');',
    '',
    'str = \'Choose output file format\';',
    'uicontrol(\'Style\', \'text\', \'Position\', [10 88 90 30], \'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'String\', \'Output format\', ...',
    '    \'Background\', clr, \'TooltipString\', str);',
    '',
    'uicontrol(\'Style\', \'popup\', \'Background\', \'white\', \'Tag\', \'rstFmt\', ...',
    '    \'Value\', 1, \'Position\', [88 92 100 30], \'TooltipString\', str, ...',
    '    \'String\', \' .nii| .hdr/.img\');',
    '',
    'str = \'Compress into .gz files\';',
    'uicontrol(\'Style\', \'checkbox\', \'Position\', [220 96 112 30], \'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'String\', \'Compress\', ...',
    '    \'Background\', clr, \'TooltipString\', str, \'Tag\', \'gzip\');',
    '',
    'str = \'Save one file for each volume (SPM style)\';',
    'uicontrol(\'Style\', \'checkbox\', \'Position\', [330 96 72 30], \'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'String\', \'SPM 3D\', ...',
    '    \'Background\', clr, \'TooltipString\', str, \'Tag\', \'rst3D\', ...',
    '    \'Callback\', \'dicm2nii([],\'\'SPMStyle\'\',\'\'gui_callback\'\');\');',
    '           ',
    'str = \'Choose the way to deal with SIEMENS MoCo series\';',
    'uicontrol(\'Style\', \'text\', \'Position\', [10 46 90 30], \'FontSize\', 9, ...',
    '    \'HorizontalAlignment\', \'left\', \'String\', \'MoCoSeries\', ...',
    '    \'Background\', clr, \'TooltipString\', str);',
    'uicontrol(\'Style\', \'popup\', \'Background\', \'white\', \'Tag\', \'mocoOpt\', ...',
    '     \'Position\', [88 50 320 30], \'Value\', 2, \'TooltipString\', str, ...',
    '     \'String\', [\' Convert both original and MoCo series|\' ...',
    '                \' Convert only original series if both exist|\' ...',
    '                \' Convert only MoCo series if both exist\']);',
    '',
    'uicontrol(\'Style\', \'pushbutton\', \'Position\', [104 10 200 30], ...',
    '    \'FontSize\', 9, \'String\', \'Start conversion\', \'Tag\', \'convert\', ...',
    '    \'UserData\', fname, ...',
    '    \'TooltipString\', \'Dicom source and Result folder needed before start\', ...',
    '    \'Callback\', \'dicm2nii([],\'\'do_convert\'\',\'\'gui_callback\'\');\');',
    '',
    'uicontrol(\'Style\', \'popup\', \'Tag\', \'about\', \'String\', \'About|License\', ...',
    '    \'Position\', [354 4 56 30], \'Callback\', \'dicm2nii([],\'\'about\'\',\'\'gui_callback\'\');\');',
    '',
    'hs = guihandles(fh); % get handles',
    'guidata(fh, hs); % store handles',
    'set(fh, \'HandleVisibility\', \'callback\'); % protect from command line',
    '',
    'if ~exist(fname, \'file\'), return; end',
    'para = load(fname); para = para.para;',
    'fn = fieldnames(para);',
    'for i = 1:length(fn)',
    '    tag = fn{i};',
    '    if ~isfield(hs, tag)',
    '        continue;  % avoid error',
    '    elseif strcmpi(get(hs.(tag), \'Style\'), \'edit\')',
    '        set(hs.(tag), \'String\', para.(tag));',
    '    else',
    '        set(hs.(tag), \'Value\', para.(tag));',
    '    end',
    '    cb = get(hs.(tag), \'Callback\');',
    '    if ~isempty(cb), eval(cb); end',
    'end',
    '',
    '%% subfunction: return phase positive and phase axis (1/2) in image reference',
    'function [phPos, iPhase] = phaseDirection(s)',
    'phPos = []; iPhase = [];',
    'fld = \'InPlanePhaseEncodingDirection\';',
    'if isfield(s, fld)',
    '    if     strncmpi(s.(fld), \'COL\', 3), iPhase = 2; % based on dicm_img(s,0)',
    '    elseif strncmpi(s.(fld), \'ROW\', 3), iPhase = 1;',
    '    else errorLog([\'Unknown \' fld \' for \' ProtocolName(s) \': \' s.(fld)]);',
    '    end',
    'end',
    '',
    'if strncmpi(s.Manufacturer, \'SIEMENS\', 7)',
    '    phPos = csa_header(s, \'PhaseEncodingDirectionPositive\'); % image ref',
    'elseif strncmpi(s.Manufacturer, \'GE\', 2)',
    '    fld = \'ProtocolDataBlock\';',
    '    if isfield(s, fld) && isfield(s.(fld), \'VIEWORDER\')',
    '        phPos = s.(fld).VIEWORDER == 1; % 1 == bottom_up',
    '    end',
    'elseif strncmpi(s.Manufacturer, \'Philips\', 7)',
    '    if ~isfield(s, \'ImageOrientationPatient\'), return; end',
    '    fld = \'MRStackPreparationDirection\';',
    '    if ~isfield(s, \'Stack\') || ~isfield(s.Stack.Item_1, fld), return; end',
    '    R = reshape(s.ImageOrientationPatient, 3, 2);',
    '    [~, ixy] = max(abs(R)); % like [1 2]',
    '    d = s.Stack.Item_1.(fld)(1); % 2-letter like \'AP\'',
    '    if isempty(iPhase) % if no InPlanePhaseEncodingDirection',
    '        iPhase = strfind(\'RLAPFH\', d);',
    '        iPhase = ceil(iPhase/2); % 1/2/3 for RL/AP/FH',
    '        iPhase = find(ixy==iPhase); % now 1 or 2',
    '    end',
    '    if     any(d == \'LPH\'), phPos = false;',
    '    elseif any(d == \'RAF\'), phPos = true;',
    '    end',
    '    if R(ixy(iPhase), iPhase)<0, phPos = ~phPos; end % tricky',
    'end',
    '',
    '%% subfunction: extract useful fields for multiframe dicom',
    'function s = multiFrameFields(s)',
    'if any(~isfield(s, {\'SharedFunctionalGroupsSequence\' ...',
    '        \'PerFrameFunctionalGroupsSequence\'}))',
    '    return; % do nothing',
    'end',
    's1 = s.SharedFunctionalGroupsSequence.Item_1;',
    's2 = s.PerFrameFunctionalGroupsSequence.Item_1;',
    '',
    'fld = \'EffectiveEchoTime\'; n1 = \'MREchoSequence\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1; val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, \'EchoTime\') && ~isempty(val), s.EchoTime = val; end',
    'if ~isfield(s, \'EchoTime\') && isfield(s, \'EchoTimeDisplay\')',
    '	s.EchoTime = s.EchoTimeDisplay;',
    'end',
    '',
    'n1 = \'MRTimingAndRelatedParametersSequence\';',
    'fld = \'RepetitionTime\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'PixelSpacing\'; n1 = \'PixelMeasuresSequence\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'SpacingBetweenSlices\';  val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'SliceThickness\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'RescaleIntercept\'; n1 = \'PixelValueTransformationSequence\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'RescaleSlope\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'ImageOrientationPatient\'; n1 = \'PlaneOrientationSequence\'; val = [];',
    'if isfield(s1, n1)',
    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',
    'elseif isfield(s2, n1)',
    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',
    'end',
    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    '',
    'fld = \'ImagePositionPatient\'; n1 = \'PlanePositionSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1); val = tryGetField(a.Item_1, fld);',
    '    if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',
    'end',
    '',
    's2 = s.PerFrameFunctionalGroupsSequence;',
    'n1 = fieldnames(s2);',
    'if length(n1) < 2, return; end % in case of only 1 frame',
    's2 = s2.(n1{end}); % last frame',
    '',
    'fld = \'DiffusionDirectionality\'; n1 = \'MRDiffusionSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val), s.LastFile.(fld) = val; end',
    'end',
    '',
    '% check ImageOrientationPatient consistency for 1st and last frame only',
    'fld = \'ImageOrientationPatient\'; n1 = \'PlaneOrientationSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val)',
    '        try',
    '            if any(abs(val-s.ImageOrientationPatient) > 1e-4)',
    '                s = []; % silently ignore it',
    '                return; % inconsistent orientation, remove the field',
    '            end',
    '        end',
    '    end',
    'end',
    '',
    '% GE data may need this to get LocationsInAcquisition',
    'fld = \'DimensionIndexValues\'; n1 = \'FrameContentSequence\';',
    'if isfield(s2, n1) && ~isfield(s, \'LocationsInAcquisition\')',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if numel(val)>1, s.LocationsInAcquisition = val(2); end',
    'end',
    '',
    'fld = \'ImagePositionPatient\'; n1 = \'PlanePositionSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val), s.LastFile.(fld) = val; end',
    'end',
    '',
    'fld = \'ComplexImageComponent\'; n1 = \'MRImageFrameTypeSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val), s.LastFile.(fld) = val; end',
    'end',
    '',
    'fld = \'RescaleIntercept\'; n1 = \'PixelValueTransformationSequence\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val), s.LastFile.(fld) = val; end',
    'end',
    'fld = \'RescaleSlope\';',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if ~isempty(val), s.LastFile.(fld) = val; end',
    'end',
    '',
    'fld = \'ImagePositionPatient\'; n1 = \'PlanePositionSequence\';',
    's2 = s.PerFrameFunctionalGroupsSequence.Item_2;',
    'if isfield(s2, n1)',
    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',
    '    if isfield(s, fld) && all(abs(s.(fld)-val)<1e-4)',
    '        s.Dim3IsVolume = true;',
    '    end',
    '    if isfield(s, \'LocationsInAcquisition\'), return; end',
    '    ',
    '    % Following code try to get LocationsInAcquisition',
    '    if isempty(val) || ~isfield(s, \'ImageOrientationPatient\') || ...',
    '          ~isfield(s, \'LastFile\') || ~isfield(s.LastFile, fld)',
    '        return; % give up: no needed info',
    '    end',
    '    ',
    '    R = reshape(s.ImageOrientationPatient, 3, 2);',
    '    [cosSL, iSL] = max(abs(cross(R(:,1), R(:,2))));',
    '    dVL = s.LastFile.(fld) - s.(fld); dVL = dVL(iSL);',
    '',
    '    if ~tryGetField(s, \'Dim3IsVolume\', false) % frames 1&2 are different slices',
    '        dSL = val(iSL) - s.(fld)(iSL);',
    '        s.LocationsInAcquisition = abs(round(dVL/dSL)) + 1;',
    '        return;',
    '    end',
    '    ',
    '    thk = tryGetField(s, \'SpacingBetweenSlices\');',
    '    if isempty(thk), thk = tryGetField(s, \'SliceThickness\'); end',
    '    if ~isempty(thk)',
    '        s.LocationsInAcquisition = abs(round(dVL/cosSL/thk)) + 1;',
    '        return;',
    '    end',
    '    ',
    '    % By ImagePositionPatient of all frames: slow',
    '    dict = dicm_dict(\'\', {\'PerFrameFunctionalGroupsSequence\' n1 fld});',
    '    s2 = dicm_hdr(s.Filename, dict, \'all\');',
    '    s2 = s2.PerFrameFunctionalGroupsSequence;',
    '    flds = fieldnames(s2);',
    '    n = length(flds);',
    '    a = nan(n, 1);',
    '    for i = 1:n, a(i) = s2.(flds{i}).(n1).Item_1.(fld)(iSL); end',
    '    s.LocationsInAcquisition = sum(diff(sort(a)) > 1e-4) + 1;',
    'end',
    '',
    '%% subfunction: split nii into mag and phase for Philips single file',
    'function [nii, niiP] = split_philips_phase(nii, s)',
    'niiP = [];',
    'if ~strcmp(tryGetField(s, \'ComplexImageComponent\', \'\'), \'MIXED\') ... % multiframe',
    '        && (~isfield(s, \'VolumeIsPhase\') || ... ',
    '            all(s.VolumeIsPhase) || ~any(s.VolumeIsPhase)) % not MIXED',
    '    return;',
    'end',
    '',
    'if ~isfield(s, \'VolumeIsPhase\') % PAR file and single-frame file have this',
    '    dim = nii.hdr.dim(4:5);',
    '    if tryGetField(s, \'Dim3IsVolume\'), iFrames = 1:dim(2);',
    '    else iFrames = 1:dim(1):dim(1)*dim(2);',
    '    end',
    '    flds = {\'PerFrameFunctionalGroupsSequence\' ...',
    '        \'MRImageFrameTypeSequence\' \'ComplexImageComponent\'};',
    '    if dim(2) == 2 % 2 volumes, no need to re-read ComplexImageComponent',
    '        iFrames(2) = dim(1)*dim(2); % use last frame',
    '        s1.(flds{1}) = s.(flds{1});        ',
    '    else',
    '        dict = dicm_dict(s.Manufacturer, flds);',
    '        s1 = dicm_hdr(s.Filename, dict, iFrames);',
    '    end',
    '    s.VolumeIsPhase = false(dim(2), 1);',
    '    for i = 1:dim(2)',
    '        Item = sprintf(\'Item_%g\', iFrames(i));',
    '        foo = s1.(flds{1}).(Item).(flds{2}).Item_1.(flds{3});',
    '        s.VolumeIsPhase(i) = strcmp(foo, \'PHASE\');',
    '    end',
    'end',
    '',
    'niiP = nii;',
    'niiP.img = nii.img(:,:,:,s.VolumeIsPhase);',
    'n = sum(s.VolumeIsPhase);',
    'niiP.hdr.dim(5) = n; % may be 1 always',
    'niiP.hdr.dim(1) = 3 + (n>1);',
    '',
    'nii.img(:,:,:,s.VolumeIsPhase) = []; % now only mag',
    'n = sum(~s.VolumeIsPhase);',
    'nii.hdr.dim(5) = n; % may be 1 always',
    'nii.hdr.dim(1) = 3 + (n>1);',
    '',
    '% undo scale for 2nd set img if it was applied in set_nii_header',
    'if (nii.hdr.scl_inter==0) && (nii.hdr.scl_slope==1) && ...',
    '        (tryGetfield(s, \'RescaleIntercept\') ~=0 ) && ...',
    '        (tryGetfield(s, \'RescaleSlope\') ~= 1)',
    '    if s.VolumeIsPhase(1)',
    '        nii.img = (nii.img - s.RescaleIntercept) / s.RescaleSlope;',
    '        nii.hdr.scl_inter = s.LastFile.RescaleIntercept;',
    '        nii.hdr.scl_slope = s.LastFile.RescaleSlope;',
    '    else',
    '        niiP.img = (niiP.img - s.RescaleIntercept) / s.RescaleSlope;',
    '        niiP.hdr.scl_inter = s.LastFile.RescaleIntercept;',
    '        niiP.hdr.scl_slope = s.LastFile.RescaleSlope;',
    '    end',
    'end',
    '',
    '%% Write error info to a file in case user ignores Command Window output',
    'function firstTime = errorLog(errInfo, folder)',
    'persistent dataFolder;',
    'if nargin>1, firstTime = isempty(dataFolder); dataFolder = folder; end',
    'if isempty(errInfo), return; end',
    'fprintf(2, \' %s\\n\', errInfo); % red text in Command Window',
    'fid = fopen([dataFolder \'dicm2nii_warningMsg.txt\'], \'a\');',
    'fseek(fid, 0, -1); ',
    'fprintf(fid, \'%s\\n\', errInfo);',
    'fclose(fid);',
    '',
    '%% Get the last date string in history',
    'function dStr = reviseDate',
    'dStr = \'150609?\';',
    'fid = fopen(which(mfilename));',
    'if fid<1, return; end',
    'str = fread(fid, \'*char\')\';',
    'fclose(fid);',
    'ind = strfind(str, \'% End of history. Don\'\'t edit this line!\');',
    'if isempty(ind), return; end',
    'ind = ind(1);',
    'ret = str(ind-1); % new line char: \\r or \\n',
    'str = str(max(1, ind-500):ind+2); % go back several lines',
    'ind = strfind(str, [ret \'% \']); % new line with % and space',
    'for i = 1:numel(ind)-1',
    '    ln = str(ind(i)+3 : ind(i+1)-1);',
    '    if length(ln)>5 && all(isstrprop(ln(1:6), \'digit\'))',
    '        dStr = ln(1:6);',
    '    end ',
    'end',
    '',
    '%% Get position info from Siemens CSA header',
    '% The only case this is useful for now is for DTI_ColFA, where Siemens omit ',
    '% ImageOrientationPatient, ImagePositionPatient, PixelSpacing.',
    '% This shows how to get info from Siemens CSA header.',
    'function s = csa2pos(s, nSL)',
    'if ~isfield(s, \'CSASeriesHeaderInfo\'); return; end',
    'if ~isfield(s, \'PixelSpacing\')',
    '    a = asc_header(s, \'sSliceArray.asSlice[0].dReadoutFOV\');',
    '    a = a ./ asc_header(s, \'sKSpace.lBaseResolution\');',
    '    interp = asc_header(s, \'sKSpace.uc2DInterpolation\');',
    '    if interp, a = a ./ 2; end',
    '    if ~isempty(a), s.PixelSpacing =  a * [1 1]\'; end',
    'end',
    '',
    'revNum = ~isempty(asc_header(s, \'sSliceArray.ucImageNumb\'));',
    'isMos = ~isempty(csa_header(s, \'NumberOfImagesInMosaic\'));',
    'ori = {\'Sag\' \'Cor\' \'Tra\'}; % 1/2/3',
    'if ~isfield(s, \'ImageOrientationPatient\')',
    '    R = zeros(3);',
    '    for i = 1:3',
    '        a = asc_header(s, [\'sSliceArray.asSlice[0].sNormal.d\' ori{i}]);',
    '        if ~isempty(a), R(i,3) = a; end',
    '    end',
    '    ',
    '    % set SliceNormalVector for mosaic if it is missing',
    '    if isMos && ~isfield(s.CSAImageHeaderInfo, \'SliceNormalVector\')',
    '        sNormal = R(:,3);',
    '        if revNum, sNormal = -sNormal; end',
    '        s.CSAImageHeaderInfo.SliceNormalVector = sNormal;',
    '    end',
    '',
    '    [~, iSL] = max(abs(R(:,3)));',
    '    if iSL==3',
    '        R(:,2) = [0 R(3,3) -R(2,3)] / sqrt(sum(R(2:3,3).^2));',
    '        R(:,1) = cross(R(:,2), R(:,3));',
    '    elseif iSL==2',
    '        R(:,1) = [R(2,3) -R(1,3) 0] / sqrt(sum(R(1:2,3).^2));',
    '        R(:,2) = cross(R(:,3), R(:,1));',
    '    elseif iSL==1',
    '        R(:,1) = [-R(2,3) R(1,3) 0] / sqrt(sum(R(1:2,3).^2));',
    '        R(:,2) = cross(R(:,1), R(:,3));',
    '    end',
    '',
    '    rot = asc_header(s, \'sSliceArray.asSlice[0].dInPlaneRot\');',
    '    if isempty(rot), rot = 0; end',
    '    rot = rot - round(rot/pi*2)*pi/2; % -45 to 45 deg, is this right?',
    '    ca = cos(rot); sa = sin(rot);',
    '    R = R * [ca sa 0; -sa ca 0; 0 0 1];',
    '    s.ImageOrientationPatient = R(1:6)\';',
    'end',
    '',
    'if ~isfield(s, \'ImagePositionPatient\')',
    '    pos = zeros(3,2);',
    '    sl = [0 nSL-1];',
    '    for j = 1:2',
    '        key = sprintf(\'sSliceArray.asSlice[%g].sPosition.d\', sl(j));',
    '        for i = 1:3',
    '            a = asc_header(s, [key ori{i}]);',
    '            if ~isempty(a), pos(i,j) = a; end',
    '        end',
    '    end',
    '    ',
    '    R = reshape(s.ImageOrientationPatient, 3, 2);',
    '    R = R * diag(s.PixelSpacing);',
    '    dim = double([s.Columns s.Rows]);',
    '    if all(pos(:,2) == 0) % Mprage, dThickness and sPosition are for volume',
    '        sNormal = zeros(3,1);',
    '        for i = 1:3',
    '            a = asc_header(s, [\'sSliceArray.asSlice[0].sNormal.d\' ori{i}]);',
    '            if ~isempty(a), sNormal(i) = a; end',
    '        end',
    '        v3 = asc_header(s, \'sSliceArray.asSlice[0].dThickness\');',
    '        R = [R sNormal*v3/nSL];',
    '        x = [-dim\'/2*[1 1]; (1-nSL)/2*[1 -1]];',
    '        pos = R * x + pos(:,1) * [1 1];',
    '    else % likely mosaic',
    '        pos = pos - R * dim\'/2 * [1 1];',
    '    end',
    '    if revNum, pos = pos(:, [2 1]); end',
    '    if isMos, pos(:,2) = pos(:,1); end % set LastFile same as first for mosaic',
    '    s.ImagePositionPatient = pos(:,1);',
    '    s.LastFile.ImagePositionPatient = pos(:,2);',
    'end',
    '',
    '%% subfuction: check whether parpool is available',
    '% Return true if it is already open, or open it if available',
    'function doParal = useParTool(toOpen)',
    'doParal = usejava(\'jvm\');',
    'if ~doParal, return; end',
    '',
    'if isempty(which(\'parpool\')) % for early matlab versions',
    '    try ',
    '        if matlabpool(\'size\')<1 %#ok<*DPOOL>',
    '            try',
    '                if toOpen, matlabpool; ',
    '                else doParal = false;',
    '                end',
    '            catch me',
    '                fprintf(2, \'%s\\n\', me.message);',
    '                doParal = false;',
    '            end',
    '        end',
    '    catch',
    '        doParal = false;',
    '    end',
    '    return;',
    'end',
    '',
    '% Following for later matlab with parpool',
    'try ',
    '    if isempty(gcp(\'nocreate\'))',
    '        try',
    '            if toOpen, parpool; ',
    '            else doParal = false;',
    '            end',
    '        catch me',
    '            fprintf(2, \'%s\\n\', me.message);',
    '            doParal = false;',
    '        end',
    '    end',
    'catch',
    '    doParal = false;',
    'end',
    '',
    '%% subfunction: return nii ext from dicom struct',
    '% The txt extension is in format of: name = parameter;',
    '% Each parameter ends with [\';\' char(0 10)]. Examples:',
    '% Modality = \'MR\'; % str parameter enclosed in single quotation marks',
    '% FlipAngle = 72; % single numeric value, brackets may be used, but optional',
    '% SliceTiming = [0.5 0.1 ... ]; % vector parameter enclosed in brackets',
    '% bvec = [0 -0 0 ',
    '% -0.25444411 0.52460458 -0.81243353 ',
    '% ...',
    '% 0.9836791 0.17571079 0.038744]; % matrix rows separated by char(10) and/or \';\'',
    'function ext = set_nii_ext(s)',
    'flds = { % fields to put into nifti ext',
    '  \'NiftiCreator\' \'SeriesNumber\' \'SeriesDescription\' \'ImageType\' \'Modality\' ...',
    '  \'AcquisitionDateTime\' \'bval\' \'bvec\' \'ReadoutSeconds\' \'SliceTiming\' ...',
    '  \'UnwarpDirection\' \'EffectiveEPIEchoSpacing\' \'EchoTime\' \'deltaTE\' ...',
    '  \'PatientName\' \'PatientSex\' \'PatientAge\' \'PatientSize\' \'PatientWeight\' ...',
    '  \'SliceThickness\' \'FlipAngle\' \'RBMoCoTrans\' \'RBMoCoRot\' ...',
    '  \'Manufacturer\' \'SoftwareVersion\' \'MRAcquisitionType\' \'InstitutionName\' ...',
    '  \'ScanningSequence\' \'SequenceVariant\' \'ScanOptions\' \'SequenceName\'};',
    '',
    'ext.ecode = 6; % text ext',
    'ext.edata = \'\';',
    'for i = 1:length(flds)',
    '    val = tryGetField(s, flds{i});',
    '    if isempty(val)',
    '        continue;',
    '    elseif ischar(val)',
    '        str = sprintf(\'\'\'%s\'\'\', val);',
    '    elseif numel(val) == 1 % single numeric',
    '        str = sprintf(\'%.8g\', val);',
    '    elseif isvector(val) % row or column',
    '        str = sprintf(\'%.8g \', val);',
    '        str = sprintf(\'[%s]\', str(1:end-1)); % drop last space',
    '    else % matrix, like DTI bvec',
    '        fmt = repmat(\'%.8g \', 1, size(val, 2));',
    '        str = sprintf([fmt char(10)], val\');',
    '        str = sprintf(\'[%s]\', str(1:end-2)); % drop last space and char(10)',
    '    end',
    '    ext.edata = [ext.edata flds{i} \' = \' str \';\' char([0 10])];',
    'end',
    '',
    '% % Matlab ext: ecode = 40',
    '% fname = [tempname \'.mat\'];',
    '% save(fname, \'-struct\', \'s\', \'-v7\'); % field as variable',
    '% fid = fopen(fname);',
    '% b = fread(fid, inf, \'*uint8\'); % data bytes',
    '% fclose(fid);',
    '% delete(fname);',
    '% ',
    '% % first 4 bytes (int32) encode real data length, endian-dependent',
    '% if exist(\'ext\', \'var\'), n = length(ext)+1; else n = 1; end',
    '% ext(n).edata = [typecast(int32(numel(b)), \'uint8\')\'; b];',
    '% ext(n).ecode = 40; % Matlab',
    ' ',
    '% % Dicom ext: ecode = 2',
    '% if isfield(s, \'SOPInstanceUID\') % make sure it is dicom',
    '%     if exist(\'ext\', \'var\'), n = length(ext)+1; else n = 1; end',
    '%     ext(n).ecode = 2; % dicom',
    '%     fid = fopen(s.Filename);',
    '%     ext(n).edata = fread(fid, s.PixelData.Start, \'*uint8\');',
    '%     fclose(fid);',
    '% end',
    '',
    '%% Fix some broken multiband sliceTiming. Hope this won\'t be needed in future.',
    '% Odd number of nShot is fine, but some even nShot may have problem.',
    '% This gives inconsistent result to the following example in PDF doc, but I',
    '% would rather believe the example is wrong:',
    '% nSL=20; mb=2; nShot=nSL/mb; % inc=3',
    '% In PDF: 0,10 - 3,13 - 6,16 - 9,19 - 1,11 - 4,14 - 7,17 - 2,12 - 5,15 - 8,18',
    '% result: 0,10 - 3,13 - 6,16 - 9,19 - 2,12 - 5,15 - 8,18 - 1,11 - 4,14 - 7,17',
    'function t = mb_slicetiming(s)',
    't = s.MosaicRefAcqTimes;',
    'delay = asc_header(s, \'lDelayTimeInTR\')/1000; % in ms now',
    'if isempty(delay), delay = 0; end',
    'TA = s.RepetitionTime - delay; % effective TR',
    '',
    'if max(t)-min(t)>TA && isfield(s, \'LastFile\') % try last volume first',
    '    dict = dicm_dict(s.Manufacturer, \'MosaicRefAcqTimes\');',
    '    s2 = dicm_hdr(s.LastFile.Filename, dict);',
    '    t = s2.MosaicRefAcqTimes; % use the last file',
    'end',
    '',
    '% No SL acc factor. Not even multiband flag. This is UGLY',
    'nSL = double(s.LocationsInAcquisition);',
    'mb = ceil((max(t) - min(t)) / TA); % based on the wrong timing pattern',
    'nShot = nSL / mb;',
    'if mb==1 || mod(nShot,1)>0, return; end % good t, not MB, or wrong acc factor',
    '',
    'ucMode = asc_header(s, \'sSliceArray.ucMode\'); % 1/2/4: Asc/Desc/Inter',
    'if isempty(ucMode), return; end',
    't = linspace(0, TA, nShot+1)\'; t(end) = [];',
    't = repmat(t, mb, 1); % ascending',
    'if ucMode == 2 % descending',
    '    t = t(nSL:-1:1);',
    'elseif ucMode == 4 % interleaved',
    '    if mod(nShot,2) % odd number of shots',
    '        inc = 2;',
    '    else',
    '        inc = nShot / 2 - 1;',
    '        if mod(inc,2) == 0, inc = inc - 1; end',
    '        errorLog([ProtocolName(s) \': multiband interleaved order, even\' ...',
    '            \' number of shots.\\nThe SliceTiming information may be wrong.\']);',
    '    end',
    '    ',
    '% % This gives the result in the PDF doc for example above',
    '%     ind = nan(nShot, 1); j = 0; i = 1; k = 0;',
    '%     while 1',
    '%         ind(i) = j + k*inc;',
    '%         if ind(i)+(mb-1)*nShot > nSL-1',
    '%             j = j + 1; k = 0;',
    '%         else',
    '%             i = i + 1; k = k + 1;',
    '%         end',
    '%         if i>nShot, break; end',
    '%     end',
    '    ',
    '    ind = mod((0:nShot-1)*inc, nShot)\'; % my guess based on chris data',
    '    ',
    '    if nShot==6, ind = [0 2 4 1 5 3]\'; end % special case',
    '    ind = bsxfun(@plus, ind*ones(1,mb), (0:mb-1)*nShot);',
    '    ind = ind + 1;',
    '',
    '    t = zeros(nSL, 1);',
    '    for i = 1:nShot',
    '        t(ind(i,:)) = (i-1) / nShot;',
    '    end',
    '    t = t * TA;',
    'end',
    'if csa_header(s, \'ProtocolSliceNumber\')>0, t = t(nSL:-1:1); end % rev-num'
  )

  dicm_dict <- c(
    'function dict = dicm_dict(vendor, flds)',
    '% Return dicom dictionary for specified vendor.',
    '% ',
    '% dict = dicm_hdr(vendor, dicmFields);',
    '% ',
    '% The vendor is used to assign those vendor-specific private tags for SIEMENS,',
    '% GE and Philips. Other vendors can be added easily into the file.',
    '% ',
    '% If only partial dictionary is needed, the struct fields can be used as',
    '% the 2nd input.',
    '% ',
    '% See also DICM_HDR, DICM2NII, DICM_IMG',
    '',
    '% History (yymmdd):',
    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com)',
    '% 131105 Make DTI parameter names more consistent across vendors.',
    '% 141021 Store requested fields, so set dict when switching vendors.',
    '% 141024 Use LocationsInAcquisition as nSL for all vendors.',
    '% 141030 Make ScanningSequence & SequenceVariant consistent for vendors.',
    '% 150114 Add two more CSA header duplicate tags, and more command tags.',
    '',
    'if nargin<1, vendor = \'SIEMENS\'; end',
    'dict.vendor = vendor;',
    '% Shortened items common across vendors from Matlab dicom-dict.txt',
    '%    group element vr  name',
    'C = {   ',
    '    \'0000\' \'0002\' \'UI\' \'AffectedSOPClassUID\'',
    '    \'0000\' \'0100\' \'US\' \'CommandField\'',
    '    \'0000\' \'0110\' \'US\' \'MessageID\'',
    '    \'0000\' \'0700\' \'US\' \'Priority\'',
    '    \'0000\' \'0800\' \'US\' \'DataSetType\'',
    '    \'0000\' \'1000\' \'UI\' \'AffectedSOPInstanceUID\'',
    '    \'0002\' \'0001\' \'OB\' \'FileMetaInformationVersion\'',
    '    \'0002\' \'0002\' \'UI\' \'MediaStorageSOPClassUID\'',
    '    \'0002\' \'0003\' \'UI\' \'MediaStorageSOPInstanceUID\'',
    '    \'0002\' \'0010\' \'UI\' \'TransferSyntaxUID\'',
    '    \'0002\' \'0012\' \'UI\' \'ImplementationClassUID\'',
    '    \'0002\' \'0013\' \'SH\' \'ImplementationVersionName\'',
    '    \'0002\' \'0016\' \'AE\' \'SourceApplicationEntityTitle\'',
    '    \'0002\' \'0100\' \'UI\' \'PrivateInformationCreatorUID\'',
    '    \'0008\' \'0005\' \'CS\' \'SpecificCharacterSet\'',
    '    \'0008\' \'0008\' \'CS\' \'ImageType\'',
    '    \'0008\' \'0012\' \'DA\' \'InstanceCreationDate\'',
    '    \'0008\' \'0013\' \'TM\' \'InstanceCreationTime\'',
    '    \'0008\' \'0014\' \'UI\' \'InstanceCreatorUID\'',
    '    \'0008\' \'0016\' \'UI\' \'SOPClassUID\'',
    '    \'0008\' \'0018\' \'UI\' \'SOPInstanceUID\'',
    '    \'0008\' \'0020\' \'DA\' \'StudyDate\'',
    '    \'0008\' \'0021\' \'DA\' \'SeriesDate\'',
    '    \'0008\' \'0022\' \'DA\' \'AcquisitionDate\'',
    '    \'0008\' \'0023\' \'DA\' \'ContentDate\'',
    '    \'0008\' \'002A\' \'DT\' \'AcquisitionDateTime\'',
    '    \'0008\' \'0030\' \'TM\' \'StudyTime\'',
    '    \'0008\' \'0031\' \'TM\' \'SeriesTime\'',
    '    \'0008\' \'0032\' \'TM\' \'AcquisitionTime\'',
    '    \'0008\' \'0033\' \'TM\' \'ContentTime\'',
    '    \'0008\' \'0050\' \'SH\' \'AccessionNumber\'',
    '    \'0008\' \'0060\' \'CS\' \'Modality\'',
    '    \'0008\' \'0064\' \'CS\' \'ConversionType\'',
    '    \'0008\' \'0070\' \'LO\' \'Manufacturer\'',
    '    \'0008\' \'0080\' \'LO\' \'InstitutionName\'',
    '    \'0008\' \'0081\' \'ST\' \'InstitutionAddress\'',
    '    \'0008\' \'0090\' \'PN\' \'ReferringPhysicianName\'',
    '    \'0008\' \'0100\' \'SH\' \'CodeValue\'',
    '    \'0008\' \'0102\' \'SH\' \'CodingSchemeDesignator\'',
    '    \'0008\' \'0104\' \'LO\' \'CodeMeaning\'',
    '    \'0008\' \'010B\' \'CS\' \'ContextGroupExtensionFlag\'',
    '    \'0008\' \'0201\' \'SH\' \'TimezoneOffsetFromUTC\'',
    '    \'0008\' \'1010\' \'SH\' \'StationName\'',
    '    \'0008\' \'1030\' \'LO\' \'StudyDescription\'',
    '    \'0008\' \'1032\' \'SQ\' \'ProcedureCodeSequence\'',
    '    \'0008\' \'103E\' \'LO\' \'SeriesDescription\'',
    '    \'0008\' \'1040\' \'LO\' \'InstitutionalDepartmentName\'',
    '    \'0008\' \'1048\' \'PN\' \'PhysicianOfRecord\'',
    '    \'0008\' \'1050\' \'PN\' \'PerformingPhysicianName\'',
    '    \'0008\' \'1060\' \'PN\' \'PhysicianReadingStudy\'',
    '    \'0008\' \'1070\' \'PN\' \'OperatorName\'',
    '    \'0008\' \'1080\' \'LO\' \'AdmittingDiagnosesDescription\'',
    '    \'0008\' \'1090\' \'LO\' \'ManufacturerModelName\'',
    '    \'0008\' \'1110\' \'SQ\' \'ReferencedStudySequence\'',
    '    \'0008\' \'1111\' \'SQ\' \'ReferencedPerformedProcedureStepSequence\'',
    '    \'0008\' \'1115\' \'SQ\' \'ReferencedSeriesSequence\'',
    '    \'0008\' \'1120\' \'SQ\' \'ReferencedPatientSequence\'',
    '    \'0008\' \'1140\' \'SQ\' \'ReferencedImageSequence\'',
    '    \'0008\' \'1150\' \'UI\' \'ReferencedSOPClassUID\'',
    '    \'0008\' \'1155\' \'UI\' \'ReferencedSOPInstanceUID\'',
    '    \'0008\' \'1160\' \'IS\' \'ReferencedFrameNumber\'',
    '    \'0008\' \'1199\' \'SQ\' \'ReferencedSOPSequence\'',
    '    \'0008\' \'2112\' \'SQ\' \'SourceImageSequence\'',
    '    \'0008\' \'2218\' \'SQ\' \'AnatomicRegionSequence\'',
    '    \'0008\' \'9007\' \'CS\' \'FrameType\'',
    '    \'0008\' \'9092\' \'SQ\' \'ReferencedImageEvidenceSequence\'',
    '    \'0008\' \'9121\' \'SQ\' \'ReferencedRawDataSequence\'',
    '    \'0008\' \'9123\' \'UI\' \'CreatorVersionUID\'',
    '    \'0008\' \'9205\' \'CS\' \'PixelPresentation\'',
    '    \'0008\' \'9206\' \'CS\' \'VolumetricProperties\'',
    '    \'0008\' \'9207\' \'CS\' \'VolumeBasedCalculationTechnique\'',
    '    \'0008\' \'9208\' \'CS\' \'ComplexImageComponent\'',
    '    \'0008\' \'9209\' \'CS\' \'AcquisitionContrast\'',
    '    \'0010\' \'0010\' \'PN\' \'PatientName\'',
    '    \'0010\' \'0020\' \'LO\' \'PatientID\'',
    '    \'0010\' \'0030\' \'DA\' \'PatientBirthDate\'',
    '    \'0010\' \'0040\' \'CS\' \'PatientSex\'',
    '    \'0010\' \'1000\' \'LO\' \'OtherPatientID\'',
    '    \'0010\' \'1010\' \'AS\' \'PatientAge\'',
    '    \'0010\' \'1020\' \'DS\' \'PatientSize\'',
    '    \'0010\' \'1030\' \'DS\' \'PatientWeight\'',
    '    \'0010\' \'1080\' \'LO\' \'MilitaryRank\'',
    '    \'0010\' \'21B0\' \'LT\' \'AdditionalPatientHistory\'',
    '    \'0010\' \'21C0\' \'US\' \'PregnancyStatus\'',
    '    \'0010\' \'4000\' \'LT\' \'PatientComments\'',
    '    \'0012\' \'0062\' \'CS\' \'PatientIdentityRemoved\'',
    '    \'0012\' \'0063\' \'LO\' \'DeidentificationMethod\'',
    '    \'0018\' \'0015\' \'CS\' \'BodyPartExamined\'',
    '    \'0018\' \'0020\' \'CS\' \'ScanningSequence\'',
    '    \'0018\' \'0021\' \'CS\' \'SequenceVariant\'',
    '    \'0018\' \'0022\' \'CS\' \'ScanOptions\'',
    '    \'0018\' \'0023\' \'CS\' \'MRAcquisitionType\'',
    '    \'0018\' \'0024\' \'SH\' \'SequenceName\'',
    '    \'0018\' \'0025\' \'CS\' \'AngioFlag\'',
    '    \'0018\' \'0050\' \'DS\' \'SliceThickness\'',
    '    \'0018\' \'0060\' \'DS\' \'KVP\'',
    '    \'0018\' \'0080\' \'DS\' \'RepetitionTime\'',
    '    \'0018\' \'0081\' \'DS\' \'EchoTime\'',
    '    \'0018\' \'0082\' \'DS\' \'InversionTime\'',
    '    \'0018\' \'0083\' \'DS\' \'NumberOfAverages\'',
    '    \'0018\' \'0084\' \'DS\' \'ImagingFrequency\'',
    '    \'0018\' \'0085\' \'SH\' \'ImagedNucleus\'',
    '    \'0018\' \'0086\' \'IS\' \'EchoNumber\'',
    '    \'0018\' \'0087\' \'DS\' \'MagneticFieldStrength\'',
    '    \'0018\' \'0088\' \'DS\' \'SpacingBetweenSlices\'',
    '    \'0018\' \'0089\' \'IS\' \'NumberOfPhaseEncodingSteps\'',
    '    \'0018\' \'0090\' \'DS\' \'DataCollectionDiameter\'',
    '    \'0018\' \'0091\' \'IS\' \'EchoTrainLength\'',
    '    \'0018\' \'0093\' \'DS\' \'PercentSampling\'',
    '    \'0018\' \'0094\' \'DS\' \'PercentPhaseFieldOfView\'',
    '    \'0018\' \'0095\' \'DS\' \'PixelBandwidth\'',
    '    \'0018\' \'1000\' \'LO\' \'DeviceSerialNumber\'',
    '    \'0018\' \'1012\' \'DA\' \'DateOfSecondaryCapture\'',
    '    \'0018\' \'1014\' \'TM\' \'TimeOfSecondaryCapture\'',
    '    \'0018\' \'1020\' \'LO\' \'SoftwareVersion\'',
    '    \'0018\' \'1030\' \'LO\' \'ProtocolName\'',
    '    \'0018\' \'1050\' \'DS\' \'SpatialResolution\'',
    '    \'0018\' \'1060\' \'DS\' \'TriggerTime\'',
    '    \'0018\' \'1063\' \'DS\' \'FrameTime\'',
    '    \'0018\' \'1088\' \'IS\' \'HeartRate\'',
    '    \'0018\' \'1090\' \'IS\' \'CardiacNumberOfImages\'',
    '    \'0018\' \'1094\' \'IS\' \'TriggerWindow\'',
    '    \'0018\' \'1100\' \'DS\' \'ReconstructionDiameter\'',
    '    \'0018\' \'1110\' \'DS\' \'DistanceSourceToDetector\'',
    '    \'0018\' \'1111\' \'DS\' \'DistanceSourceToPatient\'',
    '    \'0018\' \'1120\' \'DS\' \'GantryDetectorTilt\'',
    '    \'0018\' \'1130\' \'DS\' \'TableHeight\'',
    '    \'0018\' \'1140\' \'CS\' \'RotationDirection\'',
    '    \'0018\' \'1150\' \'IS\' \'ExposureTime\'',
    '    \'0018\' \'1151\' \'IS\' \'XrayTubeCurrent\'',
    '    \'0018\' \'1152\' \'IS\' \'Exposure\'',
    '    \'0018\' \'1160\' \'SH\' \'FilterType\'',
    '    \'0018\' \'1170\' \'IS\' \'GeneratorPower\'',
    '    \'0018\' \'1190\' \'DS\' \'FocalSpot\'',
    '    \'0018\' \'1210\' \'SH\' \'ConvolutionKernel\'',
    '    \'0018\' \'1200\' \'DA\' \'DateOfLastCalibration\'',
    '    \'0018\' \'1201\' \'TM\' \'TimeOfLastCalibration\'',
    '    \'0018\' \'1250\' \'SH\' \'ReceiveCoilName\'',
    '    \'0018\' \'1251\' \'SH\' \'TransmitCoilName\'   ',
    '    \'0018\' \'1310\' \'US\' \'AcquisitionMatrix\'',
    '    \'0018\' \'1312\' \'CS\' \'InPlanePhaseEncodingDirection\'',
    '    \'0018\' \'1314\' \'DS\' \'FlipAngle\'',
    '    \'0018\' \'1315\' \'CS\' \'VariableFlipAngleFlag\'',
    '    \'0018\' \'1316\' \'DS\' \'SAR\'',
    '    \'0018\' \'1318\' \'DS\' \'dBdt\'',
    '    \'0018\' \'1081\' \'IS\' \'LowRRValue\'',
    '    \'0018\' \'1082\' \'IS\' \'HighRRValue\'',
    '    \'0018\' \'1083\' \'IS\' \'IntervalsAcquired\'',
    '    \'0018\' \'1084\' \'IS\' \'IntervalsRejected\'',
    '    \'0018\' \'2003\' \'DS\' \'FramePrimaryAngleVector\'',
    '    \'0018\' \'2004\' \'DS\' \'FrameSecondaryAngleVector\'',
    '    \'0018\' \'2005\' \'DS\' \'SliceLocationVector\'',
    '    \'0018\' \'5100\' \'CS\' \'PatientPosition\'',
    '    \'0018\' \'9004\' \'CS\' \'ContentQualification\'',
    '    \'0018\' \'9005\' \'SH\' \'PulseSequenceName\'',
    '    \'0018\' \'9006\' \'SQ\' \'MRImagingModifierSequence\'',
    '    \'0018\' \'9008\' \'CS\' \'EchoPulseSequence\'',
    '    \'0018\' \'9009\' \'CS\' \'InversionRecovery\'',
    '    \'0018\' \'9010\' \'CS\' \'FlowCompensation\'',
    '    \'0018\' \'9011\' \'CS\' \'MultipleSpinEcho\'',
    '    \'0018\' \'9012\' \'CS\' \'MultiplanarExcitation\'',
    '    \'0018\' \'9014\' \'CS\' \'PhaseContrast\'',
    '    \'0018\' \'9015\' \'CS\' \'TimeOfFlightContrast\'',
    '    \'0018\' \'9016\' \'CS\' \'Spoiling\'',
    '    \'0018\' \'9017\' \'CS\' \'SteadyStatePulseSequence\'',
    '    \'0018\' \'9018\' \'CS\' \'EchoPlanarPulseSequence\'',
    '    \'0018\' \'9019\' \'FD\' \'TagAngleFirstAxis\'',
    '    \'0018\' \'9020\' \'CS\' \'MagnetizationTransfer\'',
    '    \'0018\' \'9021\' \'CS\' \'T2Preparation\'',
    '    \'0018\' \'9022\' \'CS\' \'BloodSignalNulling\'',
    '    \'0018\' \'9024\' \'CS\' \'SaturationRecovery\'',
    '    \'0018\' \'9025\' \'CS\' \'SpectrallySelectedSuppression\'',
    '    \'0018\' \'9026\' \'CS\' \'SpectrallySelectedExcitation\'',
    '    \'0018\' \'9027\' \'CS\' \'SpatialPresaturation\'',
    '    \'0018\' \'9028\' \'CS\' \'Tagging\'',
    '    \'0018\' \'9029\' \'CS\' \'OversamplingPhase\'',
    '    \'0018\' \'9030\' \'FD\' \'TagSpacingFirstDimension\'',
    '    \'0018\' \'9032\' \'CS\' \'GeometryOfKSpaceTraversal\'',
    '    \'0018\' \'9033\' \'CS\' \'SegmentedKSpaceTraversal\'',
    '    \'0018\' \'9034\' \'CS\' \'RectilinearPhaseEncodeReordering\'',
    '    \'0018\' \'9035\' \'FD\' \'TagThickness\'',
    '    \'0018\' \'9036\' \'CS\' \'PartialFourierDirection\'',
    '    \'0018\' \'9037\' \'CS\' \'CardiacSynchronizationTechnique\'',
    '    \'0018\' \'9042\' \'SQ\' \'MRReceiveCoilSequence\'',
    '    \'0018\' \'9043\' \'CS\' \'ReceiveCoilType\'',
    '    \'0018\' \'9044\' \'CS\' \'QuadratureReceiveCoil\'',
    '    \'0018\' \'9045\' \'SQ\' \'MultiCoilDefinitionSequence\'',
    '    \'0018\' \'9047\' \'SH\' \'MultiCoilElementName\'',
    '    \'0018\' \'9048\' \'CS\' \'MultiCoilElementUsed\'',
    '    \'0018\' \'9049\' \'SQ\' \'MRTransmitCoilSequence\'',
    '    \'0018\' \'9051\' \'CS\' \'TransmitCoilType\'',
    '    \'0018\' \'9052\' \'FD\' \'SpectralWidth\'',
    '    \'0018\' \'9053\' \'FD\' \'ChemicalShiftReference\'',
    '    \'0018\' \'9058\' \'US\' \'MRAcquisitionFrequencyEncodingSteps\'',
    '    \'0018\' \'9059\' \'CS\' \'Decoupling\'',
    '    \'0018\' \'9064\' \'CS\' \'KSpaceFiltering\'',
    '    \'0018\' \'9069\' \'FD\' \'ParallelReductionFactorInPlane\'',
    '    \'0018\' \'9073\' \'FD\' \'AcquisitionDuration\'',
    '    \'0018\' \'9074\' \'DT\' \'FrameAcquisitionDatetime\'',
    '    \'0018\' \'9075\' \'CS\' \'DiffusionDirectionality\'',
    '    \'0018\' \'9076\' \'SQ\' \'DiffusionGradientDirectionSequence\'',
    '    \'0018\' \'9077\' \'CS\' \'ParallelAcquisition\'',
    '    \'0018\' \'9078\' \'CS\' \'ParallelAcquisitionTechnique\'',
    '    \'0018\' \'9079\' \'FD\' \'InversionTimes\'',
    '    \'0018\' \'9080\' \'ST\' \'MetaboliteMapDescription\'',
    '    \'0018\' \'9081\' \'CS\' \'PartialFourier\'',
    '    \'0018\' \'9082\' \'FD\' \'EffectiveEchoTime\'',
    '    \'0018\' \'9087\' \'FD\' \'B_value\' % \'DiffusionBValue\'',
    '    \'0018\' \'9089\' \'FD\' \'DiffusionGradientDirection\' % DiffusionGradientOrientation',
    '    \'0018\' \'9090\' \'FD\' \'VelocityEncodingDirection\'',
    '    \'0018\' \'9091\' \'FD\' \'VelocityEncodingMinimumValue\'',
    '    \'0018\' \'9093\' \'US\' \'NumberOfKSpaceTrajectories\'',
    '    \'0018\' \'9094\' \'CS\' \'CoverageOfKSpace\'',
    '    \'0018\' \'9098\' \'FD\' \'TransmitterFrequency\'',
    '    \'0018\' \'9100\' \'CS\' \'ResonantNucleus\'',
    '    \'0018\' \'9101\' \'CS\' \'FrequencyCorrection\'',
    '    \'0018\' \'9103\' \'SQ\' \'MRSpectroscopyFOVGeometrySequence\'',
    '    \'0018\' \'9112\' \'SQ\' \'MRTimingAndRelatedParametersSequence\'',
    '    \'0018\' \'9114\' \'SQ\' \'MREchoSequence\'',
    '    \'0018\' \'9115\' \'SQ\' \'MRModifierSequence\'',
    '    \'0018\' \'9117\' \'SQ\' \'MRDiffusionSequence\'',
    '    \'0018\' \'9119\' \'SQ\' \'MRAveragesSequence\'',
    '    \'0018\' \'9125\' \'SQ\' \'MRFOVGeometrySequence\'',
    '    \'0018\' \'9147\' \'CS\' \'DiffusionAnisotropyType\'',
    '    \'0018\' \'9151\' \'DT\' \'FrameReferenceDatetime\'',
    '    \'0018\' \'9152\' \'SQ\' \'MRMetaboliteMapSequence\'',
    '    \'0018\' \'9155\' \'FD\' \'ParallelReductionFactorOutOfPlane\'',
    '    \'0018\' \'9168\' \'FD\' \'ParallelReductionFactorSecondInPlane\'',
    '    \'0018\' \'9170\' \'CS\' \'RespiratoryMotionCompensationTechnique\'',
    '    \'0018\' \'9171\' \'CS\' \'RespiratorySignalSource\'',
    '    \'0018\' \'9172\' \'CS\' \'BulkMotionCompensationTechnique\'',
    '    \'0018\' \'9174\' \'CS\' \'ApplicableSafetyStandardAgency\'',
    '    \'0018\' \'9176\' \'SQ\' \'OperatingModeSequence\'',
    '    \'0018\' \'9177\' \'CS\' \'OperatingModeType\'',
    '    \'0018\' \'9178\' \'CS\' \'OperatingMode\'',
    '    \'0018\' \'9179\' \'CS\' \'SpecificAbsorptionRateDefinition\'',
    '    \'0018\' \'9180\' \'CS\' \'GradientOutputType\'',
    '    \'0018\' \'9181\' \'FD\' \'SpecificAbsorptionRateValue\'',
    '    \'0018\' \'9182\' \'FD\' \'GradientOutput\'',
    '    \'0018\' \'9183\' \'CS\' \'FlowCompensationDirection\'',
    '    \'0018\' \'9199\' \'CS\' \'WaterReferencedPhaseCorrection\'',
    '    \'0018\' \'9220\' \'FD\' \'FrameAcquisitionDuration\'',
    '    \'0018\' \'9226\' \'SQ\' \'MRImageFrameTypeSequence\'',
    '    \'0018\' \'9231\' \'US\' \'MRAcquisitionPhaseEncodingStepsInPlane\'',
    '    \'0018\' \'9232\' \'US\' \'MRAcquisitionPhaseEncodingStepsOutOfPlane\'',
    '    \'0018\' \'9239\' \'SQ\' \'SpecificAbsorptionRateSequence\'',
    '    \'0018\' \'9240\' \'US\' \'RFEchoTrainLength\'',
    '    \'0018\' \'9241\' \'US\' \'GradientEchoTrainLength\'',
    '    \'0020\' \'000D\' \'UI\' \'StudyInstanceUID\'',
    '    \'0020\' \'000E\' \'UI\' \'SeriesInstanceUID\'',
    '    \'0020\' \'0010\' \'SH\' \'StudyID\'',
    '    \'0020\' \'0011\' \'IS\' \'SeriesNumber\'',
    '    \'0020\' \'0012\' \'IS\' \'AcquisitionNumber\'',
    '    \'0020\' \'0013\' \'IS\' \'InstanceNumber\'',
    '    \'0020\' \'0020\' \'CS\' \'PatientOrientation\'',
    '    \'0020\' \'0032\' \'DS\' \'ImagePositionPatient\'',
    '    \'0020\' \'0037\' \'DS\' \'ImageOrientationPatient\'',
    '    \'0020\' \'0052\' \'UI\' \'FrameOfReferenceUID\'',
    '    \'0020\' \'0100\' \'IS\' \'TemporalPositionIdentifier\'',
    '    \'0020\' \'0110\' \'DS\' \'TemporalResolution\'',
    '    \'0020\' \'0105\' \'IS\' \'NumberOfTemporalPositions\'',
    '    \'0020\' \'1000\' \'IS\' \'SeriesInStudy\'',
    '    \'0020\' \'1001\' \'IS\' \'AcquisitionsInSeries\'',
    '    \'0020\' \'1002\' \'IS\' \'ImagesInAcquisition\'',
    '    \'0020\' \'1003\' \'IS\' \'ImagesInSeries\'',
    '    \'0020\' \'1004\' \'IS\' \'AcquisitionsInStudy\'',
    '    \'0020\' \'1005\' \'IS\' \'ImagesInStudy\'',
    '    \'0020\' \'1040\' \'LO\' \'PositionReferenceIndicator\'',
    '    \'0020\' \'1041\' \'DS\' \'SliceLocation\'',
    '    \'0020\' \'4000\' \'LT\' \'ImageComments\'',
    '    \'0020\' \'9056\' \'SH\' \'StackID\'',
    '    \'0020\' \'9057\' \'UL\' \'InStackPositionNumber\'',
    '    \'0020\' \'9071\' \'SQ\' \'FrameAnatomySequence\'',
    '    \'0020\' \'9072\' \'CS\' \'FrameLaterality\'',
    '    \'0020\' \'9111\' \'SQ\' \'FrameContentSequence\'',
    '    \'0020\' \'9113\' \'SQ\' \'PlanePositionSequence\'',
    '    \'0020\' \'9116\' \'SQ\' \'PlaneOrientationSequence\'',
    '    \'0020\' \'9128\' \'UL\' \'TemporalPositionIndex\'',
    '    \'0020\' \'9156\' \'US\' \'FrameAcquisitionNumber\'',
    '    \'0020\' \'9157\' \'UL\' \'DimensionIndexValues\'',
    '    \'0020\' \'9164\' \'UI\' \'DimensionOrganizationUID\'',
    '    \'0020\' \'9165\' \'AT\' \'DimensionIndexPointer\'',
    '    \'0020\' \'9167\' \'AT\' \'FunctionalGroupPointer\'',
    '    \'0020\' \'9221\' \'SQ\' \'DimensionOrganizationSequence\'',
    '    \'0020\' \'9222\' \'SQ\' \'DimensionIndexSequence\'',
    '    \'0020\' \'9254\' \'FD\' \'RespiratoryIntervalTime\'',
    '    \'0020\' \'9255\' \'FD\' \'RespiratoryTriggerDelayTime\'',
    '    \'0020\' \'9421\' \'LO\' \'DimensionDescriptionLabel\'',
    '    \'0028\' \'0002\' \'US\' \'SamplesPerPixel\'',
    '    \'0028\' \'0004\' \'CS\' \'PhotometricInterpretation\'',
    '    \'0028\' \'0006\' \'US\' \'PlanarConfiguration\'',
    '    \'0028\' \'0008\' \'IS\' \'NumberOfFrames\'',
    '    \'0028\' \'0009\' \'AT\' \'FrameIncrementPointer\'',
    '    \'0028\' \'000A\' \'AT\' \'FrameDimensionPointer\'',
    '    \'0028\' \'0010\' \'US\' \'Rows\'',
    '    \'0028\' \'0011\' \'US\' \'Columns\'',
    '    \'0028\' \'0030\' \'DS\' \'PixelSpacing\'',
    '    \'0028\' \'0034\' \'IS\' \'PixelAspectRatio\'',
    '    \'0028\' \'0100\' \'US\' \'BitsAllocated\'',
    '    \'0028\' \'0101\' \'US\' \'BitsStored\'',
    '    \'0028\' \'0102\' \'US\' \'HighBit\'',
    '    \'0028\' \'0103\' \'US\' \'PixelRepresentation\'',
    '    \'0028\' \'0104\' \'US\' \'SmallestValidPixelValue\'',
    '    \'0028\' \'0105\' \'US\' \'LargestValidPixelValue\'',
    '    \'0028\' \'0106\' \'US\' \'SmallestImagePixelValue\'',
    '    \'0028\' \'0107\' \'US\' \'LargestImagePixelValue\'',
    '    \'0028\' \'0120\' \'SS\' \'PixelPaddingValue\'',
    '    \'0028\' \'0301\' \'CS\' \'BurnedInAnnotation\'',
    '    \'0028\' \'1050\' \'DS\' \'WindowCenter\'',
    '    \'0028\' \'1051\' \'DS\' \'WindowWidth\'',
    '    \'0028\' \'1052\' \'DS\' \'RescaleIntercept\'',
    '    \'0028\' \'1053\' \'DS\' \'RescaleSlope\'',
    '    \'0028\' \'1054\' \'LO\' \'RescaleType\'',
    '    \'0028\' \'1055\' \'LO\' \'WindowCenterWidthExplanation\'',
    '    \'0028\' \'1080\' \'LT\' \'GrayScale\'',
    '    \'0028\' \'1101\' \'US\' \'RedPaletteColorLookupTableDescriptor\'',
    '    \'0028\' \'1102\' \'US\' \'GreenPaletteColorLookupTableDescriptor\'',
    '    \'0028\' \'1103\' \'US\' \'BluePaletteColorLookupTableDescriptor\'',
    '    \'0028\' \'1201\' \'OW\' \'RedPaletteColorLookupTableData\'',
    '    \'0028\' \'1202\' \'OW\' \'GreenPaletteColorLookupTableData\'',
    '    \'0028\' \'1203\' \'OW\' \'BluePaletteColorLookupTableData\'',
    '    \'0028\' \'2110\' \'CS\' \'LossyImageCompression\'',
    '    \'0028\' \'2112\' \'DS\' \'LossyImageCompressionRatio\'',
    '    \'0028\' \'2114\' \'CS\' \'LossyImageCompressionMethod\'',
    '    \'0028\' \'3003\' \'LO\' \'LUTExplanation\'',
    '    \'0028\' \'9001\' \'UL\' \'DataPointRows\'',
    '    \'0028\' \'9002\' \'UL\' \'DataPointColumns\'',
    '    \'0028\' \'9110\' \'SQ\' \'PixelMeasuresSequence\'',
    '    \'0028\' \'9132\' \'SQ\' \'FrameVOILUTSequence\'',
    '    \'0028\' \'9145\' \'SQ\' \'PixelValueTransformationSequence\'',
    '    \'0032\' \'000A\' \'CS\' \'StudyStatusID\'',
    '    \'0032\' \'000C\' \'CS\' \'StudyPriorityID\'',
    '    \'0032\' \'1030\' \'LO\' \'ReasonForStudy\'',
    '    \'0032\' \'1032\' \'PN\' \'RequestingPhysician\'',
    '    \'0032\' \'1033\' \'LO\' \'RequestingService\'',
    '    \'0032\' \'1060\' \'LO\' \'RequestedProcedureDescription\'',
    '    \'0032\' \'1064\' \'SQ\' \'RequestedProcedureCodeSequence\'',
    '    \'0032\' \'4000\' \'LT\' \'StudyComments\'',
    '    \'0038\' \'0300\' \'LO\' \'CurrentPatientLocation\'',
    '    \'0040\' \'0006\' \'PN\' \'ScheduledPerformingPhysicianName\'',
    '    \'0040\' \'0007\' \'LO\' \'ScheduledProcedureStepDescription\'',
    '    \'0040\' \'0008\' \'SQ\' \'ScheduledProtocolCodeSequence\'',
    '    \'0040\' \'0009\' \'SH\' \'ScheduledProcedureStepID\'',
    '    \'0040\' \'0241\' \'AE\' \'PerformedStationAETitle\'',
    '    \'0040\' \'0242\' \'SH\' \'PerformedStationName\'',
    '    \'0040\' \'0243\' \'SH\' \'PerformedLocation\'',
    '    \'0040\' \'0244\' \'DA\' \'PerformedProcedureStepStartDate\'',
    '    \'0040\' \'0245\' \'TM\' \'PerformedProcedureStepStartTime\'',
    '    \'0040\' \'0250\' \'DA\' \'PerformedProcedureStepEndDate\'',
    '    \'0040\' \'0251\' \'TM\' \'PerformedProcedureStepEndTime\'',
    '    \'0040\' \'0252\' \'CS\' \'PerformedProcedureStepStatus\'',
    '    \'0040\' \'0253\' \'SH\' \'PerformedProcedureStepID\'',
    '    \'0040\' \'0254\' \'LO\' \'PerformedProcedureStepDescription\'',
    '    \'0040\' \'0260\' \'SQ\' \'PerformedProtocolCodeSequence\'',
    '    \'0040\' \'0275\' \'SQ\' \'RequestAttributesSequence\'',
    '    \'0040\' \'0280\' \'ST\' \'CommentsOnPerformedProcedureStep\'',
    '    \'0040\' \'0321\' \'SQ\' \'FilmConsumptionSequence\'',
    '    \'0040\' \'08EA\' \'SQ\' \'MeasurementUnitsCodeSequence\'',
    '    \'0040\' \'1001\' \'SH\' \'RequestedProcedureID\'',
    '    \'0040\' \'1400\' \'LT\' \'RequestedProcedureComments\'',
    '    \'0040\' \'2400\' \'LT\' \'ImagingServiceRequestComments\'',
    '    \'0040\' \'9096\' \'SQ\' \'RealWorldValueMappingSequence\'',
    '    \'0040\' \'9210\' \'SH\' \'LUTLabel\'',
    '    \'0040\' \'9211\' \'SS\' \'RealWorldValueLastValueMapped\'',
    '    \'0040\' \'9216\' \'SS\' \'RealWorldValueFirstValueMapped\'',
    '    \'0040\' \'9224\' \'FD\' \'RealWorldValueIntercept\'',
    '    \'0040\' \'9225\' \'FD\' \'RealWorldValueSlope\'',
    '    \'0040\' \'A170\' \'SQ\' \'PurposeOfReferenceCodeSequence\'',
    '    \'0050\' \'0004\' \'CS\' \'CalibrationImage\'',
    '    \'0050\' \'0010\' \'SQ\' \'DeviceSequence\'',
    '    \'0050\' \'0014\' \'DS\' \'DeviceLength\'',
    '    \'0050\' \'0016\' \'DS\' \'DeviceDiameter\'',
    '    \'0050\' \'0017\' \'CS\' \'DeviceDiameterUnits\'',
    '    \'0050\' \'0018\' \'DS\' \'DeviceVolume\'',
    '    \'0050\' \'0019\' \'DS\' \'InterMarkerDistance\'',
    '    \'0050\' \'0020\' \'LO\' \'DeviceDescription\'',
    '    \'0088\' \'0140\' \'UI\' \'StorageMediaFileSetUID\'',
    '    \'0088\' \'0200\' \'SQ\' \'IconImageSequence\'',
    '    \'5200\' \'9229\' \'SQ\' \'SharedFunctionalGroupsSequence\'',
    '    \'5200\' \'9230\' \'SQ\' \'PerFrameFunctionalGroupsSequence\'',
    '    \'7FE0\' \'0010\' \'OW\' \'PixelData\' };',
    '',
    '% Following add vendor specific tags',
    'if strncmpi(vendor, \'SIEMENS\', 7)',
    '    C = [C; {',
    '    \'0019\' \'1008\' \'CS\' \'Private_0019_10xxType\'',
    '    \'0019\' \'1009\' \'LO\' \'Private_0019_10xxVersion\'',
    '    \'0019\' \'100A\' \'US\' \'LocationsInAcquisition\' % \'NumberOfImagesInMosaic\'',
    '    \'0019\' \'100B\' \'DS\' \'SliceMeasurementDuration\'',
    '    \'0019\' \'100C\' \'IS\' \'B_value\'',
    '    \'0019\' \'100D\' \'CS\' \'DiffusionDirectionality\'',
    '    \'0019\' \'100E\' \'FD\' \'DiffusionGradientDirection\'',
    '    \'0019\' \'100F\' \'SH\' \'GradientMode\'',
    '    \'0019\' \'1011\' \'SH\' \'FlowCompensation\'',
    '    \'0019\' \'1012\' \'SL\' \'TablePositionOrigin\'',
    '    \'0019\' \'1013\' \'SL\' \'ImaAbsTablePosition\'',
    '    \'0019\' \'1014\' \'IS\' \'ImaRelTablePosition\'',
    '    \'0019\' \'1015\' \'FD\' \'SlicePosition_PCS\'',
    '    \'0019\' \'1016\' \'DS\' \'TimeAfterStart\'',
    '    \'0019\' \'1017\' \'DS\' \'SliceResolution\'',
    '    \'0019\' \'1018\' \'IS\' \'RealDwellTime\'',
    '    \'0019\' \'1025\' \'DS\' \'RBMoCoTrans\'',
    '    \'0019\' \'1026\' \'DS\' \'RBMoCoRot\'',
    '    \'0019\' \'1027\' \'FD\' \'B_matrix\'',
    '    \'0019\' \'1028\' \'FD\' \'BandwidthPerPixelPhaseEncode\'',
    '    \'0019\' \'1029\' \'FD\' \'MosaicRefAcqTimes\'',
    '    \'0029\' \'1008\' \'CS\' \'CSAImageHeaderType\'',
    '    \'0029\' \'1009\' \'LO\' \'CSAImageHeaderVersion\'',
    '    \'0029\' \'1010\' \'OB\' \'CSAImageHeaderInfo\'',
    '    \'0029\' \'1018\' \'CS\' \'CSASeriesHeaderType\'',
    '    \'0029\' \'1019\' \'LO\' \'CSASeriesHeaderVersion\'',
    '    \'0029\' \'1020\' \'OB\' \'CSASeriesHeaderInfo\'',
    '    \'0029\' \'1110\' \'OB\' \'CSAImageHeaderInfo\'',
    '    \'0029\' \'1120\' \'OB\' \'CSASeriesHeaderInfo\'',
    '    \'0029\' \'1131\' \'LO\' \'PMTFInformation1\'',
    '    \'0029\' \'1132\' \'UL\' \'PMTFInformation2\'',
    '    \'0029\' \'1133\' \'UL\' \'PMTFInformation3\'',
    '    \'0029\' \'1134\' \'CS\' \'PMTFInformation4\'',
    '    \'0029\' \'1160\' \'LO\' \'SeriesWorkflowStatus\'',
    '    \'0029\' \'1260\' \'LO\' \'SeriesWorkflowStatus\'',
    '    \'0051\' \'1008\' \'CS\' \'Private_0051_10xx_Type\'',
    '    \'0051\' \'1009\' \'LO\' \'Private_0051_10xx_Version\'',
    '    \'0051\' \'100A\' \'LO\' \'TimeOfAcquisition\'',
    '    \'0051\' \'100B\' \'LO\' \'AcquisitionMatrixText\'',
    '    \'0051\' \'100C\' \'LO\' \'FieldOfView\'',
    '    \'0051\' \'100D\' \'SH\' \'SlicePositionText\'',
    '    \'0051\' \'100E\' \'LO\' \'ImageOrientation\'',
    '    \'0051\' \'100F\' \'LO\' \'CoilString\'',
    '    \'0051\' \'1011\' \'LO\' \'ImaPATModeText\'',
    '    \'0051\' \'1012\' \'SH\' \'TablePositionText\'',
    '    \'0051\' \'1013\' \'SH\' \'PositivePCSDirections\'',
    '    \'0051\' \'1015\' \'SH\' \'DataFilterText\' % not sure',
    '    \'0051\' \'1016\' \'LO\' \'ImageTypeText\'',
    '    \'0051\' \'1017\' \'SH\' \'SliceThicknessText\'',
    '    \'0051\' \'1019\' \'LO\' \'ScanOptionsText\'',
    '    }];',
    '',
    '',
    'elseif strncmpi(vendor, \'GE\', 2) ',
    '    C = [C; {',
    '    \'0009\' \'1001\' \'LO\' \'FullFidelity\'',
    '    \'0009\' \'1002\' \'SH\' \'SuiteId\'',
    '    \'0009\' \'1004\' \'SH\' \'ProductId\'',
    '    \'0009\' \'1027\' \'SL\' \'ImageActualDate\'',
    '    \'0009\' \'1030\' \'SH\' \'ServiceId\'',
    '    \'0009\' \'1031\' \'SH\' \'MobileLocationNumber\'',
    '    \'0009\' \'10E3\' \'UI\' \'EquipmentUID\'',
    '    \'0009\' \'10E7\' \'UL\' \'ExamRecordChecksum\'',
    '    \'0009\' \'10E9\' \'SL\' \'ActualSeriesDataTimeStamp\'',
    '    \'0019\' \'100F\' \'DS\' \'HorizFrameOfRef\'',
    '    \'0019\' \'1011\' \'SS\' \'SeriesContrast\'',
    '    \'0019\' \'1012\' \'SS\' \'LastPseq\'',
    '    \'0019\' \'1017\' \'SS\' \'SeriesPlane\'',
    '    \'0019\' \'1018\' \'LO\' \'FirstScanRas\'',
    '    \'0019\' \'1019\' \'DS\' \'FirstScanLocation\'',
    '    \'0019\' \'101A\' \'LO\' \'LastScanRas\'',
    '    \'0019\' \'101B\' \'DS\' \'LastScanLoc\'',
    '    \'0019\' \'101E\' \'DS\' \'DisplayFieldOfView\'',
    '    \'0019\' \'105A\' \'FL\' \'AcquisitionDuration\'',
    '    \'0019\' \'107D\' \'DS\' \'SecondEcho\'',
    '    \'0019\' \'107E\' \'SS\' \'NumberOfEchoes\'',
    '    \'0019\' \'107F\' \'DS\' \'TableDelta\'',
    '    \'0019\' \'1081\' \'SS\' \'Contiguous\'',
    '    \'0019\' \'1084\' \'DS\' \'PeakSAR\'',
    '    \'0019\' \'1085\' \'DS\' \'MonitorSAR\'',
    '    \'0019\' \'1087\' \'DS\' \'CardiacRepetitionTime\'',
    '    \'0019\' \'1088\' \'SS\' \'ImagesPerCardiacCycle\'',
    '    \'0019\' \'108A\' \'SS\' \'ActualReceiveGainAnalog\'',
    '    \'0019\' \'108B\' \'SS\' \'ActualReceiveGainDigital\'',
    '    \'0019\' \'108D\' \'DS\' \'DelayAfterTrigger\'',
    '    \'0019\' \'108F\' \'SS\' \'Swappf\'',
    '    \'0019\' \'1090\' \'SS\' \'PauseInterval\'',
    '    \'0019\' \'1091\' \'DS\' \'PauseTime\'',
    '    \'0019\' \'1092\' \'SL\' \'SliceOffsetOnFreqAxis\'',
    '    \'0019\' \'1093\' \'DS\' \'AutoPrescanCenterFrequency\'',
    '    \'0019\' \'1094\' \'SS\' \'AutoPrescanTransmitGain\'',
    '    \'0019\' \'1095\' \'SS\' \'AutoPrescanAnalogReceiverGain\'',
    '    \'0019\' \'1096\' \'SS\' \'AutoPrescanDigitalReceiverGain\'',
    '    \'0019\' \'1097\' \'SL\' \'BitmapdefiningCVs\'',
    '    \'0019\' \'1098\' \'SS\' \'CenterFreqMethod\'',
    '    \'0019\' \'109B\' \'SS\' \'PulseSequenceMode\'',
    '    \'0019\' \'109C\' \'LO\' \'PulseSequenceName\'',
    '    \'0019\' \'109D\' \'DT\' \'PulseSequenceDate\'',
    '    \'0019\' \'109E\' \'LO\' \'SequenceName\' % \'InternalPulseSequenceName\'',
    '    \'0019\' \'109F\' \'SS\' \'TransmittingCoilType\'',
    '    \'0019\' \'10A0\' \'SS\' \'SurfaceCoilType\'',
    '    \'0019\' \'10A1\' \'SS\' \'ExtremityCoilflag\'',
    '    \'0019\' \'10A2\' \'SL\' \'RawDataRunNumber\'',
    '    \'0019\' \'10A3\' \'UL\' \'CalibratedFieldStrength\'',
    '    \'0019\' \'10A4\' \'SS\' \'SATFatWaterBone\'',
    '    \'0019\' \'10A7\' \'DS\' \'UserData0\'',
    '    \'0019\' \'10A8\' \'DS\' \'UserData1\'',
    '    \'0019\' \'10A9\' \'DS\' \'UserData2\'',
    '    \'0019\' \'10AA\' \'DS\' \'UserData3\'',
    '    \'0019\' \'10AB\' \'DS\' \'UserData4\'',
    '    \'0019\' \'10AC\' \'DS\' \'UserData5\'',
    '    \'0019\' \'10AD\' \'DS\' \'UserData6\'',
    '    \'0019\' \'10AE\' \'DS\' \'UserData7\'',
    '    \'0019\' \'10AF\' \'DS\' \'UserData8\'',
    '    \'0019\' \'10B0\' \'DS\' \'UserData9\'',
    '    \'0019\' \'10B1\' \'DS\' \'UserData10\'',
    '    \'0019\' \'10B2\' \'DS\' \'UserData11\'',
    '    \'0019\' \'10B3\' \'DS\' \'UserData12\'',
    '    \'0019\' \'10B4\' \'DS\' \'UserData13\'',
    '    \'0019\' \'10B5\' \'DS\' \'UserData14\'',
    '    \'0019\' \'10B6\' \'DS\' \'UserData15\'',
    '    \'0019\' \'10B7\' \'DS\' \'UserData16\'',
    '    \'0019\' \'10B8\' \'DS\' \'UserData17\'',
    '    \'0019\' \'10B9\' \'DS\' \'UserData18\'',
    '    \'0019\' \'10BA\' \'DS\' \'UserData19\'',
    '    \'0019\' \'10BB\' \'DS\' \'DiffusionDirectionX\' %\'UserData20\'',
    '    \'0019\' \'10BC\' \'DS\' \'DiffusionDirectionY\' %\'UserData21\'',
    '    \'0019\' \'10BD\' \'DS\' \'DiffusionDirectionZ\' %\'UserData22\'',
    '    \'0019\' \'10BE\' \'DS\' \'ProjectionAngle\'',
    '    \'0019\' \'10C0\' \'SS\' \'SaturationPlanes\'',
    '    \'0019\' \'10C2\' \'SS\' \'SATlocationR\'',
    '    \'0019\' \'10C3\' \'SS\' \'SATlocationL\'',
    '    \'0019\' \'10C4\' \'SS\' \'SATlocationA\'',
    '    \'0019\' \'10C5\' \'SS\' \'SATlocationP\'',
    '    \'0019\' \'10C6\' \'SS\' \'SATlocationH\'',
    '    \'0019\' \'10C7\' \'SS\' \'SATlocationF\'',
    '    \'0019\' \'10C8\' \'SS\' \'SATThicknessRL\'',
    '    \'0019\' \'10C9\' \'SS\' \'SATThicknessAP\'',
    '    \'0019\' \'10CA\' \'SS\' \'SATThicknessHF\'',
    '    \'0019\' \'10CB\' \'SS\' \'PhaseContrastFlowAxis\'',
    '    \'0019\' \'10CC\' \'SS\' \'VelocityEncoding\'',
    '    \'0019\' \'10CD\' \'SS\' \'ThicknessDisclaimer\'',
    '    \'0019\' \'10CE\' \'SS\' \'PrescanType\'',
    '    \'0019\' \'10CF\' \'SS\' \'PrescanStatus\'',
    '    \'0019\' \'10D2\' \'SS\' \'ProjectionAlgorithm\'',
    '    \'0019\' \'10D5\' \'SS\' \'FractionalEcho\'',
    '    \'0019\' \'10D7\' \'SS\' \'CardiacPhaseNumber\'',
    '    \'0019\' \'10D8\' \'SS\' \'VariableEchoflag\'',
    '    \'0019\' \'10D9\' \'DS\' \'ConcatenatedSAT\'',
    '    \'0019\' \'10DF\' \'DS\' \'UserData23\'',
    '    \'0019\' \'10E0\' \'DS\' \'NumberOfDiffusionDirection\' %\'UserData24\'',
    '    \'0019\' \'10E2\' \'DS\' \'VelocityEncodeScale\'',
    '    \'0019\' \'10F2\' \'SS\' \'FastPhases\'',
    '    \'0019\' \'10F9\' \'DS\' \'TransmitGain\'',
    '    \'0020\' \'9301\' \'DS\' \'ImagePositionPatient\' % These 4 are not private',
    '    \'0020\' \'9302\' \'DS\' \'ImageOrientationPatient\' % but seems used only by GE',
    '    \'0020\' \'930E\' \'SQ\' \'PlanePositionSequence\'',
    '    \'0020\' \'930F\' \'SQ\' \'PlaneOrientationSequence\'',
    '    \'0021\' \'1003\' \'SS\' \'SeriesFromWhichPrescribed\'',
    '    \'0021\' \'1035\' \'SS\' \'SeriesFromWhichPrescribed\'',
    '    \'0021\' \'1036\' \'SS\' \'ImageFromWhichPrescribed\'',
    '    \'0021\' \'1037\' \'SS\' \'ScreenFormat\'',
    '    \'0021\' \'104F\' \'SS\' \'LocationsInAcquisition\'',
    '    \'0021\' \'1050\' \'SS\' \'GraphicallyPrescribed\'',
    '    \'0021\' \'1051\' \'DS\' \'RotationFromSourceXRot\'',
    '    \'0021\' \'1052\' \'DS\' \'RotationFromSourceYRot\'',
    '    \'0021\' \'1053\' \'DS\' \'RotationFromSourceZRot\'',
    '    \'0021\' \'1056\' \'SL\' \'Num3DSlabs\'',
    '    \'0021\' \'1057\' \'SL\' \'LocsPer3DSlab\'',
    '    \'0021\' \'1058\' \'SL\' \'Overlaps\'',
    '    \'0021\' \'1059\' \'SL\' \'ImageFiltering\'',
    '    \'0021\' \'105A\' \'SL\' \'DiffusionDirection\'',
    '    \'0021\' \'105B\' \'DS\' \'TaggingFlipAngle\'',
    '    \'0021\' \'105C\' \'DS\' \'TaggingOrientation\'',
    '    \'0021\' \'105D\' \'DS\' \'TagSpacing\'',
    '    \'0021\' \'105E\' \'DS\' \'RTIA_timer\'',
    '    \'0021\' \'105F\' \'DS\' \'Fps\'',
    '    \'0021\' \'1081\' \'DS\' \'AutoWindowLevelAlpha\'',
    '    \'0021\' \'1082\' \'DS\' \'AutoWindowLevelBeta\'',
    '    \'0021\' \'1083\' \'DS\' \'AutoWindowLevelWindow\'',
    '    \'0021\' \'1084\' \'DS\' \'AutoWindowLevelLevel\'',
    '    \'0023\' \'1070\' \'FD\' \'StartTimeInFirstAxial\'',
    '    \'0023\' \'1074\' \'SL\' \'NumberOfUpdatesToHeader\'',
    '    \'0023\' \'107D\' \'SS\' \'IndicatesStudyHasCompleteInfo\'',
    '    \'0025\' \'1006\' \'SS\' \'LastPulseSequenceUsed\'',
    '    \'0025\' \'1007\' \'SL\' \'ImagesInSeries\'',
    '    \'0025\' \'1010\' \'SL\' \'LandmarkCounter\'',
    '    \'0025\' \'1011\' \'SS\' \'NumberOfAcquisitions\'',
    '    \'0025\' \'1014\' \'SL\' \'IndicatesNumberOfUpdatesToHeader\'',
    '    \'0025\' \'1017\' \'SL\' \'SeriesCompleteFlag\'',
    '    \'0025\' \'1018\' \'SL\' \'NumberOfImagesArchived\'',
    '    \'0025\' \'1019\' \'SL\' \'LastImageNumberUsed\'',
    '    \'0025\' \'101A\' \'SH\' \'PrimaryReceiverSuiteAndHost\'',
    '    \'0025\' \'101B\' \'OB\' \'ProtocolDataBlock\'',
    '    \'0027\' \'1006\' \'SL\' \'ImageArchiveFlag\'',
    '    \'0027\' \'1010\' \'SS\' \'ScoutType\'',
    '    \'0027\' \'1031\' \'SS\' \'ImagingMode\'',
    '    \'0027\' \'1032\' \'SS\' \'PulseSequence\'',
    '    \'0027\' \'1033\' \'UL\' \'ImagingOptions\'',
    '    \'0027\' \'1035\' \'SS\' \'PlaneType\'',
    '    \'0027\' \'1040\' \'SH\' \'RASletterOfImageLocation\'',
    '    \'0027\' \'1041\' \'FL\' \'ImageLocation\'',
    '    \'0027\' \'1042\' \'FL\' \'CenterRCoordOfPlaneImage\'',
    '    \'0027\' \'1043\' \'FL\' \'CenterACoordOfPlaneImage\'',
    '    \'0027\' \'1044\' \'FL\' \'CenterSCoordOfPlaneImage\'',
    '    \'0027\' \'1045\' \'FL\' \'NormalRCoord\'',
    '    \'0027\' \'1046\' \'FL\' \'NormalACoord\'',
    '    \'0027\' \'1047\' \'FL\' \'NormalSCoord\'',
    '    \'0027\' \'1060\' \'FL\' \'ImageDimensionX\'',
    '    \'0027\' \'1061\' \'FL\' \'ImageDimensionY\'',
    '    \'0027\' \'1062\' \'FL\' \'NumberOfExcitations\'',
    '    \'0029\' \'1015\' \'SL\' \'LowerRangeOfPixels1\'',
    '    \'0029\' \'1016\' \'SL\' \'UpperRangeOfPixels1\'',
    '    \'0029\' \'1017\' \'SL\' \'LowerRangeOfPixels2\'',
    '    \'0029\' \'1018\' \'SL\' \'UpperRangeOfPixels2\'',
    '    \'0029\' \'1026\' \'SS\' \'VersionOfTheHdrStruct\'',
    '    \'0029\' \'1034\' \'SL\' \'AdvantageCompOverflow\'',
    '    \'0029\' \'1035\' \'SL\' \'AdvantageCompUnderflow\'',
    '    \'0043\' \'1001\' \'SS\' \'BitmapOfPrescanOptions\'',
    '    \'0043\' \'1002\' \'SS\' \'GradientOffsetInX\'',
    '    \'0043\' \'1003\' \'SS\' \'GradientOffsetInY\'',
    '    \'0043\' \'1004\' \'SS\' \'GradientOffsetInZ\'',
    '    \'0043\' \'1006\' \'SS\' \'NumberOfEPIShots\'',
    '    \'0043\' \'1007\' \'SS\' \'ViewsPerSegment\'',
    '    \'0043\' \'1008\' \'SS\' \'RespiratoryRate\'',
    '    \'0043\' \'1009\' \'SS\' \'RespiratoryTriggerPoint\'',
    '    \'0043\' \'100A\' \'SS\' \'TypeOfReceiverUsed\'',
    '    \'0043\' \'100B\' \'DS\' \'DB_dtPeakRateOfChangeOfGradientField\'',
    '    \'0043\' \'100C\' \'DS\' \'dB_dtLimitsInUnitsOfPercent\'',
    '    \'0043\' \'100D\' \'DS\' \'PSDEstimatedLimit\'',
    '    \'0043\' \'100E\' \'DS\' \'PSDEstimatedLimitInTeslaPerSecond\'',
    '    \'0043\' \'1010\' \'SS\' \'WindowValue\'',
    '    \'0043\' \'101C\' \'SS\' \'GEImageIntegrity\'',
    '    \'0043\' \'101D\' \'SS\' \'LevelValue\'',
    '    \'0043\' \'100F\' \'DS\' \'Saravghead\'',
    '    \'0043\' \'1028\' \'OB\' \'UniqueImageIden\'',
    '    \'0043\' \'1029\' \'OB\' \'HistogramTables\'',
    '    \'0043\' \'102A\' \'OB\' \'UserDefineData\'',
    '    \'0043\' \'102B\' \'SS\' \'PrivateScanOptions\'',
    '    \'0043\' \'102C\' \'SS\' \'EffectiveEchoSpacing\'',
    '    \'0043\' \'102D\' \'SH\' \'FilterMode\'',
    '    \'0043\' \'102F\' \'SS\' \'PrivateImageType\'',
    '    \'0043\' \'1030\' \'SS\' \'VasCollapseFlag\'',
    '    \'0043\' \'1032\' \'SS\' \'VasFlags\'',
    '    \'0043\' \'1033\' \'FL\' \'Neg_scanspacing\'',
    '    \'0043\' \'1034\' \'IS\' \'OffsetFrequency\'',
    '    \'0043\' \'1035\' \'UL\' \'User_usage_tag\'',
    '    \'0043\' \'1036\' \'UL\' \'User_fill_map_MSW\'',
    '    \'0043\' \'1037\' \'UL\' \'User_fill_map_LSW\'',
    '    \'0043\' \'1038\' \'FL\' \'UserData_25_48\'',
    '    \'0043\' \'1039\' \'IS\' \'SlopInt_6_9\'',
    '    \'0043\' \'1060\' \'IS\' \'SlopInt_10_17\'',
    '    \'0043\' \'1061\' \'UI\' \'ScannerStudyEntityUID\'',
    '    \'0043\' \'1062\' \'SH\' \'ScannerStudyID\'',
    '    \'0043\' \'106F\' \'DS\' \'ScannerTableEntry\'',
    '    \'0043\' \'1070\' \'LO\' \'ParadigmName\'',
    '    \'0043\' \'1071\' \'ST\' \'ParadigmDescription\'',
    '    \'0043\' \'1072\' \'UI\' \'ParadigmUID\'',
    '    \'0043\' \'1073\' \'US\' \'ExperimentType\'',
    '    \'0043\' \'1074\' \'US\' \'NumberOfRestVolumes\'',
    '    \'0043\' \'1075\' \'US\' \'NumberOfActiveVolumes\'',
    '    \'0043\' \'1076\' \'US\' \'NumberOfDummyScans\'',
    '    \'0043\' \'1079\' \'US\' \'LocationsInAcquisition\' % \'SlicesPerVolume\'',
    '    \'0043\' \'107A\' \'US\' \'ExpectedTimePoints\'',
    '    \'0043\' \'107B\' \'FL\' \'RegressorValues\'',
    '    \'0043\' \'107C\' \'FL\' \'DelayAfterSliceGroup\'',
    '    \'0043\' \'107D\' \'US\' \'ReconModeFlagWord\'',
    '    \'0043\' \'1080\' \'LO\' \'CoilIDData\'',
    '    \'0043\' \'1081\' \'LO\' \'GECoilName\'',
    '    \'0043\' \'1082\' \'LO\' \'SystemConfigurationInformation\'',
    '    \'0043\' \'1083\' \'DS\' \'AssetRFactors\'',
    '    \'0043\' \'1084\' \'LO\' \'AdditionalAssetData\'',
    '    \'0043\' \'1088\' \'UI\' \'PUREAcquisitionCalibrationSeriesUID\'',
    '    \'0043\' \'1089\' \'LO\' \'GoverningBodydB_dtAndSARDefinition\'',
    '    \'0043\' \'108A\' \'CS\' \'InPlanePhaseEncodingDirection\'',
    '    \'0043\' \'108B\' \'OB\' \'FMRIBinaryDataBlock\'',
    '    \'0043\' \'1090\' \'LO\' \'SARDefinition\'',
    '    \'0043\' \'1091\' \'DS\' \'SARValue\'',
    '    \'0043\' \'1095\' \'LO\' \'PrescanReuseString\'',
    '    \'0043\' \'1096\' \'CS\' \'ContentQualification\'',
    '    \'0043\' \'1097\' \'LO\' \'ImageFilteringParameters\'',
    '    \'0043\' \'1098\' \'UI\' \'ASSETAcquisitionCalibrationSeriesUID\'',
    '    \'0043\' \'109A\' \'IS\' \'RxStackIdentification\'',
    '    \'0043\' \'10AA\' \'LO\' \'AdditionalFilteringParameters\'',
    '    \'0043\' \'10B3\' \'DS\' \'AdvancedEddyCorrection\' }];',
    '    % SlopInt:',
    '    % 6: b_value 7: private imaging options 2  8: ihtagging  9: ihtagspc',
    '    % 10: ihfcineim  11: ihfcinent  12: Reserved  13: oprtarr ',
    '    % 14: averages  15: Current Station #  16: Total # of Stations ',
    '    % 17: private imaging options 3',
    '',
    '    % ScannerTableEntry:',
    '    % 1: table entry, 2: table swing angle, 3: table lateral offset, ',
    '    % 4: gradient coil selected (multiple gradient systems only)',
    'elseif strncmpi(vendor, \'Philips\', 7)',
    '    C = [C; {',
    '    \'2001\' \'1001\' \'FL\' \'ChemicalShift\'',
    '    \'2001\' \'1002\' \'IS\' \'ChemicalShiftNumberMR\'',
    '    \'2001\' \'1003\' \'FL\' \'B_factor\'',
    '    \'2001\' \'1004\' \'CS\' \'DiffusionDirection\'',
    '    \'2001\' \'1006\' \'CS\' \'ImageEnhanced\'',
    '    \'2001\' \'1007\' \'CS\' \'ImageTypeEDES\'',
    '    \'2001\' \'1008\' \'IS\' \'PhaseNumber\'',
    '    \'2001\' \'1009\' \'FL\' \'ImagePrepulseDelay\'',
    '    \'2001\' \'100A\' \'IS\' \'SliceNumberMR\'',
    '    \'2001\' \'100B\' \'CS\' \'SliceOrientation\'',
    '    \'2001\' \'100C\' \'CS\' \'ArrhythmiaRejection\'',
    '    \'2001\' \'100E\' \'CS\' \'CardiacCycled\'',
    '    \'2001\' \'100F\' \'SS\' \'CardiacGateWidth\'',
    '    \'2001\' \'1010\' \'CS\' \'CardiacSync\'',
    '    \'2001\' \'1011\' \'FL\' \'DiffusionEchoTime\'',
    '    \'2001\' \'1012\' \'CS\' \'DynamicSeries\'',
    '    \'2001\' \'1013\' \'SL\' \'EPIFactor\'',
    '    \'2001\' \'1014\' \'SL\' \'NumberOfEchoes\'',
    '    \'2001\' \'1015\' \'SS\' \'NumberOfLocations\'',
    '    \'2001\' \'1016\' \'SS\' \'NumberOfPCDirections\'',
    '    \'2001\' \'1017\' \'SL\' \'NumberOfPhasesMR\'',
    '    \'2001\' \'1018\' \'SL\' \'LocationsInAcquisition\'  % \'NumberOfSlicesMR\'',
    '    \'2001\' \'1019\' \'CS\' \'PartialMatrixScanned\'',
    '    \'2001\' \'101A\' \'FL\' \'PCVelocity\'',
    '    \'2001\' \'101B\' \'FL\' \'PrepulseDelay\'',
    '    \'2001\' \'101C\' \'CS\' \'PrepulseType\'',
    '    \'2001\' \'101D\' \'IS\' \'ReconstructionNumberMR\'',
    '    \'2001\' \'101F\' \'CS\' \'RespirationSync\'',
    '    \'2001\' \'1020\' \'LO\' \'ScanningSequence\' % ScanningTechnique',
    '    \'2001\' \'1021\' \'CS\' \'SPIR\'',
    '    \'2001\' \'1022\' \'FL\' \'WaterFatShift\'',
    '    \'2001\' \'1023\' \'DS\' \'MRSeriesFlipAngle\' % duplicate',
    '    \'2001\' \'1024\' \'CS\' \'SeriesIsInteractive\' ',
    '    \'2001\' \'1025\' \'SH\' \'EchoTimeDisplay\' ',
    '    \'2001\' \'102D\' \'SS\' \'StackNumberOfSlices\'',
    '    \'2001\' \'1032\' \'FL\' \'StackRadialAngle\'',
    '    \'2001\' \'1033\' \'CS\' \'StackRadialAxis\'',
    '    \'2001\' \'1035\' \'SS\' \'StackSliceNumber\'',
    '    \'2001\' \'1036\' \'CS\' \'StackType\'',
    '    \'2001\' \'105F\' \'SQ\' \'Stack\' ',
    '    \'2001\' \'1060\' \'SL\' \'NumberOfStacks\'',
    '    \'2001\' \'1061\' \'CS\' \'SeriesTransmitted\'',
    '    \'2001\' \'1062\' \'CS\' \'SeriesCommitted\'',
    '    \'2001\' \'1063\' \'CS\' \'ExaminationSource\'',
    '    \'2001\' \'106E\' \'SH\' \'SeriesType\'',
    '    \'2001\' \'107B\' \'IS\' \'MRSeriesAcquisitionNumber\'',
    '    \'2001\' \'1081\' \'IS\' \'NumberOfDynamicScans\'',
    '    \'2001\' \'1082\' \'IS\' \'MRSeriesEchoTrainLength\' % duplicate',
    '    \'2001\' \'1083\' \'DS\' \'MRSeriesImagingFrequency\' % duplicate',
    '    \'2001\' \'1084\' \'DS\' \'MRSeriesInversionTime\' % duplicate',
    '    \'2001\' \'1085\' \'DS\' \'MRSeriesMagneticFieldStrength\' % duplicate, seems wrong',
    '    \'2001\' \'1086\' \'IS\' \'MRSeriesNrOfPhaseEncodingSteps\' % duplicate, seems wrong',
    '    \'2001\' \'1087\' \'SH\' \'MRSeriesNucleus\' % duplicate',
    '    \'2001\' \'1088\' \'DS\' \'MRSeriesNumberOfAverages\' % duplicate',
    '    \'2001\' \'1089\' \'DS\' \'MRSeriesPercentPhaseFieldOfView\' % duplicate, wrong',
    '    \'2001\' \'108A\' \'DS\' \'MRSeriesPercentSampling\' % duplicate, wrong',
    '    \'2001\' \'108B\' \'SH\' \'MRSeriesTransmittingCoil\' % duplicate',
    '    \'2001\' \'10C8\' \'LO\' \'ExamCardName\'',
    '    \'2001\' \'10F1\' \'FL\' \'ProspectiveMotionCorrection\'',
    '    \'2001\' \'10F2\' \'FL\' \'RetrospectiveMotionCorrection\'',
    '    \'2005\' \'1000\' \'FL\' \'MRImageAngulationAP\' ',
    '    \'2005\' \'1001\' \'FL\' \'MRImageAngulationFH\' ',
    '    \'2005\' \'1002\' \'FL\' \'MRImageAngulationRL\'',
    '    \'2005\' \'1004\' \'CS\' \'MRImageDisplayOrientation\'',
    '    \'2005\' \'1008\' \'FL\' \'MRImageOffCentreAP\'',
    '    \'2005\' \'1009\' \'FL\' \'MRImageOffCentreFH\'',
    '    \'2005\' \'100A\' \'FL\' \'MRImageOffCentreRL\'',
    '    \'2005\' \'100B\' \'FL\' \'MRMaxFP\'',
    '    \'2005\' \'100C\' \'FL\' \'MRMinFP\'',
    '    \'2005\' \'100D\' \'FL\' \'MRScaleIntercept\'',
    '    \'2005\' \'100E\' \'FL\' \'MRScaleSlope\'',
    '    \'2005\' \'100F\' \'DS\' \'WindowCenterOriginal\'',
    '    \'2005\' \'1010\' \'DS\' \'WindowWidthOriginal\'',
    '    \'2005\' \'1011\' \'CS\' \'MRImageTypeMR\'',
    '    \'2005\' \'1012\' \'CS\' \'MRCardiacGating\'',
    '    \'2005\' \'1013\' \'CS\' \'MRSeriesDevelopmentMode\'',
    '    \'2005\' \'1014\' \'CS\' \'MRSeriesDiffusion\'',
    '    \'2005\' \'1015\' \'CS\' \'MRFatSaturationTechnique\'',
    '    \'2005\' \'1016\' \'CS\' \'MRFlowCompensation\'',
    '    \'2005\' \'1017\' \'CS\' \'MRFourierInterpolation\'',
    '    \'2005\' \'1019\' \'CS\' \'MRInverseReconstructed\'',
    '    \'2005\' \'101A\' \'SS\' \'MRLabelSyntax\'',
    '    \'2005\' \'101B\' \'CS\' \'MRMagnetiPrepared\'',
    '    \'2005\' \'101C\' \'CS\' \'MRMagnetTransferConst\'',
    '    \'2005\' \'101D\' \'SS\' \'MRMeasurementScanResolution\'',
    '    \'2005\' \'101E\' \'SH\' \'MIPProtocol\' ',
    '    \'2005\' \'101F\' \'SH\' \'MPRProtocol\' ',
    '    \'2005\' \'1020\' \'SL\' \'NumberOfChemicalShift\'',
    '    \'2005\' \'1021\' \'SS\' \'MRNumberOfMixes\'',
    '    \'2005\' \'1022\' \'IS\' \'MRNumberOfReferences\'',
    '    \'2005\' \'1023\' \'SS\' \'MRNumberOfSlabs\'',
    '    \'2005\' \'1025\' \'SS\' \'MRNumberOfVolumes\'',
    '    \'2005\' \'1026\' \'CS\' \'MROverSampleingPhase\'',
    '    \'2005\' \'1027\' \'CS\' \'MRPackageMode\'',
    '    \'2005\' \'1028\' \'CS\' \'MRPartialFourierFrequency\'',
    '    \'2005\' \'1029\' \'CS\' \'MRPartialFourierPhase\'',
    '    \'2005\' \'102A\' \'IS\' \'MRPatientReferenceID\'',
    '    \'2005\' \'102B\' \'SS\' \'MRPercentScanComplete\'',
    '    \'2005\' \'102C\' \'CS\' \'MRPhaseEncodedRecording\'',
    '    \'2005\' \'102D\' \'IS\' \'MRPlanScanSurveyNumberOfImages\'',
    '    \'2005\' \'102E\' \'CS\' \'MRPPGPPUGating\'',
    '    \'2005\' \'102F\' \'CS\' \'MRSpatialPresaturation\'',
    '    \'2005\' \'1030\' \'FL\' \'MRSeriesRepetitionTime\' % duplicate',
    '    \'2005\' \'1031\' \'CS\' \'MRRespiratoryGating\'',
    '    \'2005\' \'1033\' \'FL\' \'MRSeriesScanDuration\'',
    '    \'2005\' \'1034\' \'CS\' \'MRSegmentedKSpace\'',
    '    \'2005\' \'1035\' \'CS\' \'MRSeriesDataType\'',
    '    \'2005\' \'1036\' \'CS\' \'MRSeriesIsCardiac\'',
    '    \'2005\' \'1037\' \'CS\' \'MRSeriesIsSpectro\'',
    '    \'2005\' \'1038\' \'CS\' \'MRSpoiled\'',
    '    \'2005\' \'1039\' \'CS\' \'MRSteadyState\'',
    '    \'2005\' \'103A\' \'SH\' \'MRSubAnatomy\'',
    '    \'2005\' \'103B\' \'CS\' \'MRTimeReversedSteadyState\'',
    '    \'2005\' \'103C\' \'CS\' \'MRSeriesTone\'',
    '    \'2005\' \'103D\' \'SS\' \'MRNumberOfRRIntervalRanges\'',
    '    \'2005\' \'103E\' \'SL\' \'MRRRIntervalsDistribution\'',
    '    \'2005\' \'103F\' \'SL\' \'MRPlanScanAcquisitionNo\'',
    '    \'2005\' \'1040\' \'SL\' \'MRChemicalShiftNo\'',
    '    \'2005\' \'1041\' \'SL\' \'MRPlanScanDynamicScanNo\'',
    '    \'2005\' \'1042\' \'SL\' \'MRPlanScanSurveyEchoNo\'',
    '    \'2005\' \'1043\' \'CS\' \'MRPlanScanImageType\'',
    '    \'2005\' \'1044\' \'SL\' \'MRPlanScanPhaseNo\'',
    '    \'2005\' \'1045\' \'SL\' \'MRPlanScanReconstructionNo\'',
    '    \'2005\' \'1046\' \'CS\' \'MRPlanScanScanningSequence\'',
    '    \'2005\' \'1047\' \'SL\' \'MRPlanScanSliceNo\'',
    '    \'2005\' \'1054\' \'FL\' \'MRVolumeAngulationAP\'',
    '    \'2005\' \'1055\' \'FL\' \'MRVolumeAngulationFH\'',
    '    \'2005\' \'1056\' \'FL\' \'MRVolumeAngulationRL\'',
    '    \'2005\' \'1057\' \'FL\' \'MRVolumeFovAP\'',
    '    \'2005\' \'1058\' \'FL\' \'MRVolumeFovFH\'',
    '    \'2005\' \'1059\' \'FL\' \'MRVolumeFovRL\'',
    '    \'2005\' \'105A\' \'FL\' \'MRVolumeOffcentreAP\'',
    '    \'2005\' \'105B\' \'FL\' \'MRVolumeOffcentreFH\'',
    '    \'2005\' \'105C\' \'FL\' \'MRVolumeOffcentreRL\'',
    '    \'2005\' \'105D\' \'CS\' \'MRVolumeType\'',
    '    \'2005\' \'105E\' \'CS\' \'MRVolumeViewAxis\'',
    '    \'2005\' \'105F\' \'CS\' \'MRStudyOrigin\'',
    '    \'2005\' \'1060\' \'IS\' \'MRStudySequenceNumber\'',
    '    \'2005\' \'1061\' \'CS\' \'MRImagePrepulseType\'',
    '    \'2005\' \'1063\' \'SS\' \'MRfMRIStatusIndication\'',
    '    \'2005\' \'106E\' \'CS\' \'MRImageScanningSequencePrivate\'',
    '    \'2005\' \'106F\' \'CS\' \'MRAcquisitionType\' % \'MRSeriesAcquisitionTypePrivate\'',
    '    \'2005\' \'1071\' \'FL\' \'MRStackAngulationAP\'',
    '    \'2005\' \'1072\' \'FL\' \'MRStackAngulationFH\'',
    '    \'2005\' \'1073\' \'FL\' \'MRStackAngulationRL\'',
    '    \'2005\' \'1074\' \'FL\' \'MRStackFovAP\'',
    '    \'2005\' \'1075\' \'FL\' \'MRStackFovFH\'',
    '    \'2005\' \'1076\' \'FL\' \'MRStackFovRL\'',
    '    \'2005\' \'1078\' \'FL\' \'MRStackOffcentreAP\'',
    '    \'2005\' \'1079\' \'FL\' \'MRStackOffcentreFH\'',
    '    \'2005\' \'107A\' \'FL\' \'MRStackOffcentreRL\'',
    '    \'2005\' \'107B\' \'CS\' \'MRStackPreparationDirection\'',
    '    \'2005\' \'107E\' \'FL\' \'MRStackSliceDistance\'',
    '    \'2005\' \'1080\' \'SQ\' \'SeriesPlanScan\'',
    '    \'2005\' \'1081\' \'CS\' \'MRStackViewAxis\'',
    '    \'2005\' \'1083\' \'SQ\' \'SeriesSlab\'',
    '    \'2005\' \'1084\' \'SQ\' \'SeriesReference\'',
    '    \'2005\' \'1085\' \'SQ\' \'SeriesVolume\'',
    '    \'2005\' \'1086\' \'SS\' \'MRNumberOfGeometry\'',
    '    \'2005\' \'109E\' \'SQ\' \'SeriesGeom\'',
    '    \'2005\' \'109F\' \'CS\' \'MRSeriesSpectralSelectiveExcitationPulse\'',
    '    \'2005\' \'10A0\' \'FL\' \'MRImageDynamicScanBeginTime\'',
    '    \'2005\' \'10A1\' \'CS\' \'SyncraScanType\'',
    '    \'2005\' \'10A2\' \'CS\' \'MRIsCOCA\'',
    '    \'2005\' \'10A3\' \'IS\' \'MRStackCoilID\'',
    '    \'2005\' \'10A4\' \'IS\' \'MRStackCBBCoil1\'',
    '    \'2005\' \'10A5\' \'IS\' \'MRStackCBBCoil2\'',
    '    \'2005\' \'10A6\' \'IS\' \'MRStackChannelCombi\'',
    '    \'2005\' \'10A7\' \'CS\' \'MRStackCoilConn\'',
    '    \'2005\' \'10A8\' \'DS\' \'MRPrivateInversionTime\'',
    '    \'2005\' \'10A9\' \'CS\' \'MRSeriesGeometryCorrection\'',
    '    \'2005\' \'10B0\' \'FL\' \'DiffusionDirectionX\' % degrees',
    '    \'2005\' \'10B1\' \'FL\' \'DiffusionDirectionY\'',
    '    \'2005\' \'10B2\' \'FL\' \'DiffusionDirectionZ\' ',
    '    \'2005\' \'10C0\' \'CS\' \'SequenceVariant\' % \'SeriesScanSequence\' % duplicate',
    '    \'2005\' \'1134\' \'LT\' \'SeriesTransactionUID\'',
    '    \'2005\' \'1199\' \'UL\' \'MRNumberOfRequestExcerpts\'',
    '    \'2005\' \'1200\' \'UL\' \'MRNumberOfSOPCommon\'',
    '    \'2005\' \'1201\' \'UL\' \'MRNoOfFilmConsumption\'',
    '    \'2005\' \'1213\' \'UL\' \'MRNumberOfCodes\'',
    '    \'2005\' \'1243\' \'SS\' \'MRNoDateOfLastCalibration\'',
    '    \'2005\' \'1244\' \'SS\' \'MRNoTimeOfLastCalibration\'',
    '    \'2005\' \'1245\' \'SS\' \'MRNrOfSoftwareVersion\'',
    '    \'2005\' \'1247\' \'SS\' \'MRNrOfPatientOtherNames\'',
    '    \'2005\' \'1248\' \'SS\' \'MRNrOfReqRecipeOfResults\'',
    '    \'2005\' \'1249\' \'SS\' \'MRNrOfSeriesOperatorsName\'',
    '    \'2005\' \'1250\' \'SS\' \'MRNrOfSeriesPerfPhysiName\'',
    '    \'2005\' \'1251\' \'SS\' \'MRNrOfStudyAdmittingDiagnosticDescr\'',
    '    \'2005\' \'1252\' \'SS\' \'MRNrOfStudyPatientContrastAllergies\'',
    '    \'2005\' \'1253\' \'SS\' \'MRNrOfStudyPatientMedicalAlerts\'',
    '    \'2005\' \'1254\' \'SS\' \'MRNrOfStudyPhysiciansOfRecord\'',
    '    \'2005\' \'1255\' \'SS\' \'MRNrOfStudyPhysiReadingStudy\'',
    '    \'2005\' \'1325\' \'CS\' \'MRSpectroSIB0Correction\'',
    '    \'2005\' \'1326\' \'FL\' \'MRSpectroB0EchoTopPosition\'',
    '    \'2005\' \'1327\' \'CS\' \'MRSpectroComplexComponent\'',
    '    \'2005\' \'1328\' \'CS\' \'MRSpectroDataOrigin\'',
    '    \'2005\' \'1329\' \'FL\' \'MRSpectroEchoTopPosition\'',
    '    \'2005\' \'1330\' \'CS\' \'MRInPlaneTransforms\'',
    '    \'2005\' \'1331\' \'SS\' \'MRNumberOfSpectraAcquired\'',
    '    \'2005\' \'1333\' \'FL\' \'MRPhaseEncodingEchoTopPositions\'',
    '    \'2005\' \'1334\' \'CS\' \'MRPhysicalQuantityForChemicalShift\'',
    '    \'2005\' \'1335\' \'CS\' \'MRPhysicalQuantitySpatial\'',
    '    \'2005\' \'1336\' \'FL\' \'MRReferenceFrequency\'',
    '    \'2005\' \'1337\' \'FL\' \'MRSampleOffset\'',
    '    \'2005\' \'1338\' \'FL\' \'MRSamplePitch\'',
    '    \'2005\' \'1339\' \'SS\' \'MRSearchIntervalForPeaks\'',
    '    \'2005\' \'1340\' \'CS\' \'MRSignalDomainForChemicalShift\'',
    '    \'2005\' \'1341\' \'CS\' \'MRSignalDomainSpatial\'',
    '    \'2005\' \'1342\' \'CS\' \'MRSignalType\'',
    '    \'2005\' \'1343\' \'CS\' \'MRSpectroAdditionalRotations\'',
    '    \'2005\' \'1344\' \'SS\' \'MRSpectroDisplayRanges\'',
    '    \'2005\' \'1345\' \'CS\' \'MRSpectroEchoAcquisition\'',
    '    \'2005\' \'1346\' \'CS\' \'MRSpectroFrequencyUnit\'',
    '    \'2005\' \'1347\' \'FL\' \'MRSpectroGamma\'',
    '    \'2005\' \'1348\' \'CS\' \'MRSpectroHiddenLineRemoval\'',
    '    \'2005\' \'1349\' \'FL\' \'MRSpectroHorizontalShift\'',
    '    \'2005\' \'1350\' \'FL\' \'MRSpectroHorizontalWindow\'',
    '    \'2005\' \'1351\' \'SS\' \'MRSpectroNumberOfDisplayRanges\'',
    '    \'2005\' \'1352\' \'SS\' \'MRSpectroNumberOfEchoPulses\'',
    '    \'2005\' \'1353\' \'LO\' \'MRSpectroProcessingHistory\'',
    '    \'2005\' \'1354\' \'CS\' \'MRSpectroScanType\'',
    '    \'2005\' \'1355\' \'FL\' \'MRSpectroSICSIntervals\'',
    '    \'2005\' \'1356\' \'CS\' \'MRSpectroSIMode\'',
    '    \'2005\' \'1357\' \'SS\' \'MRSpectroSpectralBW\'',
    '    \'2005\' \'1358\' \'LO\' \'MRSpectroTitleLine\'',
    '    \'2005\' \'1359\' \'FL\' \'MRSpectroTurboEchoSpacing\'',
    '    \'2005\' \'1360\' \'FL\' \'MRSpectroVerticalShift\'',
    '    \'2005\' \'1361\' \'FL\' \'MRSpectroVerticalWindow\'',
    '    \'2005\' \'1362\' \'FL\' \'MRSpectroOffset\'',
    '    \'2005\' \'1363\' \'FL\' \'MRSpectrumPitch\'',
    '    \'2005\' \'1364\' \'CS\' \'MRVolumeSelection\'',
    '    \'2005\' \'1370\' \'SS\' \'MRNoMixesSpectro\'',
    '    \'2005\' \'1371\' \'SQ\' \'MRSeriesSPMix\'',
    '    \'2005\' \'1381\' \'IS\' \'MRScanoGramSurveyNumberOfImages\'',
    '    \'2005\' \'1382\' \'UL\' \'MRNumberOfProcedureCodes\'',
    '    \'2005\' \'1390\' \'CS\' \'MRStackCoilFunction\'',
    '    \'2005\' \'1392\' \'IS\' \'MRGeolinkID\'',
    '    \'2005\' \'1393\' \'IS\' \'MRStationNo\'',
    '    \'2005\' \'1396\' \'CS\' \'MRFlowImagesPresent\'',
    '    \'2005\' \'1397\' \'LO\' \'AnatomicRegCodeValue\'',
    '    \'2005\' \'1398\' \'CS\' \'MRMobiviewEnabled\'',
    '    \'2005\' \'1399\' \'CS\' \'MRIViewBoldEnabled\'',
    '    \'2005\' \'1400\' \'CS\' \'MRVolumeViewEnabled\'',
    '    \'2005\' \'1401\' \'UL\' \'MRNumberOfStudyReference\'',
    '    \'2005\' \'1402\' \'SQ\' \'SPSCode\'',
    '    \'2005\' \'1403\' \'UL\' \'MRNumberOfSPSCodes\'',
    '    \'2005\' \'1407\' \'SS\' \'MRNrOfSpecificCharacterSet\'',
    '    \'2005\' \'1409\' \'DS\' \'RescaleInterceptOriginal\'',
    '    \'2005\' \'140A\' \'DS\' \'RescaleSlopeOriginal\'',
    '    \'2005\' \'140B\' \'LO\' \'RescaleTypeOriginal\'',
    '    \'2005\' \'140E\' \'SQ\' \'PrivateSharedSq\'',
    '    \'2005\' \'140F\' \'SQ\' \'PrivatePerFrameSq\'',
    '    \'2005\' \'1411\' \'UI\' \'MFPrivateReferencedSOPInstanceUID\'',
    '    \'2005\' \'1412\' \'IS\' \'MRImageDiffBValueNumber\'',
    '    \'2005\' \'1413\' \'IS\' \'MRImageGradientOrientationNumber\'',
    '    \'2005\' \'1414\' \'SL\' \'MRSeriesNrOfDiffBValues\'',
    '    \'2005\' \'1415\' \'SL\' \'MRSeriesNrOfDiffGradOrients\'',
    '    \'2005\' \'1416\' \'CS\' \'MRSeriesPlanMode\'',
    '    \'2005\' \'1417\' \'FD\' \'B_matrix\' % DiffusionBMatrix',
    '    \'2005\' \'1418\' \'CS\' \'PrivOperatingModeType\'',
    '    \'2005\' \'1419\' \'CS\' \'PrivOperatingMode\'',
    '    \'2005\' \'141A\' \'CS\' \'MRFatSaturationTechnique\'',
    '    \'2005\' \'141B\' \'IS\' \'MRVersionNumberDeletedImages\'',
    '    \'2005\' \'141C\' \'IS\' \'MRVersionNumberDeletedSpectra\'',
    '    \'2005\' \'141D\' \'IS\' \'MRVersionNumberDeletedBlobsets\'',
    '    \'2005\' \'1426\' \'CS\' \'ViewingHardcopyOnly\'',
    '    \'2005\' \'1428\' \'SL\' \'MRSeriesNrOfLabelTypes\'',
    '    \'2005\' \'142A\' \'CS\' \'ExamPrintStatus\'',
    '    \'2005\' \'142B\' \'CS\' \'ExamExportStatus\'',
    '    \'2005\' \'142C\' \'CS\' \'ExamStorageCommitStatus\'',
    '    \'2005\' \'142D\' \'CS\' \'ExamMediaWriteStatus\'',
    '    \'2005\' \'1432\' \'CS\' \'MRSeriesSafetyOverrideMode\'',
    '    \'2005\' \'1435\' \'CS\' \'SpectroExamcard\'',
    '    \'2005\' \'143A\' \'LT\' \'DataDictionaryContentsVersion\'',
    '    \'2005\' \'143B\' \'CS\' \'MRIsCoilSurvey\'',
    '    \'2005\' \'143C\' \'FL\' \'MRStackTablePosLong\'',
    '    \'2005\' \'143D\' \'FL\' \'MRStackTablePosLat\'',
    '    \'2005\' \'143E\' \'FL\' \'MRStackPosteriorCoilPos\'',
    '    \'2005\' \'143F\' \'CS\' \'AIMDLimitsApplied\'',
    '    \'2005\' \'1440\' \'FL\' \'AIMDHeadSARLimit\'',
    '    \'2005\' \'1441\' \'FL\' \'AIMDWholeBodySARLimit\'',
    '    \'2005\' \'1442\' \'FL\' \'AIMDB1RMSLimit\'',
    '    \'2005\' \'1443\' \'FL\' \'AIMDdbDtLimit\'',
    '    \'2005\' \'1444\' \'IS\' \'TFEFactor\'',
    '    \'2005\' \'1445\' \'CS\' \'AttenuationCorrection\'',
    '    \'2005\' \'1447\' \'FL\' \'PowerOptimization\'',
    '    \'2005\' \'144A\' \'FL\' \'DataWindowDuration\'',
    '    \'2005\' \'144B\' \'FL\' \'MixingTime\'',
    '    \'2005\' \'144C\' \'FL\' \'FirstEchoTime\'',
    '    \'2005\' \'144D\' \'CS\' \'IsB0Series\'',
    '    \'2005\' \'144E\' \'CS\' \'IsB1Series\'',
    '    \'2005\' \'144F\' \'CS\' \'VolumeSelect\'',
    '    \'2005\' \'1450\' \'SS\' \'MRNrOfPatientOtherIDs\'',
    '    \'2005\' \'1455\' \'FD\' \'ImageVelocityEncodingDirection\'',
    '    \'2050\' \'0020\' \'CS\' \'PresentationLUTShape\' }];',
    '% elseif strncmpi(vendor, \'OtherVendor\', n)',
    'end',
    '',
    'dict.tag = uint32(hex2dec(strcat(C(:,1), C(:,2))));',
    'dict.vr = C(:,3); % for implicit VR and some problematic explicit VR',
    'dict.name = C(:,4);',
    '',
    'if nargin>1 && ~isempty(flds) % use only provided fields',
    '    flds = cellstr(flds);',
    '    ind = false(size(dict.tag,1), 1);',
    '    for i = 1:length(flds)',
    '        ind = ind | strcmp(flds{i}, dict.name); % include duplicate',
    '    end',
    '    dict.fields = flds; % remember the requested fields',
    '    dict.tag  = dict.tag(ind);',
    '    dict.vr   = dict.vr(ind);',
    '    dict.name = dict.name(ind);',
    'end',
    '',
    '[dict.tag, ind] = unique(dict.tag); % sort by tag',
    'dict.vr = dict.vr(ind);',
    'dict.name = dict.name(ind);'
  )

  dicm_hdr <- c(
    'function [s, info, dict] = dicm_hdr(fname, dict, iFrames)',
    '% Return header of a dicom file in a struct.',
    '% ',
    '% [s, err] = dicm_hdr(dicomFileName, dict, iFrames);',
    '% ',
    '% The mandatory 1st input is the dicom file name. The optional 2nd input can be',
    '% a dicom dict, which may have only part of the full dict. The partial dict can',
    '% be returned by dict = dicm_dict(vendor, fieldNames). The use of partial dict',
    '% may speed up header read considerably. See rename_dicm for example.',
    '% ',
    '% The optional 3rd intput is only needed for multi-frame dicom files. When there',
    '% are many frames, it may be very slow to read all items in',
    '% PerFrameFunctionalGroupsSequence for all frames. The 3rd input can be used to',
    '% specify the frames to read. By default, items for only 1st, 2nd and last',
    '% frames are read.',
    '% ',
    '% The optional 2nd output contains information in case of error, and will be',
    '% empty if there is no error.',
    '% ',
    '% DICM_HDR is like dicominfo from Matlab, but is independent of Image Processing',
    '% Toolbox. The limitation is it can deal with only little endian data for',
    '% popular vendors. The advantage is that it decodes most private and shadow tags',
    '% for Siemens, GE and Philips dicom, and runs faster, especially for partial',
    '% header and multi-frame dicom.',
    '% ',
    '% This can also read Philips PAR file and AFNI HEAD file, and return needed',
    '% fields for dicm2nii to convert into nifti.',
    '% ',
    '% See also DICM_DICT, DICM2NII, DICM_IMG, RENAME_DICM, SORT_DICM',
    '',
    '% The method used here:',
    '% Check 4 bytes at 128 to make sure it is \'DICM\';',
    '% Find PixelData; Get its location;',
    '% Loop through each item:',
    '%      Read tag: group and element, each 1 uint16;',
    '%        Find name in dictionary by the tag; if not exists,',
    '%        assign it as Private_xxxx_xxxx;',
    '%      Get VR:',
    '%        Read VR (2 char) if explicit VR; ',
    '%        Get VR from dict if implicit;',
    '%      Decode item length type:',
    '%        implicit VR, always uint32;',
    '%        explicit VR: uint16/uint32(skip 2 bytes) based on VR; ',
    '%      Decode data type by VR;',
    '%      if VR == \'SQ\', deal in special way;',
    '%      Read the item according to the length and data type;',
    '%        Process the item if needed;',
    '%      Assign to field.',
    '',
    '% History (yymmdd):',
    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com).',
    '% 130912 Extend private tags, automatically detect vendor.',
    '% 130923 Call philips_par, so make dicm2nii easier. ',
    '% 131001 Decode SQ, useful for multiframe dicom and Philips Stack. ',
    '% 131008 Load then typecast. Faster than multiple fread.',
    '% 131009 Work for implicit VR.',
    '% 131010 Decode Siemens CSA header (slow), so it is human readable.',
    '% 131019 PAR file: read image col labels, and use it for indexing.',
    '% 131023 Implement afni_hdr.',
    '% 131102 Use last tag for partial hdr, so return if it is non-exist fld.',
    '% 131107 Search tags if only a few fields: faster than regular way.',
    '% 131114 Add 3rd input: only 1,2,last frames hdr read. 0.4 vs 38 seconds!',
    '%        Store needed fields in LastFile for PAR MIXED image type.',
    '% 140123 Support dicom without meta info (thanks Paul).',
    '% 140213 afni_head: IJK_TO_DICOM_REAL replaces IJK_TO_DICOM.',
    '% 140502 philips_par: don\'t use FOV for PixelSpacing and SpacingBetweenSlices.',
    '% 140506 philips_par: use PAR file name as SeriesDescription.',
    '% 140512 decode GE ProtocolDataBlock (gz compressed).',
    '% 140611 No re-do if there are <16 extra bytes after image data.',
    '% 140724 Ignore PAR/HEAD ext case; fix philips_par: Patient Position.',
    '% 140924 Use dict VR if VR==OB/UN (thx Macro R). Could be bad in theory.',
    '% 141006 philips_par: take care of char(13 10) issue (thx Hye).',
    '% 141021 Store fields in dict, so it can be used for changed vendor.',
    '% 141023 checkManufacturer for fast search approach too.',
    '% 141128 Minor tweaks (len-1 in read_csa) for Octave 3.8.1.',
    '% 150114 Siemens CSA str is not always len=1. Fix it (runs slower).',
    '% 150128 Use memory gunzip for GE ProtocolDataBlock (0.5 vs 43 ms).',
    '% 150222 philips_par: fix slice dir in R using \'image offcentre\';',
    '%        Avoid repeatedly reading .REC .BRIK file for hdr. ',
    '% 150227 Avoid error due to empty file (thx Kushal).',
    '% 150316 Avoid error due to empty item dat for search method (thx VG).',
    '% 150324 philips_par/afni_head: make up SeriesInstanceUID for dicm2nii.',
    '% 150405 Implement bv_file to read non-transformed BV fmr/vmr/dmr.',
    '% 150504 bv_file: fix multiple STCdata; bug fix for VMRData.',
    '% 150513 return dict as 3rd output for dicm2nii in case of vendor change.',
    '% 150517 fix manufacturer check problem for Octave: no re-read.',
    '% 150522 PerFrameSQ ind: fix the case if numel(ind)~=nFrame.',
    '% 150526 read_sq: use ItemDelimitationItem instead of empty dat1 as SQ end.',
    '',
    'persistent dict_full;',
    's = []; info = \'\';',
    'fullHdr = false;',
    'if nargin<2 || isempty(dict)',
    '    if isempty(dict_full), dict_full = dicm_dict; end',
    '    fullHdr = true;',
    '    dict = dict_full; ',
    'end',
    'if nargin<3, iFrames = []; end',
    '',
    'fid = fopen(fname);',
    'if fid<0, info = [\'File not exists: \' fname]; return; end',
    'cln = onCleanup(@() fclose(fid));',
    'empty = fseek(fid, 128, -1);',
    'if empty',
    '    info = [\'Invalid file: \' fname];',
    '    return;',
    'end',
    'sig = fread(fid, 4, \'*char\')\';',
    'isDicm = strcmp(sig, \'DICM\');',
    'isTruncated = false;',
    'if ~isDicm',
    '    fseek(fid, 0, -1);',
    '    a = fread(fid, 1, \'uint16\');',
    '    if a==2 || a==8 % not safe, but no better way',
    '        fseek(fid, 0, -1);',
    '        isTruncated = true;',
    '    end',
    'end',
    'if ~isDicm && ~isTruncated % may be PAR or HEAD file',
    '    [~, ~, ext] = fileparts(fname);',
    '    try',
    '        if strcmpi(ext, \'.PAR\') % || strcmpi(ext, \'.REC\')',
    '            [s, info] = philips_par(fname);',
    '        elseif strcmpi(ext, \'.HEAD\') % || strcmpi(ext, \'.BRIK\')',
    '            [s, info] = afni_head(fname);',
    '        elseif any(strcmpi(ext, {\'.vmr\' \'.fmr\' \'.dmr\'})) % BrainVoyager',
    '            [s, info] = bv_file(fname);',
    '        else',
    '            info = [\'Unknown file type: \' fname];',
    '            return;',
    '        end',
    '    catch me',
    '        info = me.message;',
    '        return;',
    '    end',
    '    if ~isempty(s), return; end',
    '    if isempty(info), info = [\'Not dicom file: \' fname]; end',
    '    return; ',
    'end',
    '',
    '% This is the trick to make partial hdr faster.',
    'b = [];',
    'tag_7fe00010 = char([224 127 16 0]); % PixelData, can\'t add VR',
    'for nb = [120000 2e6 20e6 Inf] % if not enough, read more',
    '    b = [b fread(fid, nb, \'*uint8\')\']; %#ok',
    '    allRead = feof(fid);',
    '    i = strfind(char(b), tag_7fe00010);',
    '    if ~isempty(i)',
    '        break;',
    '    elseif allRead',
    '        % i = strfind(char(b), char([225 127 16 16])); % DTI tensor file',
    '        % if ~isempty(i), break; end',
    '        i = strfind(char(b), char([127 224 0 16]));',
    '        if isempty(i)',
    '            info = [\'No PixelData in \' fname]; ',
    '        else',
    '            info = [\'Likely big-endian file (not supported): \' fname]; ',
    '        end',
    '        return; ',
    '    end',
    'end',
    's.Filename = fopen(fid);',
    '',
    '% iPixelData could be in header or data. Using full hdr can correct this',
    'iPixelData = i(end); % start of PixelData tag with 132 offset',
    'b = typecast(b, \'uint16\'); % hope this makes the code faster',
    '',
    'i = 1; len = numel(b)-6; % 6 less avoid missing next tag',
    'expl = false; explVR = false; % default for truncated dicom',
    'toSearch = numel(dict.tag) < 10;',
    '',
    'if toSearch % search each tag if only a few fields',
    '    b8 = char(typecast(b, \'uint8\'));',
    '    tg = char([2 0 16 0 \'UI\']); % TransferSyntaxUID',
    '    i = (strfind(b8, tg)+1) / 2; % i for uint16',
    '    if ~isempty(i) % empty for truncated ',
    '        [dat, name] = read_item(i(1));',
    '        s.(name) = dat;',
    '        expl = ~strcmp(dat, \'1.2.840.10008.1.2\');',
    '    end',
    '    for k = 1:numel(dict.tag)',
    '        tg = char(typecast(dict.tag(k), \'uint8\'));',
    '        tg = tg([3 4 1 2]);',
    '        i = (strfind(b8, tg)+1) / 2;',
    '        if isempty(i), continue;',
    '        elseif numel(i)>1 % +1 tags found. use non-search method',
    '            if expl, tg = [tg uint8(dict.vr{k})]; end %#ok add vr',
    '            i = (strfind(b8, tg)+1) / 2;',
    '            if isempty(i), continue;',
    '            elseif numel(i)>1 % +1 tags found. use non-search method',
    '                i = 1;',
    '                toSearch = false;',
    '                break; % re-do in regular way',
    '            end',
    '        end',
    '        [dat, name, info] = read_item(i);',
    '        if isnumeric(name) || isempty(dat), continue; end',
    '        s.(name) = dat;',
    '        if strcmp(name, \'Manufacturer\') && ~strncmpi(dat, dict.vendor, 2)',
    '            updateManufacturer(dat);',
    '        end',
    '    end',
    'end',
    '',
    'while ~toSearch',
    '    if i>=len',
    '        if strcmp(name, \'PixelData\') % if PixelData in SQ/data was caught',
    '            iPixelData = iPre*2-1; % start of PixelData tag in bytes',
    '            break; % done',
    '        end',
    '        if allRead',
    '            info = [\'End of file reached: likely error: \' s.Filename];  ',
    '            break; % give up',
    '        else % in case PixelData in SQ was caught',
    '            b = [b fread(fid, inf, \'*uint16\')\']; %#ok read all',
    '            len = numel(b)-6; % update length',
    '            i = iPre; % re-do the previous item',
    '            allRead = true;',
    '        end',
    '    end',
    '    iPre = i; % backup it, also useful for PixelData',
    '    ',
    '    [dat, name, info, i, tg] = read_item(i);',
    '    if ~fullHdr && tg>dict.tag(end), break; end % done for partial hdr',
    '    if strncmp(info, \'Given up\', 8), break; end',
    '    if isnumeric(name) || isempty(dat), continue; end',
    '    s.(name) = dat;',
    '    if strcmp(name, \'Manufacturer\') && ~strncmpi(dat, dict.vendor, 2)',
    '        updateManufacturer(dat);',
    '    end',
    '    if strcmp(name, \'TransferSyntaxUID\')',
    '        expl = ~strcmp(dat, \'1.2.840.10008.1.2\'); % may be wrong for some',
    '    end',
    'end',
    '',
    'i = (iPixelData+1) / 2; % start of PixelData tag in b (uint16)',
    'if isTruncated',
    '    iPixelData = iPixelData +   7; i=i+2;',
    'elseif explVR',
    '    % s.PixelData.VR = char(typecast(b(i+2), \'uint8\'));',
    '    iPixelData = iPixelData + 143; i=i+4; % extra vr(2) + pad(2) than implicitVR',
    'else',
    '    iPixelData = iPixelData + 139; i=i+2;',
    'end',
    's.PixelData.Start = uint32(iPixelData);',
    's.PixelData.Bytes = typecast(b(i+(0:1)), \'uint32\');',
    '',
    '% if iPixelData is not right, re-do with full header',
    'if ~fullHdr',
    '    fseek(fid, 0, 1); % end of file',
    '    if ftell(fid)-s.PixelData.Start-s.PixelData.Bytes > 15 % ==0 is too strict',
    '        [s, info] = dicm_hdr(fname, [], iFrames); % full hdr',
    '        return;',
    '    end',
    'end',
    '',
    'if isfield(s, \'CSAImageHeaderInfo\') % Siemens CSA image header (slow)',
    '    s.CSAImageHeaderInfo = read_csa(s.CSAImageHeaderInfo);',
    'end',
    'if isfield(s, \'CSASeriesHeaderInfo\') % series header',
    '    s.CSASeriesHeaderInfo = read_csa(s.CSASeriesHeaderInfo);',
    'end',
    'if isfield(s, \'ProtocolDataBlock\') % GE',
    '    s.ProtocolDataBlock = read_ProtocolDataBlock(s.ProtocolDataBlock);',
    'end',
    'return;',
    '',
    '% Nested function: read dicom item. Called by dicm_hdr and read_sq',
    'function [dat, name, info, i, tag] = read_item(i)',
    'persistent len16 chDat;',
    'if isempty(len16)',
    '    len16 = \'AE AS AT CS DA DS DT FD FL IS LO LT PN SH SL SS ST TM UI UL US\';',
    '    chDat = \'AE AS CS DA DS DT IS LO LT PN SH ST TM UI UT\';',
    'end',
    'dat = []; name = nan; info = \'\'; ',
    'vr = \'CS\'; % CS for Manufacturer and TransferSyntaxUID',
    '',
    'group = b(i); i=i+1;',
    'elmnt = b(i); i=i+1;',
    'tag = uint32(group)*65536 + uint32(elmnt);',
    'if tag == 4294893581 %|| tag == 4294893789 % FFFE E00D ItemDelimitationItem',
    '    i = i+2; % skip length, in case there is another SQ Item',
    '    name = \'\';',
    '    return;',
    'end',
    '',
    'explVR = expl || group==2;',
    'if explVR, vr = char(typecast(b(i), \'uint8\')); i=i+1; end % 2-byte VR',
    '',
    'if ~explVR % implicit, length irrevalent to VR',
    '    n = typecast(b(i+(0:1)), \'uint32\'); i=i+2;',
    'elseif ~isempty(strfind(len16, vr)) % data length in uint16',
    '    n = b(i); i=i+1;',
    'else % length in uint32: skip 2 bytes',
    '    n = typecast(b(i+(1:2)), \'uint32\'); i=i+3;',
    'end',
    'if n<1, return; end % empty val',
    '',
    '% Look up item name in dictionary',
    'n = double(n)/2;',
    'ind = find(dict.tag == tag, 1);',
    'if ~isempty(ind)',
    '    name = dict.name{ind};',
    '    if strcmp(vr, \'UN\') || strcmp(vr, \'OB\') || ~explVR, vr = dict.vr{ind}; end',
    'elseif tag==524400 % in case not in dict',
    '    name = \'Manufacturer\';',
    'elseif tag==131088 % can\'t skip TransferSyntaxUID even if not in dict',
    '    name = \'TransferSyntaxUID\';',
    'elseif fullHdr',
    '    if elmnt==0, i=i+n; return; end % skip GroupLength',
    '    if mod(group, 2), name = sprintf(\'Private_%04x_%04x\', group, elmnt);',
    '    else              name = sprintf(\'Unknown_%04x_%04x\', group, elmnt);',
    '    end',
    '    if ~explVR, vr = \'UN\'; end',
    'elseif n<2147483647.5 % no skip for SQ with length 0xffffffff',
    '    i=i+n; return;',
    'end',
    '% compressed PixelData, n can be 0xffffffff',
    'if ~explVR && n==2147483647.5, vr = \'SQ\'; end % best guess',
    'if (n+i>len) && (~strcmp(vr, \'SQ\')), i = i+n; return; end % re-do',
    '% fprintf(\'(%04x %04x) %s %g %s\\n\', group, elmnt, vr, n*2, name);',
    '',
    '% Decode data length and type of an item by VR',
    'if ~isempty(strfind(chDat, vr)) % char data',
    '    dat = deblank(char(typecast(b(i+(0:n-1)), \'uint8\'))); i=i+n;',
    '    if strcmp(vr, \'DS\') || strcmp(vr, \'IS\')',
    '        dat = sscanf(dat, \'%f%*c\'); % like 1\\2\\3',
    '    end',
    'elseif strcmp(vr, \'SQ\')',
    '    isPerFrameSQ = strcmp(name, \'PerFrameFunctionalGroupsSequence\');',
    '    [dat, info, i] = read_sq(i, min(i+n,len), isPerFrameSQ);',
    'else % numeric data, or UN',
    '    fmt = vr2format(vr);',
    '    if isempty(fmt)',
    '        info = sprintf(\'Given up: Invalid VR (%d %d) for %s\', vr, name);',
    '        fprintf(2, \' %s\\n\', info);',
    '    else',
    '        dat = typecast(b(i+(0:n-1)), fmt)\'; i=i+n;',
    '    end',
    'end',
    'end % nested func',
    '',
    '% Nested function: decode SQ, called by read_item (recursively)',
    'function [rst, info, i] = read_sq(i, nEnd, isPerFrameSQ)',
    'rst = []; info = \'\'; j = 0; % j is frame index',
    '',
    'while i<nEnd',
    '    tag = typecast(b(i+(0:1)), \'uint32\'); i=i+2;',
    '    n = typecast(b(i+(0:1)), \'uint32\'); i=i+2; % n may be 0xffff ffff',
    '    if tag ~= 3758161918, return; end % only do FFFE E000, Item',
    '    if isPerFrameSQ && ~ischar(iFrames)',
    '        if j==0, i0 = i; j = 1; % always read 1st frame',
    '        elseif j==1 % always read 2nd frame, and find ind for all frames',
    '            j = 2; iItem = 2;',
    '            tag1 = char(typecast(tag1, \'uint8\'));',
    '            tag1 = tag1([3 4 1 2]);',
    '            ind = strfind(char(typecast(b(i0:(iPixelData+1)/2), \'uint8\')), tag1);',
    '            ind = (ind-1)/2 + i0;',
    '            nInd = numel(ind);',
    '            if isfield(s, \'NumberOfFrames\') && nInd~=s.NumberOfFrames',
    '                tag1PerF = nInd / s.NumberOfFrames;',
    '                if mod(tag1PerF, 1)>0 % not integer, read all frames',
    '                    iFrames = \'all\'; rst = []; j = 0; i = i0-4; % re-do the SQ',
    '                    fprintf(2, [\'Failed to determine indice for frames. \' ...',
    '                        \'Will read all frames.\\nFile: %s\\n\'], s.Filename);',
    '                    continue;',
    '                elseif tag1PerF>1 % more than one ind for each frame',
    '                    ind = ind(1:tag1PerF:nInd);',
    '                    nInd = s.NumberOfFrames;',
    '                end',
    '            end',
    '            iFrames = unique([1 2 round(iFrames) nInd]);',
    '        else',
    '            iItem = iItem + 1;',
    '            j = iFrames(iItem);',
    '            i = ind(j); % start of tag1 for a frame',
    '        end',
    '    else',
    '        j = j + 1;',
    '    end',
    '    ',
    '    Item_n = sprintf(\'Item_%g\', j);',
    '    n = min(i+double(n)/2, nEnd);',
    '    ',
    '    while i<n',
    '        [dat1, name1, info, i, tag] = read_item(i);',
    '        if isnumeric(name1), continue; end % 0-length or skipped item',
    '        if tag == 4294893581, break; end % FFFE E00D ItemDelimitationItem',
    '        if isempty(dat1), continue; end',
    '        if isempty(rst), tag1 = tag; end % first wanted tag in SQ',
    '        rst.(Item_n).(name1) = dat1;',
    '    end',
    'end',
    'end % nested func',
    '',
    'function updateManufacturer(vendor)',
    '    dict_full = dicm_dict(vendor); % update vendor',
    '    if ~fullHdr && isfield(dict, \'fields\')',
    '        dict = dicm_dict(vendor, dict.fields);',
    '    else',
    '        dict = dict_full;',
    '    end',
    'end',
    '',
    'end % main func',
    '',
    '% subfunction: return format str for typecast according to VR',
    'function fmt = vr2format(vr)',
    'switch vr ',
    '    case \'OB\', fmt = \'uint8\';',
    '    case \'UN\', fmt = \'uint8\';',
    '    case \'AT\', fmt = \'uint16\';',
    '    case \'OW\', fmt = \'uint16\';',
    '    case \'US\', fmt = \'uint16\';',
    '    case \'SS\', fmt = \'int16\'; ',
    '    case \'UL\', fmt = \'uint32\';',
    '    case \'SL\', fmt = \'int32\';',
    '    case \'FL\', fmt = \'single\'; ',
    '    case \'FD\', fmt = \'double\';',
    '    otherwise, fmt = \'\';',
    'end',
    'end',
    '',
    '% subfunction: decode Siemens CSA image and series header',
    'function csa = read_csa(csa)',
    'b = csa\';',
    'if ~strcmp(char(b(1:4)), \'SV10\'), return; end % no op if not SV10',
    'chDat = \'AE AS CS DA DT LO LT PN SH ST TM UI UN UT\';',
    'i = 8; % \'SV10\' 4 3 2 1',
    'try %#ok in case of error, we return the original uint8',
    '    nField = typecast(b(i+(1:4)), \'uint32\'); i=i+8;',
    '    for j = 1:nField',
    '        i=i+68; % name(64) and vm(4)',
    '        vr = char(b(i+(1:2))); i=i+8; % vr(4), syngodt(4)',
    '        n = typecast(b(i+(1:4)), \'int32\'); i=i+8;',
    '        if n<1, continue; end % skip name decoding, faster',
    '        ind = find(b(i-84+(1:64))==0, 1) - 1;',
    '        name = char(b(i-84+(1:ind)));',
    '        % fprintf(\'%s %3g %s\\n\', vr, n, name);',
    '',
    '        dat = [];',
    '        for k = 1:n % n is often 6, but often only the first contains value',
    '            len = typecast(b(i+(1:4)), \'int32\'); i=i+16;',
    '            if len<1, i = i+double(n-k)*16; break; end % rest are empty too',
    '            foo = char(b(i+(1:len-1))); % exclude nul, need for Octave',
    '            i = i + ceil(double(len)/4)*4; % multiple 4-byte',
    '            if isempty(strfind(chDat, vr))',
    '                tmp = str2double(foo);',
    '                if isnan(tmp), continue; end',
    '                dat(end+1, 1) = tmp; %#ok numeric to double',
    '            else',
    '                dat{end+1, 1} = deblank(foo); %#ok',
    '            end',
    '        end',
    '        if iscellstr(dat) && length(dat)<2, dat = dat{1}; end',
    '        if ~isempty(dat), rst.(name) = dat; end',
    '    end',
    '    csa = rst;',
    'end',
    'end',
    '',
    '% subfunction: decode GE ProtocolDataBlock',
    'function ch = read_ProtocolDataBlock(ch)',
    'n = typecast(ch(1:4), \'int32\') + 4; % nBytes, zeros may be padded to make 4x',
    'if ~all(ch(5:6) == [31 139]\') || n>numel(ch), return; end % gz signature',
    '',
    'b = gunzip_mem(ch(5:n));',
    'if isempty(b), return; end % guzip faild, we give up',
    'b = char(b\');',
    '',
    'try %#ok',
    '    i = 1; n = numel(b);',
    '    while i<n',
    '        nam = strtok(b(i:n), \' "\'); i = i + numel(nam) + 2; % VIEWORDER "1"',
    '        val = strtok(b(i:n),  \'"\'); i = i + numel(val) + 2;',
    '        if strcmp(val(end), \';\'), val(end) = []; end',
    '        foo = str2double(val);',
    '        if ~isnan(foo), val = foo; end % convert into num if possible',
    '        rst.(nam) = val;',
    '    end',
    '    ch = rst;',
    'end',
    'end',
    '',
    '%% subfunction: read PAR file, return struct like that from dicm_hdr.',
    'function [s, err] = philips_par(fname)',
    'err = \'\';',
    'if numel(fname)>4 && strcmpi(fname(end+(-3:0)), \'.REC\')',
    '    fname(end+(-3:0)) = \'.PAR\';',
    '    if ~exist(fname, \'file\'), fname(end+(-3:0)) = \'.par\'; end',
    'end',
    'fid = fopen(fname);',
    'if fid<0, s = []; err = [\'File not exist: \' fname]; return; end',
    'str = fread(fid, inf, \'*char\')\'; % read all as char',
    'fname = fopen(fid); % name with full path',
    'fclose(fid);',
    '',
    'str = strrep(str, char(13), char(10)); % make carriage return single char(10)',
    'while true',
    '    ind = strfind(str, char([10 10]));',
    '    if isempty(ind), break; end',
    '    str(ind) = []; ',
    'end',
    '',
    '% In V4, offcentre and Angulation labeled as y z x, but actually x y z. We',
    '% try not to use these info',
    'key = \'image export tool\';',
    'i = strfind(lower(str), key) + numel(key);',
    'if isempty(i), err = \'Not PAR file\'; s = []; return; end',
    'C = textscan(str(i:end), \'%s\', 1);',
    's.SoftwareVersion = C{1}{1};',
    'if strncmpi(s.SoftwareVersion, \'V3\', 2)',
    '    err = \'V3 PAR file is not supported\';',
    '    fprintf(2, \' %s.\\n\', err);',
    '    s = []; return;',
    'end',
    '',
    '% s.IsPhilipsPAR = true;',
    's.PatientName = par_key(\'Patient name\', \'%c\');',
    's.StudyDescription = par_key(\'Examination name\', \'%c\');',
    '[pth, nam] = fileparts(fname);',
    's.SeriesDescription = nam;',
    's.ProtocolName = par_key(\'Protocol name\', \'%c\');',
    'foo = par_key(\'Examination date/time\', \'%s\');',
    'foo = foo(isstrprop(foo, \'digit\'));',
    's.AcquisitionDateTime = foo;',
    '% s.SeriesType = strkey(str, \'Series Type\', \'%c\');',
    's.SeriesNumber = par_key(\'Acquisition nr\');',
    's.SeriesInstanceUID = sprintf(\'%g.%s.%09.0f\', s.SeriesNumber, ...',
    '    datestr(now, \'yymmdd.HHMMSS.fff\'), rand*1e9);',
    '% s.SamplesPerPixel = 1; % make dicm2nii.m happy',
    '% s.ReconstructionNumberMR = strkey(str, \'Reconstruction nr\', \'%g\');',
    '% s.MRSeriesScanDuration = strkey(str, \'Scan Duration\', \'%g\');',
    's.NumberOfEchoes = par_key(\'Max. number of echoes\');',
    'nSL = par_key(\'Max. number of slices/locations\');',
    's.LocationsInAcquisition = nSL;',
    's.NumberOfTemporalPositions = par_key(\'Max. number of dynamics\');',
    'foo = par_key(\'Patient position\', \'%c\');',
    'if isempty(foo), foo = par_key(\'Patient Position\', \'%c\'); end',
    'if ~isempty(foo)',
    '    if numel(foo)>4, s.PatientPosition = foo(regexp(foo, \'\\<.\')); ',
    '    else s.PatientPosition = foo; ',
    '    end',
    'end',
    's.MRAcquisitionType = par_key(\'Scan mode\', \'%s\');',
    's.ScanningSequence = par_key(\'Technique\', \'%s\'); % ScanningTechnique',
    's.ImageType = [\'PhilipsPAR\\\' s.ScanningSequence];',
    '% foo = strkey(str, \'Scan resolution\', \'%g\'); % before reconstruction',
    '% s.AcquisitionMatrix = [foo(1) 0 0 foo(2)]\'; % depend on slice ori',
    's.RepetitionTime = par_key(\'Repetition time\');',
    '% FOV = par_key(\'FOV\'); % (ap,fh,rl) [mm] ',
    '% FOV = FOV([3 1 2]); % x y z',
    's.WaterFatShift = par_key(\'Water Fat shift\');',
    'rotAngle = par_key(\'Angulation midslice\'); % (ap,fh,rl) deg',
    'rotAngle = rotAngle([3 1 2]);',
    'posMid = par_key(\'Off Centre midslice\'); % (ap,fh,rl) [mm]',
    's.Stack.Item_1.MRStackOffcentreAP = posMid(1);',
    's.Stack.Item_1.MRStackOffcentreFH = posMid(2);',
    's.Stack.Item_1.MRStackOffcentreRL = posMid(3);',
    'posMid = posMid([3 1 2]); % better precision than those in the table',
    'if par_key(\'MTC\') % motion correction?',
    '    s.ImageType = [s.ImageType \'\\MOCO\\\'];',
    'end',
    's.EPIFactor = par_key(\'EPI factor\');',
    '% s.DynamicSeries = strkey(str, \'Dynamic scan\', \'%g\'); % 0 or 1',
    'isDTI = par_key(\'Diffusion\')>0;',
    'if isDTI',
    '    s.ImageType = [s.ImageType \'\\DIFFUSION\\\'];',
    '    s.DiffusionEchoTime = par_key(\'Diffusion echo time\'); % ms',
    'end',
    '',
    'foo = par_key(\'Preparation direction\', \'%s\'); % Anterior-Posterior',
    'if ~isempty(foo)',
    '    foo = foo(regexp(foo, \'\\<.\')); % \'AP\'',
    '    s.Stack.Item_1.MRStackPreparationDirection = foo;',
    '    iPhase = strfind(\'LRAPFH\', foo(1));',
    '    iPhase = ceil(iPhase/2); % 1/2/3',
    'end',
    '',
    '% Get list of para meaning for the table, and col index of each para',
    'i1 = strfind(str, \'= IMAGE INFORMATION DEFINITION =\'); i1 = i1(end);',
    'ind = strfind(str(i1:end), [char(10) \'#\']) + i1;',
    'for i = 1:9 % find the empty line before column descrip',
    '    [~, foo] = strtok(str(ind(i):ind(i+1)-2)); % remove # and char(10)',
    '    if isempty(foo), break; end ',
    'end',
    'j = 1; ',
    'for i = i+1:numel(ind)',
    '    [~, foo] = strtok(str(ind(i):ind(i+1)-2));',
    '    if isempty(foo), break; end % the end of the col label',
    '    foo = strtrim(foo);',
    '    i3 = strfind(foo, \'<\');',
    '    i2 = strfind(foo, \'(\');',
    '    if isempty(i3), i3 = i2(1); end',
    '    colLabel{j} = strtrim(foo(1:i3(1)-1)); %#ok para name',
    '    nCol = sscanf(foo(i2(end)+1:end), \'%g\');',
    '    if isempty(nCol), nCol = 1; end',
    '    iColumn(j) = nCol; %#ok number of columns in the table for this para',
    '    j = j + 1;',
    'end',
    'iColumn = cumsum([1 iColumn]); % col start ind for corresponding colLabel',
    'keyInLabel = @(key)strcmp(colLabel, key);',
    'colIndex = @(key)iColumn(keyInLabel(key));',
    '',
    'i1 = strfind(str, \'= IMAGE INFORMATION =\'); i1 = i1(end);',
    'ind = strfind(str(i1:end), char(10)) + i1 + 1; % start of a line',
    'for i = 1:9',
    '    foo = sscanf(str(ind(i):end), \'%g\', 1);',
    '    if ~isempty(foo), break; end % get the first number',
    'end',
    'while str(ind(i))==10, i = i+1; end % skip empty lines (only one)',
    'str = str(ind(i):end); % now start of the table',
    'i1 = strfind(str, char(10));',
    'para = sscanf(str(1:i1(1)), \'%g\'); % 1st row',
    'n = numel(para); % number of items each row, 41 for V4',
    'para = sscanf(str, \'%g\'); % read all numbers',
    'nImg = floor(numel(para) / n); ',
    'para = reshape(para(1:n*nImg), n, nImg)\'; % whole table now',
    's.NumberOfFrames = nImg;',
    '',
    's.Dim3IsVolume = (diff(para(1:2, colIndex(\'slice number\'))) == 0);',
    'if s.Dim3IsVolume, iVol = 1:(nImg/nSL);',
    'else iVol = 1:nSL:nImg;',
    'end',
    '',
    'imgType = para(iVol, colIndex(\'image_type_mr\')); % 0 mag; 3, phase?',
    'if any(diff(imgType) ~= 0) % more than 1 type of image',
    '    s.ComplexImageComponent = \'MIXED\';',
    '    s.VolumeIsPhase = (imgType==3); % one for each vol',
    '    s.LastFile.RescaleIntercept = para(end, colIndex(\'rescale intercept\'));',
    '    s.LastFile.RescaleSlope = para(end, colIndex(\'rescale slope\'));',
    'elseif imgType(1)==0, s.ComplexImageComponent = \'MAGNITUDE\';',
    'elseif imgType(1)==3, s.ComplexImageComponent = \'PHASE\';',
    'end',
    '',
    '% These columns should be the same for all images: ',
    'cols = {\'image pixel size\' \'recon resolution\' \'image angulation\' ...',
    '    \'slice thickness\' \'slice gap\' \'slice orientation\' \'pixel spacing\'};',
    'if ~strcmp(s.ComplexImageComponent, \'MIXED\')',
    '    cols = [cols {\'rescale intercept\' \'rescale slope\'}];',
    'end',
    'ind = [];',
    'for i = 1:numel(cols)',
    '    j = find(keyInLabel(cols{i}));',
    '    if isempty(j), continue; end',
    '    ind = [ind iColumn(j):iColumn(j+1)-1]; %#ok',
    'end',
    'foo = para(:, ind);',
    'foo = abs(diff(foo));',
    'if any(foo(:) > 1e-5)',
    '    err = sprintf(\'Inconsistent image size, bits etc: %s\', fname);',
    '    fprintf(2, \' %s. \\n\', err);',
    '    s = []; return;',
    'end',
    '',
    '% getTableVal(\'echo number\', \'EchoNumber\', 1:nImg);',
    '% getTableVal(\'dynamic scan number\', \'TemporalPositionIdentifier\', 1:nImg);',
    'getTableVal(\'image pixel size\', \'BitsAllocated\');',
    'getTableVal(\'recon resolution\', \'Columns\');',
    's.Rows = s.Columns(2); s.Columns = s.Columns(1);',
    'getTableVal(\'rescale intercept\', \'RescaleIntercept\');',
    'getTableVal(\'rescale slope\', \'RescaleSlope\');',
    'getTableVal(\'window center\', \'WindowCenter\', 1:nImg);',
    'getTableVal(\'window width\', \'WindowWidth\', 1:nImg);',
    'mx = max(s.WindowCenter + s.WindowWidth/2);',
    'mn = min(s.WindowCenter - s.WindowWidth/2);',
    's.WindowCenter = round((mx+mn)/2);',
    's.WindowWidth = ceil(mx-mn);',
    'getTableVal(\'slice thickness\', \'SliceThickness\');',
    'getTableVal(\'echo_time\', \'EchoTime\');',
    '% getTableVal(\'dyn_scan_begin_time\', \'TimeOfAcquisition\', 1:nImg);',
    'if isDTI',
    '    getTableVal(\'diffusion_b_factor\', \'B_value\', iVol);',
    '    fld = \'bvec_original\';',
    '    getTableVal(\'diffusion\', fld, iVol);',
    '    if isfield(s, fld), s.(fld) = s.(fld)(:, [3 1 2]); end',
    'end',
    'getTableVal(\'TURBO factor\', \'TurboFactor\');',
    '',
    '% Rotation order and signs are figured out by try and err, not 100% sure',
    'ca = cosd(rotAngle); sa = sind(rotAngle);',
    'rx = [1 0 0; 0 ca(1) -sa(1); 0 sa(1) ca(1)]; % 3D rotation',
    'ry = [ca(2) 0 sa(2); 0 1 0; -sa(2) 0 ca(2)];',
    'rz = [ca(3) -sa(3) 0; sa(3) ca(3) 0; 0 0 1];',
    'R = rx * ry * rz; % seems right for Philips',
    '',
    'getTableVal(\'slice orientation\', \'SliceOrientation\'); % 1/2/3 for TRA/SAG/COR',
    'iOri = mod(s.SliceOrientation+1, 3) + 1; % [1 2 3] to [3 1 2]',
    'if iOri == 1 % Sag',
    '    s.SliceOrientation = \'SAGITTAL\';',
    '    ixyz = [2 3 1];',
    '    R(:,[1 3]) = -R(:,[1 3]); % change col sign according to iOri',
    'elseif iOri == 2 % Cor',
    '    s.SliceOrientation = \'CORONAL\';',
    '    ixyz = [1 3 2];',
    '    R(:,3) = -R(:,3);',
    'else % Tra',
    '    s.SliceOrientation = \'TRANSVERSAL\';',
    '    ixyz = [1 2 3];',
    'end',
    '% bad precision for some PAR, \'pixel spacing\' and \'slice gap\', but it is wrong',
    '% to use FOV, maybe due to partial Fourier?',
    'getTableVal(\'pixel spacing\', \'PixelSpacing\');',
    's.PixelSpacing = s.PixelSpacing(:);',
    'getTableVal(\'slice gap\', \'SpacingBetweenSlices\');',
    '',
    's.SpacingBetweenSlices = s.SpacingBetweenSlices + s.SliceThickness;',
    '% s.PixelSpacing = FOV(ixyz(1:2)) ./ [s.Columns s.Rows]\';',
    '% s.SpacingBetweenSlices = FOV(ixyz(3)) ./ nSL;',
    '',
    'if exist(\'iPhase\', \'var\')',
    '    foo = \'COL\';',
    '    if iPhase == ixyz(1), foo = \'ROW\'; end',
    '    s.InPlanePhaseEncodingDirection = foo;',
    'end',
    '',
    'R = R(:, ixyz); % dicom rotation matrix',
    's.ImageOrientationPatient = R(1:6)\';',
    'R = R * diag([s.PixelSpacing; s.SpacingBetweenSlices]);',
    'R = [R posMid; 0 0 0 1]; % 4th col is mid slice center position',
    '% x = ([s.Columns s.Rows nSL] -1) / 2; % some V4.2 seem to use this',
    'x = [s.Columns s.Rows nSL-1] / 2; % ijk of mid slice center ',
    '',
    'c0 = R(iOri,3:4) * [-x(3) 1]\'; % 1st slice center loc based on current slice dir',
    'if sign(R(iOri,3)) ~= sign(posMid(iOri)-c0)',
    '    R(:,3) = -R(:,3);',
    'end',
    '',
    'R(:,4) = R * [-x 1]\'; % dicom xform matrix',
    'y = R * [0 0 nSL-1 1]\'; % last slice position',
    's.ImagePositionPatient = R(1:3,4);',
    's.LastFile.ImagePositionPatient = y(1:3);',
    's.Manufacturer = \'Philips\';',
    's.Filename = fullfile(pth, [nam \'.REC\']); % for dicm_img',
    's.PixelData.Start = 0; % for dicm_img.m',
    's.PixelData.Bytes = s.Rows * s.Columns * nImg * s.BitsAllocated / 8;',
    '',
    '    % nested function: set field if the key is in colTable',
    '    function getTableVal(key, fldname, iRow)',
    '        if nargin<3, iRow = 1; end',
    '        iCol = find(keyInLabel(key));',
    '        if isempty(iCol), return; end',
    '        s.(fldname) = para(iRow, iColumn(iCol):iColumn(iCol+1)-1);',
    '    end',
    '',
    '    % nested subfunction: return value specified by key in PAR file',
    '    function val = par_key(key, fmt)',
    '        if nargin<2 || isempty(fmt), fmt = \'%g\';  end',
    '        i1 = regexp(str, [\'\\n.\\s{1,}\' key \'\\s{0,}[(<\\[:]\']);',
    '        if isempty(i1)',
    '            if strcmp(fmt, \'%g\'), val = [];',
    '            else val = \'\';',
    '            end',
    '            return; ',
    '        end',
    '        i1 = i1(1) + 1; % skip \'\\n\'',
    '        i2 = find(str(i1:end)==char(10), 1, \'first\') + i1 - 2;',
    '        ln = str(i1:i2); % the line',
    '        i1 = strfind(ln, \':\') + 1;',
    '        val = sscanf(ln(i1(1):end), fmt); % convert based on fmt, re-use fmt',
    '        if isnumeric(val), val = double(val);',
    '        else val = strtrim(val);',
    '        end',
    '    end',
    'end',
    '',
    '%% subfunction: read AFNI HEAD file, return struct like that from dicm_hdr.',
    'function [s, err] = afni_head(fname)',
    'persistent SN;',
    'if isempty(SN), SN = 1; end',
    'err = \'\';',
    'if numel(fname)>5 && strcmp(fname(end+(-4:0)), \'.BRIK\')',
    '    fname(end+(-4:0)) = \'.HEAD\';',
    'end',
    'fid = fopen(fname);',
    'if fid<0, s = []; err = [\'File not exist: \' fname]; return; end',
    'str = fread(fid, inf, \'*char\')\';',
    'fname = fopen(fid);',
    'fclose(fid);',
    '',
    'i = strfind(str, \'DATASET_DIMENSIONS\');',
    'if isempty(i), s = []; err = \'Not brik header file\'; return; end',
    '',
    '% these make dicm_nii.m happy',
    '[~, foo] = fileparts(fname);',
    '% s.IsAFNIHEAD = true;',
    's.ProtocolName = foo;',
    's.SeriesNumber = SN; SN = SN+1; % make it unique for multilple files',
    's.SeriesInstanceUID = sprintf(\'%g.%s.%09.0f\', s.SeriesNumber, ...',
    '    datestr(now, \'yymmdd.HHMMSS.fff\'), rand*1e9);',
    's.ImageType = [\'AFNIHEAD\\\' afni_key(\'TYPESTRING\')];',
    '',
    'foo = afni_key(\'BYTEORDER_STRING\');',
    'if strcmp(foo(1), \'M\'), err = \'BYTEORDER_STRING not supported\'; s = []; return; end',
    '',
    'foo = afni_key(\'BRICK_FLOAT_FACS\');',
    'if any(diff(foo)~=0), err = \'Inconsistent BRICK_FLOAT_FACS\'; ',
    '    s = []; return; ',
    'end',
    'if foo(1)==0, foo = 1; end',
    's.RescaleSlope = foo(1);',
    's.RescaleIntercept = 0;',
    '',
    'foo = afni_key(\'BRICK_TYPES\');',
    'if any(diff(foo)~=0), err = \'Inconsistent DataType\'; s = []; return; end',
    'foo = foo(1);',
    'if foo == 0',
    '    s.BitsAllocated =  8; s.PixelData.Format = \'*uint8\';',
    'elseif foo == 1',
    '    s.BitsAllocated = 16; s.PixelData.Format = \'*int16\';',
    'elseif foo == 3',
    '    s.BitsAllocated = 32; s.PixelData.Format = \'*single\';',
    'else',
    '    error(\'Unsupported BRICK_TYPES: %g\', foo);',
    'end',
    '',
    'hist = afni_key(\'HISTORY_NOTE\');',
    'i = strfind(hist, \'Time:\') + 6;',
    'if ~isempty(i)',
    '    dat = sscanf(hist(i:end), \'%11c\', 1); % Mar  1 2010',
    '    dat = datenum(dat, \'mmm dd yyyy\');',
    '    s.AcquisitionDateTime = datestr(dat, \'yyyymmdd\');',
    'end',
    'i = strfind(hist, \'Sequence:\') + 9;',
    'if ~isempty(i), s.ScanningSequence = strtok(hist(i:end), \' \'); end',
    'i = strfind(hist, \'Studyid:\') + 8;',
    'if ~isempty(i), s.StudyID = strtok(hist(i:end), \' \'); end',
    '% i = strfind(hist, \'Dimensions:\') + 11;',
    '% if ~isempty(i)',
    '%     dimStr = strtok(hist(i:end), \' \') % 64x64x35x92',
    '% end',
    '% i = strfind(hist, \'Orientation:\') + 12;',
    '% if ~isempty(i)',
    '%     oriStr = strtok(hist(i:end), \' \') % LAI',
    '% end',
    'i = strfind(hist, \'TE:\') + 3;',
    'if ~isempty(i), s.EchoTime = sscanf(hist(i:end), \'%g\', 1) * 1000; end',
    '',
    '% foo = afni_key(\'TEMPLATE_SPACE\'); % ORIG/TLRC',
    '% INT_CMAP',
    'foo = afni_key(\'SCENE_DATA\');',
    's.TemplateSpace = foo(1)+1; %[0] 0=+orig, 1=+acpc, 2=+tlrc',
    'if foo(2)==9, s.ImageType = [s.ImageType \'\\DIFFUSION\\\']; end',
    '% ori = afni_key(\'ORIENT_SPECIFIC\')+1;',
    '% orients = [1 -1 -2 2 3 -3]; % RL LR PA AP IS SI',
    '% ori = orients(ori) % in dicom/afni LPS, ',
    '% seems always [1 2 3], meaning AFNI re-oriented the volome',
    '',
    '% no read/phase/slice dim info, so following 3D info are meaningless',
    'dim = afni_key(\'DATASET_DIMENSIONS\');',
    's.Columns = dim(1); s.Rows = dim(2); s.LocationsInAcquisition = dim(3);',
    'R = afni_key(\'IJK_TO_DICOM_REAL\'); % IJK_TO_DICOM is always straight?',
    'if isempty(R), R = afni_key(\'IJK_TO_DICOM\'); end',
    'R = reshape(R, [4 3])\';',
    's.ImagePositionPatient = R(:,4); % afni_key(\'ORIGIN\') can be wrong',
    'y = [R; 0 0 0 1] * [0 0 dim(3)-1 1]\';',
    's.LastFile.ImagePositionPatient = y(1:3);',
    'R = R(1:3, 1:3);',
    'R = R ./ (ones(3,1) * sqrt(sum(R.^2)));',
    's.ImageOrientationPatient = R(1:6)\';',
    'foo = afni_key(\'DELTA\');',
    's.PixelSpacing = foo(1:2);',
    '% s.SpacingBetweenSlices = foo(3);',
    's.SliceThickness = foo(3);',
    'foo = afni_key(\'BRICK_STATS\');',
    'foo = reshape(foo, [2 numel(foo)/2]);',
    'mn = min(foo(1,:)); mx = max(foo(2,:));',
    's.WindowCenter = (mx+mn)/2;',
    's.WindowWidth = mx-mn;',
    'foo = afni_key(\'TAXIS_FLOATS\'); %[0]:0; ',
    'if ~isempty(foo), s.RepetitionTime = foo(2)*1000; end',
    '',
    'foo = afni_key(\'TAXIS_NUMS\'); % [0]:nvals; [1]: 0 or nSL normally',
    'if ~isempty(foo)',
    '    inMS = foo(3)==77001;',
    '    foo = afni_key(\'TAXIS_OFFSETS\');',
    '    if inMS, foo = foo/1000; end',
    '    if ~isempty(foo), s.MosaicRefAcqTimes = foo; end',
    'end',
    '',
    'foo = afni_key(\'DATASET_RANK\'); % [3 nvals]',
    'dim(4) = foo(2);',
    's.NumberOfTemporalPositions = dim(4);',
    '% s.NumberOfFrames = dim(4)*dim(3);',
    ' ',
    's.Manufacturer = \'\';',
    's.Filename = strrep(fname, \'.HEAD\', \'.BRIK\');',
    's.PixelData.Start = 0; % make it work for dicm_img.m',
    's.PixelData.Bytes = prod(dim(1:4)) * s.BitsAllocated / 8;',
    '',
    '    % subfunction: return value specified by key in afni header str',
    '    function val = afni_key(key)',
    '    i1 = regexp(str, [\'\\nname\\s{0,}=\\s{0,}\' key \'\\n\']); % line \'name = key\'',
    '    if isempty(i1), val = []; return; end',
    '    i1 = i1(1) + 1;',
    '    i2 = regexp(str(1:i1), \'type\\s{0,}=\\s{0,}\\w*-attribute\\n\');',
    '    keyType = sscanf(str(i2(end):i1), \'type%*c=%*c%s\', 1); %\'string-attribute\'',
    '    i1 = find(str(i1:end)==char(10), 1, \'first\') + i1;',
    '    count = sscanf(str(i1:end), \'count%*c=%*c%g\', 1);',
    '    if strcmp(keyType, \'string-attribute\')',
    '        i1 = find(str(i1:end)==\'\'\'\', 1, \'first\') + i1;',
    '        val = str(i1+(0:count-2));',
    '    else',
    '        i1 = find(str(i1:end)==char(10), 1, \'first\') + i1;',
    '        val = sscanf(str(i1:end), \'%g\', count);',
    '    end',
    '    end',
    'end',
    '',
    '%% gunzip data in memory if possible.',
    '% For a GE ProtocolDataBlock, memory / file approaches take 0.5 / 43 ms.',
    '% When gz_bytes is large, pigz will be faster. The reversing point is about 8M.',
    'function bytes = gunzip_mem(gz_bytes)',
    'bytes = [];',
    'try',
    '    import com.mathworks.mlwidgets.io.*',
    '    streamCopier = InterruptibleStreamCopier.getInterruptibleStreamCopier;',
    '    baos = java.io.ByteArrayOutputStream;',
    '    b = typecast(gz_bytes, \'int8\');',
    '    bais = java.io.ByteArrayInputStream(b);',
    '    gzis = java.util.zip.GZIPInputStream(bais);',
    '    streamCopier.copyStream(gzis, baos);',
    '    bytes = typecast(baos.toByteArray, \'uint8\'); % int8 to uint8',
    'catch',
    '    try %#ok',
    '        tmp = tempname; % temp gz file',
    '        fid = fopen([tmp \'.gz\'], \'w\');',
    '        if fid<0, return; end',
    '        cln = onCleanup(@() delete([tmp \'*\'])); % delete gz and unziped files',
    '        fwrite(fid, gz_bytes, \'uint8\');',
    '        fclose(fid);',
    '        ',
    '        gunzipOS = nii_tool(\'func_handle\', \'gunzipOS\');',
    '        gunzipOS([tmp \'.gz\']);',
    '        ',
    '        fid = fopen(tmp);',
    '        bytes = fread(fid, \'*uint8\');',
    '        fclose(fid);',
    '    end',
    'end',
    'end',
    '',
    '%% Subfunction: read BrainVoyager vmr/fmr/dmr. Call BVQXfile',
    'function [s, err] = bv_file(fname)',
    's = []; err = \'\';',
    'try ',
    '    bv = BVQXfile(fname);',
    'catch me',
    '    err = me.message;',
    '    if strfind(me.identifier, \'UndefinedFunction\')',
    '        fprintf(2, \'Please download BVQXtools at \\n%s\\n\', ...',
    '        \'http://support.brainvoyager.com/available-tools/52-matlab-tools-bvxqtools.html\');',
    '    end',
    '    return;',
    'end',
    '',
    'if ~isempty(bv.Trf)',
    '    for i = 1:length(bv.Trf)',
    '        if ~isequal(diag(bv.Trf(i).TransformationValues), [1 1 1 1]\')',
    '            err = \'Data has been transformed: skipped.\';',
    '            return;',
    '        end',
    '    end',
    'end',
    '',
    'persistent SN subj folder % folder is used to update subj',
    'if isempty(SN), SN = 1; subj = \'\'; folder = \'\'; end',
    's.Filename = bv.FilenameOnDisk;',
    'fType = bv.filetype;',
    's.ImageType = [\'BrainVoyagerFile\\\' fType];',
    '',
    '% Find a fmr/dmr, and get subj based on dicom file name in BV format.',
    '% Suppose BV files in the folder are for the same subj',
    '[pth, nam] = fileparts(s.Filename);',
    's.SeriesDescription = nam;',
    'if isempty(folder) || ~strcmp(folder, pth)',
    '    folder = pth;',
    '    subj = \'\';',
    '    if strcmp(fType, \'fmr\') || strcmp(fType, \'dmr\')',
    '        [~, nam] = fileparts(bv.FirstDataSourceFile);',
    '        nam = strtok(nam, \'-\');',
    '        if ~isempty(nam), subj = nam; end',
    '    else',
    '        fnames = dir([pth \'/*.fmr\']);',
    '        if isempty(fnames), fnames = dir([pth \'/*.dmr\']); end',
    '        if ~isempty(fnames)',
    '            bv1 = BVQXfile(fullfile(pth, fnames(1).name));',
    '            [~, nam] = fileparts(bv1.FirstDataSourceFile);',
    '            bv1.ClearObject;',
    '            nam = strtok(nam, \'-\');',
    '            if ~isempty(nam), subj = nam; end',
    '        end',
    '    end',
    'end',
    'if ~isempty(subj), s.PatientName = subj; end',
    '',
    's.Columns = bv.NCols;',
    's.Rows = bv.NRows;',
    's.SliceThickness = bv.SliceThickness;',
    'R = [bv.RowDirX bv.RowDirY bv.RowDirZ; bv.ColDirX bv.ColDirY bv.ColDirZ]\';',
    's.ImageOrientationPatient = R(:);',
    'R(:,3) = cross(R(:,1), R(:,2));',
    '[~, ixyz] = max(abs(R)); iSL =ixyz(3);',
    '',
    'try ',
    '    s.TemplateSpace = bv.ReferenceSpace; % 0/2/3: Scanner/ACPC/TAL',
    '    if s.TemplateSpace==0, s.TemplateSpace = 1; end',
    'catch',
    '    s.TemplateSpace = 1;',
    'end',
    'pos = [bv.Slice1CenterX bv.Slice1CenterY bv.Slice1CenterZ',
    '       bv.SliceNCenterX bv.SliceNCenterY bv.SliceNCenterZ]\'; % for real slices',
    '',
    'if strcmpi(fType, \'vmr\')',
    '    s.SpacingBetweenSlices = s.SliceThickness + bv.GapThickness;',
    '    s.PixelSpacing = [bv.VoxResX bv.VoxResY]\';',
    '    if ~isempty(bv.VMRData16)',
    '        nSL = bv.DimZ;',
    '        s.PixelData = bv.VMRData16; % no padded zeros',
    '    else',
    '        v16 = [s.Filename(1:end-3) \'v16\'];',
    '        if exist(v16, \'file\')',
    '            bv16 = BVQXfile(v16);',
    '            nSL = bv16.DimZ;',
    '            s.PixelData = bv16.VMRData; % no padded zeros',
    '            bv16.ClearObject;',
    '        else % fall back the 8-bit data, and deal with padded zeros',
    '            ix = floor((bv.DimX - s.Columns)/2);',
    '            iy = floor((bv.DimY - s.Rows)/2);',
    '            R3 = abs(R(iSL,3)) * s.SpacingBetweenSlices;',
    '            nSL = round(abs(diff(pos(iSL,:))) / R3) + 1;',
    '            iz = floor((bv.DimZ - nSL)/2);',
    '            s.PixelData = bv.VMRData(ix+(1:s.Columns), iy+(1:s.Rows), iz+(1:nSL), :);',
    '        end',
    '    end',
    '    s.LocationsInAcquisition = nSL;',
    '    s.MRAcquisitionType = \'3D\'; % for dicm2nii to re-orient',
    'elseif strcmpi(fType, \'fmr\') || strcmpi(fType, \'dmr\')',
    '    s.SpacingBetweenSlices = s.SliceThickness + bv.SliceGap;',
    '    s.PixelSpacing = [bv.InplaneResolutionX bv.InplaneResolutionY]\';',
    '    nSL = bv.NrOfSlices;',
    '    s.LocationsInAcquisition = nSL;',
    '    s.NumberOfTemporalPositions = bv.NrOfVolumes;',
    '    s.RepetitionTime = bv.TR;',
    '    s.EchoTime = bv.TE;',
    '    if bv.TimeResolutionVerified',
    '        switch bv.SliceAcquisitionOrder % the same as NIfTI?',
    '            case 1, ind = 1:nSL;',
    '            case 2, ind = nSL:-1:1;',
    '            case 3, ind = [1:2:nSL 2:2:nSL];',
    '            case 4, ind = [nSL:-2:1 nSL-1:-2:1];',
    '            case 5, ind = [2:2:nSL 1:2:nSL];',
    '            case 6, ind = [nSL-1:-2:1 nSL:-2:1];',
    '            otherwise, ind = []; err = \'Unknown SliceAcquisitionOrder\';',
    '        end',
    '        if ~isempty(ind)',
    '            t = (0:s.LocationsInAcquisition-1)\' * bv.InterSliceTime; % ms',
    '            t(ind) = t;',
    '            s.SliceTiming = t;',
    '        end',
    '    end',
    '    if strcmpi(fType, \'fmr\')',
    '        bv.LoadSTC;',
    '        s.PixelData = permute(bv.Slice(1).STCData , [1 2 4 3]);',
    '        for i = 2:length(bv.Slice)',
    '            s.PixelData(:,:,i,:) = permute(bv.Slice(i).STCData , [1 2 4 3]);',
    '        end',
    '    else % dmr',
    '        s.ImageType = [s.ImageType \'\\DIFFUSION\\\'];',
    '        bv.LoadDWI;',
    '        s.PixelData = bv.DWIData;',
    '        if strncmpi(bv.GradientInformationAvailable, \'Y\', 1)',
    '            a = bv.GradientInformation; % nDir by 4',
    '            s.B_value = a(:,4);',
    '            a = a(:,1:3); % bvec',
    '            % Following should be right in theory, but I would trust the grd',
    '            % table which should be in dicom coodinate system, rather than the',
    '            % confusing Gradient?DirInterpretation ',
    '%             % 1:6 for LR RL AP PA IS SI. Default [2 3 5] by dicom LPS',
    '%             i1_6 = [bv.GradientXDirInterpretation ...',
    '%                     bv.GradientYDirInterpretation ...',
    '%                     bv.GradientZDirInterpretation];',
    '%             [xyz, ind] = sort(i1_6);',
    '%             if isequal(ceil(xyz/2), 1:3) % perm of 1/2/3',
    '%                 a = a(:,ind);',
    '%                 flip = xyz == [1 4 6]; % negative by dicom ',
    '%                 a(:,flip) = -a(:,flip);',
    '%             else',
    '%                 str = sprintf([\'Wrong Interpretation of gradient found: %s\\n\' ... ',
    '%                        \'Please check bvec and its sign.\\n\'], fname);',
    '%                 fprintf(2, str);',
    '%                 err = [err str];',
    '%             end',
    '            s.bvec_original = a;',
    '        end',
    '    end',
    '    ',
    '    % fmr/dmr are normally converted from uint16 to single',
    '    if isfloat(s.PixelData) && isequal(floor(s.PixelData), s.PixelData) ...',
    '            && max(s.PixelData(:))<32768 && min(s.PixelData(:))>=-32768',
    '        s.PixelData = int16(s.PixelData);',
    '    end',
    'else',
    '    err = [\'Unknown BV file type: \' fType];',
    '    s = [];',
    '    return;',
    'end',
    '',
    'pos = pos - R(:,1:2) * diag(s.PixelSpacing) * [s.Columns s.Rows]\'/2 * [1 1];',
    's.ImagePositionPatient = pos(:,1);',
    's.LastFile.ImagePositionPatient = pos(:,2);',
    '',
    '% Following make dicm2nii happy',
    'try %#ok',
    '    [~, nam] = fileparts(bv.FirstDataSourceFile);',
    '    [~, nam] = strtok(nam, \'-\');',
    '    serN = str2double(strtok(nam, \'-\'));',
    '    if ~isempty(serN), SN = serN; end',
    'end',
    's.SeriesNumber = SN; SN = SN+1; % make it unique for multilple files',
    's.SeriesInstanceUID = sprintf(\'%g.%s.%09.0f\', s.SeriesNumber, ...',
    '    datestr(now, \'yymmdd.HHMMSS.fff\'), rand*1e9);',
    'c = class(s.PixelData);',
    'if strcmp(c, \'double\') %#ok',
    '    s.BitsAllocated = 64;',
    'elseif strcmp(c, \'single\') %#ok',
    '    s.BitsAllocated = 32;',
    'else',
    '    ind = find(isstrprop(c, \'digit\'), 1);',
    '    s.BitsAllocated = sscanf(c(ind:end), \'%g\');',
    'end',
    'end'
  )

  dicm_img <- c(
    'function img = dicm_img(s, xpose)',
    '% Read image of a dicom file.',
    '% ',
    '% img = dicm_img(metaStructOrFilename, xpose);',
    '% ',
    '% The mandatory first input is the dicom file name, or the struct returned by',
    '% dicm_hdr. The output keeps the data type in dicom file.',
    '% ',
    '% The second input is for special purpose. When it is provided and is false, the',
    '% returned img won\'t be transposed. This is likely only useful for dicm2nii.m,',
    '% where the Columns and Rows parameters become counter-intuitive.',
    '% ',
    '% DICM_IMG is like dicomread from Matlab, but is independent of Image Processing',
    '% Toolbox.',
    '% ',
    '% Limitation: DICM_IMG reads only little endian format, and can deal with only',
    '% JPEG compression.',
    '%',
    '% See also DICM_HDR, DICM_DICT, DICM2NII',
    '',
    '% TO DO: take care of BitsAllocated, BitsStored and HighBit related issue.',
    '% Now we assume',
    '%   HighBit is BitsStored-1;',
    '%   extra bits beyond BitsStored are zeros.',
    '',
    '% History (yymmdd):',
    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com)',
    '% 130914 Use PixelData.Bytes rather than nPixels;',
    '%        Use PixelRepresentation to determine signed data.',
    '% 130923 Use BitsAllocated for bits. Make it work for multiframe.',
    '% 131018 Add jpeg de-compression part.',
    '% 141023 Use memmapfile for temp file: ~25% speedup.',
    '% 150109 Transpose img by default. dicm2nii needs xpose=0 to avoid transpose.',
    '% 150115 SamplesPerPixel>1 works: put it as dim3, and push rest to dim4.',
    '% 150211 dim3 reserved for RGB, even if SamplesPerPixel=1 (like dicomread). ',
    '% 150404 Add \'if\' block for numeric s.PixelData (BVfile). ',
    '',
    'persistent flds dict;',
    'if isempty(flds)',
    '    flds = {\'Columns\' \'Rows\' \'BitsAllocated\'};',
    '    dict = dicm_dict(\'\', [flds \'SamplesPerPixel\' \'PixelRepresentation\' ...',
    '                         \'PlanarConfiguration\' \'BitsStored\' \'HighBit\']);',
    'end',
    'if isstruct(s) && ~all(isfield(s, flds)), s = s.Filename; end',
    'if ischar(s), [s, err] = dicm_hdr(s, dict); end % input is file name',
    'if isempty(s), error(err); end',
    'if isfield(s, \'SamplesPerPixel\'), spp = double(s.SamplesPerPixel);',
    'else spp = 1;',
    'end',
    '',
    'if isnumeric(s.PixelData) % data already in hdr',
    '    img = s.PixelData;',
    '    return;',
    'end',
    '',
    'if all(isfield(s, {\'BitsStored\' \'HighBit\'})) && s.BitsStored ~= s.HighBit+1',
    '    error(\'Please report to author: HighBit+1 ~= BitsStored, %s\', s.Filename);',
    'end',
    '',
    'fid = fopen(s.Filename);',
    'if fid<0',
    '    if exist([s.Filename \'.gz\'], \'file\')',
    '        gunzip([s.Filename \'.gz\']);',
    '        fid = fopen(s.Filename);',
    '    end',
    '    if fid<0, error([\'File not exists: \' s.Filename]); end',
    'end',
    'closeFile = onCleanup(@() fclose(fid));',
    'fseek(fid, s.PixelData.Start, -1);',
    'if ~isfield(s.PixelData, \'Format\')',
    '    fmt = sprintf(\'*uint%g\', s.BitsAllocated);',
    'else',
    '    fmt =  s.PixelData.Format;',
    'end',
    '',
    'if nargin<2 || isempty(xpose), xpose = true; end % same as dicomread by default',
    '',
    'if ~isfield(s, \'TransferSyntaxUID\') || ... % maybe PAR or AFNI file',
    '        strcmp(s.TransferSyntaxUID, \'1.2.840.10008.1.2.1\') || ...',
    '        strcmp(s.TransferSyntaxUID, \'1.2.840.10008.1.2\')',
    '    n = s.PixelData.Bytes / double(s.BitsAllocated) * 8;',
    '    img = fread(fid, n, fmt);',
    '    dim = double([s.Columns s.Rows]);',
    '    if ~isfield(s, \'PlanarConfiguration\') || s.PlanarConfiguration==0',
    '        img = reshape(img, [spp dim n/spp/dim(1)/dim(2)]);',
    '        img = permute(img, [2 3 1 4]);',
    '    else',
    '        img = reshape(img, [dim spp n/spp/dim(1)/dim(2)]);',
    '    end',
    '    if xpose, img = permute(img, [2 1 3 4]); end',
    'else % rely on imread for decompression',
    '    b = fread(fid, inf, \'*uint8\'); % read all as bytes',
    '    nEnd = numel(b) - 8; % terminator 0xFFFE E0DD and its zero length',
    '    n = typecast(b(5:8), \'uint32\'); i = 8+n; % length of offset table',
    '    if n>0',
    '        nFrame = n/4; % # of elements in offset table ',
    '    else % empty offset table',
    '        ind = strfind(b\', uint8([254 255 0 224])); % 0xFFFE E000',
    '        nFrame = numel(ind) - 1; % one more for offset table, even if empty',
    '    end',
    '    img = zeros(s.Rows, s.Columns, spp, nFrame, fmt(2:end)); % pre-allocate',
    '    ',
    '    useMemmapfile = ~isempty(which(\'memmapfile\'));',
    '    fname = tempname;',
    '    if useMemmapfile',
    '        fid = fopen(fname, \'w\');',
    '        n = double(s.Columns) * double(s.Rows) * double(s.BitsAllocated) / 8 * spp;',
    '        fwrite(fid, zeros(n, 1, \'uint8\')); % large enough: 1 frame w/o compression',
    '        fclose(fid); ',
    '        m = memmapfile(fname, \'Writable\', true);',
    '    end',
    '    deleteTemp = onCleanup(@() delete(fname)); % after memmapfile',
    '    ',
    '    for j = 1:nFrame',
    '        i = i+4; % delimiter: FFFE E000',
    '        n = typecast(b(i+uint32(1:4)), \'uint32\'); i = i+4;',
    '        if useMemmapfile',
    '            m.Data(1:n) = b(i+(1:n)); i = i + n;',
    '        else',
    '            fid = fopen(fname, \'w\');',
    '            fwrite(fid, b(i+(1:n)), \'uint8\'); i = i + n;',
    '            fclose(fid); ',
    '        end',
    '        img(:,:,:,j) = imread(fname); % take care of decompression',
    '        if i>nEnd % in case false delimiter in data was counted',
    '            img(:,:,:,j+1:end) = [];',
    '            break;',
    '        end',
    '    end',
    '    if ~xpose, img = permute(img, [2 1 3 4]); end',
    'end',
    '',
    'if isfield(s, \'PixelRepresentation\') && s.PixelRepresentation>0',
    '    img = reshape(typecast(img(:), fmt(3:end)), size(img)); % signed',
    'end'
  )

  rename_dict <- c(
    'function rename_dicm(files, fmt)',
    '% Rename dicom files so the names are human readable.',
    '% ',
    '% rename_dicm(files, outputNameFormat)',
    '% ',
    '% The first input is the dicom file(s) or a folder containing dicom files.',
    '% The second input is the format for the result file names. Support format',
    '% include:',
    '% ',
    '% 1: Protocol_#####.dcm, such as run1_00001.dcm. If there is MoCo series,',
    '%    or users did not change run names, there will be name conflict.',
    '%   ',
    '% 2: Subj-Ser#-Acq#-Inst#.dcm, such as 2334ZL-0004-0001-00001.dcm. This is',
    '%    the BrainVoyager format. It won\'t have any name confict, but it is',
    '%    long and less descriptive. Note that BrainVoyager itself has problem',
    '%    to distinguish the two series of images for Siemens fieldmap, while',
    '%    this code can avoid this problem.',
    '% ',
    '% 3: Protocol_Se#_Inst#, such as run1_004_00001.dcm. This gives short names,',
    '%    while it is descriptive and there is no name conflict most of time.',
    '% ',
    '% 4: Subj_Protocol_In#, such as 2334ZL_run1_00001.dcm. This is useful if',
    '%    files for different subjects are in the same folder.',
    '% ',
    '% 5: Protocol_Ser#-Acq#-Inst#, such as run1_003_001_00001.dcm. This ensures ',
    '%    no name conflict, and is the default.',
    '% ',
    '% Whenever there is name confict, you will see red warning and the latter',
    '% files won\'t be renamed.',
    '% ',
    '% If the first input is not provided or empty, you will be asked to pick up',
    '% a folder.',
    '% ',
    '% See also DICM_HDR SORT_DICM',
    ' ',
    '% History (yymmdd):',
    '% 0710?? Write it (Xiangrui Li)',
    '% 1304?? Add more options for output format',
    '% 1306?? Exclude PhoenixZIPReport files to avoid error',
    '% 1306?? Fix problem if illegal char in ProtocolName',
    '% 1309?? Use dicm_hdr to replace dicominfo, so it runs much faster',
    '% 1309?? Use 5-digit InstanceNumber, so works better for GE/Philips',
    '% 1402?? Add Manufacturer to flds (bug caused by dicm_hdr update)',
    '% 140506 Use SeriesDescription to replace ProtocolName non-Siemens',
    '',
    'curFolder = pwd;',
    'clnObj = onCleanup(@() cd(curFolder));',
    'if nargin<1 || isempty(files)',
    '    folder = uigetdir(pwd, \'Select a folder containing DICOM files\');',
    '    if folder==0, return; end',
    '    cd(folder);',
    '    files = dir;',
    '    files([files.isdir]) = [];',
    '    files = {files.name};',
    '    ',
    '    str = sprintf([\'Choose Output format: \\n\\n\' ...',
    '                   \'1: run1_00001.dcm\\n\' ...',
    '                   \'2: BrainVoyager format\\n\' ...',
    '                   \'3: run1_001_00001.dcm\\n\' ...',
    '                   \'4: subj_run1_00001.dcm\\n\' ...',
    '                   \'5: run1_001_001_00001.dcm\\n\']);',
    '    fmt = inputdlg(str, \'Rename Dicom\', 1, {\'5\'});',
    '    if isempty(fmt), return; end',
    '    fmt = str2double(fmt{1});',
    'else',
    '    if exist(files, \'dir\') % input is folder',
    '        cd(files);',
    '        files = dir;',
    '        files([files.isdir]) = [];',
    '        files = {files.name};',
    '    else % files',
    '        if ~iscell(files), files = {files}; end',
    '        folder = fileparts(files{1});',
    '        if ~isempty(folder), cd(folder); end',
    '    end',
    '    if nargin<2 || isempty(fmt), fmt = 5; end',
    'end',
    '',
    'if ispc, ren = \'rename\';',
    'else ren = \'mv\';',
    'end % matlab movefile is too slow',
    '',
    'flds = {\'InstanceNumber\' \'AcquisitionNumber\' \'SeriesNumber\' \'EchoNumber\' \'ProtocolName\' ...',
    '        \'SeriesDescription\' \'PatientName\' \'PatientID\' \'Manufacturer\'};',
    'dict = dicm_dict(\'\', flds);',
    '',
    'nFile = length(files);',
    'if nFile<1, return; end',
    'err = \'\';',
    'str = sprintf(\'%g/%g\', 1, nFile);',
    'fprintf(\' Renaming DICOM files: %s\', str);',
    '',
    'for i = 1:nFile',
    '    fprintf(repmat(\'\\b\', [1 length(str)]));',
    '    str = sprintf(\'%g/%g\', i, nFile);',
    '    fprintf(\'%s\', str);',
    '    s = dicm_hdr(files{i}, dict);',
    '    try % skip if no these fields',
    '        sN = s.SeriesNumber;',
    '        aN = s.AcquisitionNumber;',
    '        iN = s.InstanceNumber;',
    '        if strncmp(s.Manufacturer, \'SIEMENS\', 7)',
    '            pName = strtrim(s.ProtocolName);',
    '        else',
    '            pName = strtrim(s.SeriesDescription);',
    '        end',
    '        if isfield(s, \'PatientName\')',
    '            sName = s.PatientName;',
    '        else',
    '            sName = s.PatientID;',
    '        end',
    '    catch me %#ok',
    '        continue;',
    '    end',
    '    ',
    '    pName(~isstrprop(pName, \'alphanum\')) = \'_\'; % make str valid for file name',
    '    while 1',
    '        ind = strfind(pName, \'__\');',
    '        if isempty(ind), break; end',
    '        pName(ind) = [];',
    '    end',
    '    sName(~isstrprop(sName, \'alphanum\')) = \'_\'; % make str valid for file name',
    '    while 1',
    '        ind = strfind(sName, \'__\');',
    '        if isempty(ind), break; end',
    '        sName(ind) = [];',
    '    end',
    '    ',
    '    if strncmpi(s.Manufacturer, \'Philips\', 7) % SeriesNumber is useless',
    '        sN = aN;',
    '    elseif strncmpi(s.Manufacturer, \'SIEMENS\', 7)',
    '        if isfield(s, \'EchoNumber\') && s.EchoNumber>1',
    '            aN = s.EchoNumber; % fieldmap phase image',
    '        end',
    '    end',
    '    ',
    '    if fmt == 1 % pN_001',
    '        name = sprintf(\'%s_%05g.dcm\', pName, iN);',
    '    elseif fmt == 2 % BrainVoyager',
    '        name = sprintf(\'%s-%04g-%04g-%05g.dcm\', sName, sN, aN, iN);',
    '    elseif fmt == 3 % pN_03_00001',
    '        name = sprintf(\'%s_%02g_%05g.dcm\', pName, s.SeriesNumber, iN);',
    '    elseif fmt == 4 % 2322ZL_pN_001',
    '        name = sprintf(\'%s_%s_%05g.dcm\', sName, pName, iN); ',
    '    elseif fmt == 5 % pN_003_001_001',
    '        name = sprintf(\'%s_%03g_%03g_%05g.dcm\', pName, sN, aN, iN); ',
    '    else',
    '        error(\'Invalid format.\');',
    '    end',
    '    ',
    '    if strcmpi(files{i}, name), continue; end % done already',
    '    [er, foo] = system([ren \' "\' files{i} \'" \' name]);',
    '    if er, err = [err files{i} \': \' foo]; end %#ok',
    'end',
    'fprintf(\'\\n\');',
    'if ~isempty(err), fprintf(2, \'\\n%s\\n\', err); end'
  )

  sort_dicm <- c(
    'function varargout = sort_dicm(srcDir)',
    '% Sort dicom files for different subjects into subject folders. ',
    '% ',
    '% subjects = SORT_DICM(dicmFolder);',
    '% The optional input is the top folder containing dicom file and/or subfodlers',
    '% which may contain dicom files and/or subfolders.',
    '% ',
    '% Optionally, it returns subfolder names for the dicom files.',
    '% ',
    '% It is suggested not to mix dicom files for different subjects into a folder.',
    '% However if, for any reason, a folder contains dicom files for multiple',
    '% subjects, this function will create a subfolder under the dicom folder for',
    '% each subject, and move corresponding files into each subject folder. If a',
    '% subject has more than one studies, each study will have a subfolder.',
    '% ',
    '% See also DICM2NII, DICM_HDR, RENAME_DICM ',
    '',
    '% History (yymmdd):',
    '% 141016 Wrote it (Xiangrui Li).',
    '% 141017 Take care of StudyID, return sub-folders.',
    '',
    'if nargin<1 || isempty(srcDir)',
    '    srcDir = uigetdir(pwd, \'Select a folder containing DICOM files\');',
    '    if ~ischar(srcDir), return; end % user cancelled',
    'end',
    'if ~exist(srcDir, \'dir\'), error([srcDir \' not exists.\']); end',
    '',
    'dirs = genpath(srcDir);',
    'dirs = textscan(dirs, \'%s\', \'Delimiter\', pathsep);',
    'dirs = dirs{1}; % cell str',
    'fnames = {};',
    'for i = 1:length(dirs)',
    '    curFolder = [dirs{i} filesep];',
    '    foo = dir(curFolder); % all files and folders',
    '    foo([foo.isdir]) = []; % remove folders',
    '    foo = strcat(curFolder, {foo.name});',
    '    fnames = [fnames foo]; %#ok<*AGROW>',
    'end',
    '',
    'dict = dicm_dict(\'\', {\'PatientName\' \'PatientID\' \'StudyID\'});',
    'h = struct;',
    'n = length(fnames);',
    'nDicm = 0;',
    'for i = 1:n',
    '    s = dicm_hdr(fnames{i}, dict);',
    '    if isempty(s), continue; end',
    '',
    '    if isfield(s, \'PatientName\'), subj = s.PatientName;',
    '    elseif isfield(s, \'PatientID\'), subj = s.PatientID;',
    '    else continue;',
    '    end',
    '    if ~isfield(s, \'StudyID\'), s.StudyID = \'1\'; end',
    '    ',
    '    P = genvarname([\'P\' subj]);',
    '    if ~isfield(h, P), h.(P) = []; end',
    '    S = genvarname([\'S\' s.StudyID]);',
    '    if ~isfield(h.(P), S), h.(P).(S) = {}; end',
    '    ',
    '    h.(P).(S){end+1} = s.Filename;',
    '    nDicm = nDicm + 1;',
    'end',
    '',
    'sep = filesep;',
    'folders = {};',
    'subjs = fieldnames(h);',
    'for i = 1:length(subjs)',
    '    sub = h.(subjs{i});',
    '    S = fieldnames(sub);',
    '    nS = length(S);',
    '    for j = 1:nS',
    '        dstDir = [srcDir sep subjs{i}(2:end)];',
    '        if nS>1, dstDir = [dstDir \'_study\' S{j}(2:end)]; end',
    '        if ~exist(dstDir, \'dir\'), mkdir(dstDir); end',
    '        folders{end+1} = dstDir;',
    '        ',
    '        for k = 1:length(sub.(S{j}))',
    '            fname = sub.(S{j}){k};',
    '            [~, nam, ext] = fileparts(fname);',
    '            dstName = [dstDir sep nam ext];',
    '            if ~exist(dstName, \'file\'), movefile(fname, dstName); end',
    '        end',
    '    end',
    'end',
    '',
    'if nargout',
    '    varargout = {folders\'};',
    'else',
    '    fprintf(\' %g of %g files sorted into %g subfolders:\\n\', ...',
    '        nDicm, n, length(folders));',
    '    fprintf(\'  %s\\n\', folders{:});',
    'end'

  )

  writeLines(nii_tool,'nii_tool.m')
  writeLines(dicm2nii,'dicm2nii.m')
  writeLines(dicm_dict,'dicm_dict.m')
  writeLines(dicm_hdr,'dicm_hdr.m')
  writeLines(dicm_img,'dicm_img.m')
  writeLines(rename_dict,'rename_dict.m')
  writeLines(sort_dicm,'sort_dicm.m')




  #source('matlabcode.R')
  Matlab$startServer()   #matlab,
  #[1] 0
  matlab <- Matlab()
  isOpen <- open(matlab) #matlab
  if (!isOpen)
    stop('connect to Matlab Server failed!')
  OutputDir <- 'nii_tmp/'
  setVariable(matlab,src = src);
  #setVariable(matlab,dataFolder = outputPath);
  #setVariable(matlab,outputFormat = outputFormat);
  setVariable(matlab,dataFolder = OutputDir);
  evaluate(matlab,'dicm2nii(src,dataFolder,0,0)')

  close(matlab)

  target <- paste(OutputDir,list.files(OutputDir,'*.nii'),sep="")
  object <- read.nii(object,target)
  file.remove(paste(OutputDir,list.files(OutputDir,'dcm*'),sep=""))
  file.remove(target)
  file.remove('nii_tool.m')
  file.remove('dicm2nii.m')
  file.remove('dicm_dict.m')
  file.remove('dicm_hdr.m')
  file.remove('dicm_img.m')
  file.remove('rename_dict.m')
  file.remove('sort_dicm.m')
  file.remove('InputStreamByteWrapper.class')
  file.remove('MatlabServer.m')
  object@file_type <- "DICOM"
  object
}
)

read.DICOM.dcm <- function(inputPath)
{
  a <- new("nifti_one")
  read.dcm(a, inputPath)
}
