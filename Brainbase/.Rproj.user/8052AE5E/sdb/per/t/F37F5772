{
    "collab_server" : "",
    "contents" : "setGeneric(\"convert.4Dto2D\", function(obj, ...) standardGeneric(\"convert.4Dto2D\"))\n\nsetMethod(\"convert.4Dto2D\", signature(\"NIdata\"), function(obj, template = NULL, verbose = TRUE){\n  new.obj = obj\n\n  if(!is.null(template)){\n    assert_that(class(template) == \"Template\") #WARNING: need to relax this \n    template = template@data@mat\n  }\n\n  res = .convert.4Dto2Dmat(obj@data@mat, template, verbose)\n\n  new.obj@data = .BCoData2D(mat = res$mat, mask = res$mask, base.dim = dim(obj@data@mat)[1:3])\n\n  new.obj\n})\n\n#convert 4D matrix into 2D matrix\n.convert.4Dto2Dmat <- function(dat, template = NULL, verbose = TRUE){\n  assert_that(is.numeric(dat) & length(dim(dat))==4)\n  assert_that(is.null(template) || all(dim(dat)[1:3] == dim(template)))\n\n  dimen = dim(dat)\n  if(is.null(template)){\n    #NEED A FUNCTION HERE TO MAKE SURE THERE IS NO MOTION\n    mask = which(dat[,,,1] != 0)\n  } else {\n    mask = .extract.mask(template)\n  }\n\n  mat = matrix(NA, dimen[4], length(mask))\n  for(j in 1:dimen[4]){\n    mat[j,] = as.numeric(dat[,,,j])[mask]\n\n    if(j%%floor(dimen[4]/10)==0 & verbose) cat('*')\n  }\n\n  list(mat = mat, mask = mask)\n}\n\n#convert 2D matrix back to 4D matrix\n.convert.2Dto4Dmat <- function(mat, mask, dimen, verbose = TRUE){\n  assert_that(min(mask) >= 0)\n  assert_that(max(mask) <= prod(dimen))\n  assert_that(ncol(mat) == length(mask))\n\n  dat = array(0, dim = c(dimen, nrow(mat)))\n\n  #change the mask to handle the indices across different time slices\n  idx = as.numeric(sapply(0:(nrow(mat)-1), function(x){mask+prod(dimen)*x}))  \n\n  #fill in the values\n  dat[idx] = t(mat)\n\n  dat\n}\n\n#create mask from a 3D MNI template\n.extract.mask <- function(template){\n  assert_that(length(dim(template)) == 3)\n\n  which(template != 0)\n}\n\n#onvert a location (single matrix index from 1 to prod(dimen)) into 3D coordinates\n.convert.2Dto3Dloc <- function(idx, dimen){\n  assert_that(is.numeric(idx))\n  assert_that(length(dimen)==3 & is.numeric(dimen))\n  assert_that(idx <= prod(dimen))\n\n  z = ceiling(idx / (dimen[1]*dimen[2]))\n\n  tmp = idx %% (dimen[1]*dimen[2])\n  if(tmp==0) tmp = dimen[1]*dimen[2]\n  y = ceiling(tmp / dimen[1])\n\n  x = tmp %% dimen[1]\n  if(x==0) x = dimen[1]\n\n  c(x,y,z)\n}\n\n# convert a location (3D by coordinates) into an index for a matrix\n.convert.3Dto2Dloc = function(loc, dimen)\n{\n  assert_that(length(loc)==3 & is.numeric(loc))\n  assert_that(length(dimen)==3 & is.numeric(dimen))\n  assert_that(all(loc<=dimen))\n  assert_that(all(loc>0))\n\n  loc[1]+dimen[1]*(loc[2]-1)+(dimen[1]*dimen[2])*(loc[3]-1)\n}\n\n",
    "created" : 1458230970367.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2961572388",
    "id" : "F37F5772",
    "lastKnownWriteTime" : 1458143921,
    "last_content_update" : 1458143921,
    "path" : "D:/Documents/github/BrainConductor/Brainbase/R/conversion.R",
    "project_path" : "R/conversion.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}