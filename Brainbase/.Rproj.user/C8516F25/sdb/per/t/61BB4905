{
    "contents" : "#WE NEED A SPECIAL PRINT STATEMENT\n\n#Our generic read function\n#\"controls\" is a list which contains preprocessing commands\nBCoRead <- function(input, controls = list(), subject.ID = \"\"){\n\n  #determine if the 'input' file is DICOM or NIfTI\n  file.ending = strsplit(input, \"\\\\.\")[[1]]\n  file.ending = file.ending[length(file.ending)]\n  assert_that(file.ending %in% c(\".dcm\", \"gz\", \"nii\"))\n\n  #if dicom, read dicom reader and convert into \n  if(file.ending == \".dcm\"){\n    \n    #WARNING: The following code does not work, but should be something like this:\n    dat = read.DICOM.dcm(input)\n\n  #if nifti, use the nifti functions\n  } else {\n    \n    #WARNING: We want to use our readNIfTI.R function?  \n    dat = readNIfTI(input)\n  }\n\n  #WARNING; This currently doesn't handle the NIfTI handler\n  res = .NIdata(.BCoBase(data = .BCoData4D(mat = dat@.Data)), ID = subject.ID)\n\n  #immediately convert to 2D matrix if it is dictated in \"controls\"\n  if(!is.null(controls$convert2D) && controls$convert2D == TRUE){\n    res = convert.4Dto2D(res)\n  }\n\n  #immediately apply a mask if one is supplied\n  if(!is.null(controls$template)){\n    #WARNING: How to pass in the arguments for BCoReduce?\n    res = BCoReduce(res, controls$template)\n  }\n\n  res\n}\n\nBCoWrite <- function(obj, type = c(\"NIfTI\", \"RData\")){\n\n}\n\n\nBCoReadandAssign <- function(input, variable.header, controls = NULL, subject.ID = \"\"){\n  res = BCoRead(input, controls, subject.ID)\n  \n  resname = paste0(variable.header, \"_\", subject.ID)\n  resname.mod = resname\n \n  #determine if \"resname\" is unique. If not, add integers after it until it is\n  current.vars = ls(.GlobalEnv)\n  if(resname.mod %in% current.vars){\n    iter = 1\n\n    while(TRUE){\n      resname.mod = paste0(resname, \"_\", iter)\n      if(!resname.mod %in% current.vars) break()\n\n      iter = iter + 1\n    }\n  }\n\n  assign(resname.mod, res, envir = .GlobalEnv)  \n\n  resname.mod\n}\n\n#tab is a data.frame (supposedly from a csv file already loaded in R)\nBCoLink.phenotype <- function(tab, subject.ID.col, kept.column.idx){\n  assert_that(class(tab) == \"data.frame\")\n  assert_that(class(tab[,subject.ID.col]) == \"character\")\n  assert_that(all(!duplicated(tab[,subject.ID.col]))) #make sure no duplicates\n\n  subject.ID = tab[,subject.ID.col]\n  variables = ls(.GlobalEnv)\n  varClasses = sapply(variables, function(x){\n    class(eval(as.name(x)))\n  })\n\n  #find the NIdata variables\n  idx.NIdata = which(varClasses == \"NIdata\")\n  subj.vec = sapply(variables[idx.NIdata], function(x){\n    eval(as.name(x))@ID\n  })\n\n  colnam = names(tab)[kept.column.idx]\n\n  #now loop over all rows in tab\n  link.phenotype <- function(i){\n    idx = which(subj.vec == tab[i, subject.ID.col])\n \n    if(length(idx) > 0){\n      #create the list for the phenotype\n      lis = as.list(tab[i, kept.column.idx])\n      names(lis) = colnam\n  \n      #loop over all data from that subject (handle multiple scans)\n      for(j in 1:length(idx)){\n        NIobj = eval(as.name(variables[idx.NIdata[idx[j]]]))\n        assert_that(class(NIobj) == \"NIdata\")\n    \n        NIobj@phenotype = lis\n\n\n        assign(variables[idx.NIdata[idx[j]]], NIobj, envir = .GlobalEnv)\n      }\n    }\n  }\n\n  sapply(1:nrow(tab), link.phenotype)\n \n  invisible()\n}\n",
    "created" : 1458374628418.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1666939010",
    "id" : "61BB4905",
    "lastKnownWriteTime" : 1458205417,
    "path" : "~/GitHub/BrainConductor/Brainbase/R/BCoRead.R",
    "project_path" : "R/BCoRead.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}