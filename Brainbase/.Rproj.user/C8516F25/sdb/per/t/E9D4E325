{
    "contents" : "#This Method 'read.dcm' can read NIFTI S4 class from .dcm files in the folder inputPath\n\nsetGeneric(\"read.dcm\",function(object, src)  standardGeneric(\"read.dcm\"));\n\nsetMethod(\"read.dcm\", signature(object = \"NIdata\"), function(object, src)\n{\n  nii_tool <- c(\n    'function varargout = nii_tool(cmd, varargin)',\n    '% Basic function to create, load and save NIfTI file.',\n    '% Matlab function copyright (c) 2015, Xiangrui Li, All rights reserved.',\n    '% rst = nii_tool(cmd, para);',\n    '% ',\n    '% To list all command, type',\n    '%  nii_tool ?',\n    '% ',\n    '% To get help information for each command, include \\'?\\' in cmd, for example:',\n    '%  nii_tool init?',\n    '%  nii_tool(\\'init?\\')',\n    '% ',\n    '% Here is a list of all command:',\n    '% ',\n    '% nii_tool(\\'default\\', \\'version\\', 1, \\'rgb_dim\\', 1);',\n    '% nii = nii_tool(\\'init\\', img);',\n    '% nii_tool(\\'save\\', nii, filename, force_3D);',\n    '% hdr = nii_tool(\\'hdr\\', filename);',\n    '% img = nii_tool(\\'img\\', filename_or_hdr);',\n    '% ext = nii_tool(\\'ext\\', filename_or_hdr);',\n    '% nii = nii_tool(\\'load\\', filename_or_hdr);',\n    '% nii = nii_tool(\\'cat3D\\', filenames);',\n    '% nii_tool(\\'RGBStyle\\', \\'afni\\');',\n    '% ',\n    '% Detail for each command is described below.',\n    '% ',\n    '% oldVal = nii_tool(\\'default\\', \\'version\\', 1, \\'rgb_dim\\', 1);',\n    '% oldVal = nii_tool(\\'default\\', struct(\\'version\\', 1, \\'rgb_dim\\', 1));',\n    '% ',\n    '% - Set/query default NIfTI version and/or rgb_dim. To check the setting, run',\n    '% nii_tool(\\'default\\') without other input. The input for \\'default\\' command can',\n    '% be either a struct with fields of \\'version\\' and/or \\'rgb_dim\\', or',\n    '% parameter/value pairs. See nii_tool(\\'RGBstyle\\') for meaning of rgb_dim.',\n    '% ',\n    '% Note that the setting will be saved for future use. If one wants to change the',\n    '% settting temporarily, it is better to return the oldVal, and to restore it',\n    '% after done:',\n    '% ',\n    '%  oldVal = nii_tool(\\'default\\', \\'version\\', 2); % set version 2 as default',\n    '%  % \\'init\\' and \\'save\\' NIfTI using above version',\n    '%  nii_tool(\\'default\\', oldVal); % restore default setting',\n    '% ',\n    '% The default version setting affects \\'init\\' command only. If you \\'load\\' a NIfTI',\n    '% file, modify it, and then \\'save\\' it, the version will be the same as the',\n    '% original file, unless it is changed explicitly (see help for \\'save\\' command).',\n    '% All \\'load\\' command (\\'load\\', \\'hdr\\', \\'ext\\', \\'img\\') will read any version',\n    '% correctly, regardless of version setting.',\n    '% ',\n    '% ',\n    '% nii = nii_tool(\\'init\\', img, RGB_dim);',\n    '% ',\n    '% - Initialize nii struct based on img, normally 3D or 4D array. Most fields in',\n    '% the returned nii.hdr contain default values, and need to be updated based on',\n    '% dicom or other information. Important ones include pixdim and s/qform_code and',\n    '% related parameters.',\n    '% ',\n    '% The NIfTI datatype will depend on data type of img. Most Matlab data types are',\n    '% supported, including 8/16/32/64 bit signed and unsigned integers, single and',\n    '% double floating numbers. Single/double complex and logical array are also',\n    '% supported.',\n    '% ',\n    '% nii_tool returns img with the same data type as it is stored, while numeric',\n    '% values in hdr are in double regardless the data type in the file.',\n    '% ',\n    '% The optional third input is needed only if img contains RGB/RGBA data. It',\n    '% specifies which dimension in img encodes for RGB or RGBA. In other words, if a',\n    '% non-empty third input is provided, img will be interpreted as RGB or RGBA',\n    '% data.',\n    '% ',\n    '% Another way to signify RGB/RGBA data is to permute color dim to 8th-dim of img',\n    '% (RGB_dim of 8 can be omitted then). Since NIfTI img can have up to 7 dim,',\n    '% nii_tool chooses to store RGB/RGBA in 8th dim. Although this looks lengthy',\n    '% (4th to 7th dim are often all ones), nii_tool can deal with up to 7 dim',\n    '% without causing any confusion. This is why the returned nii.img will always',\n    '% store RGB in 8th dim.',\n    '% ',\n    '% ',\n    '% hdr = nii_tool(\\'hdr\\', filename);',\n    '% ',\n    '% - Return hdr struct of the provided NIfTI file.',\n    '% ',\n    '% ',\n    '% img = nii_tool(\\'img\\', filename_or_hdr);',\n    '% ',\n    '% - Return image data in a NIfTI file. The second input can be NIfTI file name,',\n    '% or hdr struct returned by nii_tool(\\'hdr\\', filename).',\n    '% ',\n    '% ',\n    '% ext = nii_tool(\\'ext\\', filename_or_hdr);',\n    '% ',\n    '% - Return NIfTI extension in a NIfTI file. The second input can be NIfTI file',\n    '% name, or hdr struct returned by nii_tool(\\'hdr\\', filename). The returned ext',\n    '% will have field \\'edata_decoded\\' if \\'ecode\\' is of known type, such as dicom',\n    '% (2), text (4 or 6) or Matlab (40).',\n    '% ',\n    '% Here is an example to add data in myFile.mat as extension to nii struct, which',\n    '% can be from \\'init\\' or \\'load\\':',\n    '% ',\n    '%  fid = fopen(\\'myFile.mat\\'); % open the MAT file',\n    '%  myEdata = fread(fid, inf, \\'*uint8\\'); % load all bytes as byte column',\n    '%  fclose(fid);',\n    '%  len = int32(numel(myEdata)); % number of bytes in int32',\n    '%  myEdata = [typecast(len, \\'uint8\\')\\'; myEdata]; % include len in myEdata',\n    '%  nii.ext.ecode = 40; % 40 for Matlab extension',\n    '%  nii.ext.edata = myEdata; % myEdata must be uint8 array',\n    '% ',\n    '% nii_tool will take care of rest when you \\'save\\' nii to a file.',\n    '% ',\n    '% In case a NIfTI ext causes problem (for example, some FSL builds have problem',\n    '% in reading NIfTI img with ecode>30), one can remove the ext easily:',\n    '% ',\n    '%  nii = nii_tool(\\'load\\', \\'file_with_ext.nii\\'); % load the file with ext',\n    '%  nii.ext = []; % or nii = rmfield(nii, \\'ext\\'); % remove ext',\n    '%  nii_tool(\\'save\\', nii, \\'file_without_ext.nii\\'); % save it',\n    '%',\n    '% ',\n    '% nii = nii_tool(\\'load\\', filename_or_hdr);',\n    '% ',\n    '% - Load NIfTI file into nii struct. The returned struct includes NIfTI \\'hdr\\'',\n    '% and \\'img\\', as well as \\'ext\\' if the file contains NIfTI extension.',\n    '% ',\n    '% ',\n    '% nii_tool(\\'save\\', nii, filename, force_3D);',\n    '% ',\n    '% - Save struct nii into filename. The format of the file is determined by the',\n    '% file extension, such as .img, .nii, .img.gz, .nii.gz etc. If filename is not',\n    '% provided, nii.hdr.file_name must contain a file name. Note that \\'save\\' command',\n    '% always overwrites file in case of name conflict.',\n    '% ',\n    '% If filename has no extension, \\'.nii\\' will be used as default.',\n    '% ',\n    '% If the 4th input, force_3D, is true (default false), the output file will be',\n    '% 3D only, which means multiple volume data will be split into multiple files.',\n    '% This is the format SPM likes. You can use this command to convert 4D into 3D',\n    '% by \\'load\\' a 4D file, then \\'save\\' it as 3D files. The 3D file names will have',\n    '% 5-digit like \\'_00001\\' appended to indicate volume index.',\n    '% ',\n    '% The NIfTI version can be set by nii_tool(\\'default\\'). One can override the',\n    '% default version by specifying it in nii.hdr.version. To convert between',\n    '% versions, load a NIfTI file, specify new version, and save it. For example:',\n    '% ',\n    '%  nii = nii_tool(\\'load\\', \\'file_nifti1.nii\\'); % load version 1 file',\n    '%  nii.hdr.version = 2; % force to NIfTI-2',\n    '%  nii_tool(\\'save\\', nii, \\'file_nifti2.nii\\'); % save as version 2 file',\n    '% ',\n    '% Following example shows how to change data type of a nii file:',\n    '%  nii = nii_tool(\\'load\\', \\'file_int16.nii\\'); % load int16 type file',\n    '%  nii.img = single(nii.img); % change data type to single/float32',\n    '%  nii_tool(\\'save\\', nii, \\'file_float.nii\\'); % nii_tool will take care of hdr',\n    '% ',\n    '% ',\n    '% nii = nii_tool(\\'cat3D\\', files);',\n    '% ',\n    '% - Concatenate SPM 3D files into a 4D dataset. The input \\'files\\' can be cellstr',\n    '% with file names, or char with wildcards (* or ?). If it is cellstr, the volume',\n    '% order in the 4D data corresponds to those files. If wildcards are used, the',\n    '% volume order is based on alphabetical order of file names.',\n    '% ',\n    '% Note that the files to be concatenated must have the same datatype, dim, voxel',\n    '% size, scaling slope and intercept, transformation matrix, etc. This is true if',\n    '% files are for the same series. ',\n    '% ',\n    '% Following example shows how to convert a series of 3D files into a 4D file:',\n    '% ',\n    '%  nii = nii_tool(\\'cat3D\\', \\'./data/fSubj2-0003*.nii\\'); % load files for series 3 ',\n    '%  nii_tool(\\'save\\', nii, \\'./data/fSubj2-0003_4D.nii\\'); % save as a 4D file',\n    '% ',\n    '% ',\n    '% oldStyle = nii_tool(\\'RGBStyle\\', \\'afni\\');',\n    '% ',\n    '% - Set/query the method to save RGB or RGBA NIfTI file. The default method can',\n    '% be set by nii_tool(\\'default\\', \\'rgb_dim\\', dimN), where dimN can be 1, 3 or 4,',\n    '% or \\'afni\\', \\'mricron\\' or \\'fsl\\', as explained below.',\n    '% ',\n    '% The default style is \\'afni\\' style (or 1), which is defined by NIfTI standard,',\n    '% but is not well supported by fslview till v5.0.8 or mricron till v20140804',\n    '% ',\n    '% If the second input is set to \\'mricron\\' (or 3), nii_tool will save file',\n    '% using the old RGB fashion (dim 3 for RGB). This works for mricron v20140804 or',\n    '% earlier. The later mricron works for both rgb_dim of 1 and 3.',\n    '% ',\n    '% If the second input is set to \\'fsl\\' (or 4), nii_tool will save RGB or RGBA',\n    '% layer into 4th dimension, and the file is not encoded as RGB data, but as',\n    '% normal NIfTI. This violates the NIfTI rule, but it seems it is the only way',\n    '% to work for fslview (at least till fsl v5.0.8).',\n    '% ',\n    '% If no new style (second input) is provided, it means to query the current',\n    '% style (one of \\'afni\\', \\'mricron\\' and \\'fsl\\').',\n    '% ',\n    '% Following shows how to convert into fsl style:',\n    '% ',\n    '%  nii = nii_tool(\\'load\\', \\'non_fsl_style.nii\\'); % load RGB file',\n    '%  nii_tool(\\'RGBStyle\\', \\'fsl\\'); % switch to fsl style for later save',\n    '%  nii_tool(\\'save\\', nii, \\'fslRGB.nii\\'); % fsl can read it as RGB',\n    '% ',\n    '% Note that, if one wants to convert fsl style (non-RGB file by NIfTI standard)',\n    '% to other styles, an extra step is needed to change the RGB dim from 4th to 8th',\n    '% dim before \\'save\\':',\n    '% ',\n    '%  nii = nii_tool(\\'load\\', \\'fslStyleFile.nii\\'); % it is normal NIfTI',\n    '%  nii.img = permute(nii.img, [1:3 5:8 4]); % force it to be RGB data',\n    '%  nii_tool(\\'RGBStyle\\', \\'afni\\'); % switch to NIfTI RGB style',\n    '%  nii_tool(\\'save\\', nii, \\'afni_RGB.nii\\'); % now AFNI can read it as RGB',\n    '% ',\n    '% Also note that the setting by nii_tool(\\'RGBStyle\\') is effective only for',\n    '% current Matlab session. If one clears all or starts a new Matlab session, the',\n    '% default style by nii_tool(\\'default\\') will take effect.',\n    ' ',\n    '% More information for NIfTI format:',\n    '% Official NIfTI website: http://nifti.nimh.nih.gov/',\n    '% Another excellent site: http://brainder.org/2012/09/23/the-nifti-file-format/',\n    '',\n    '% History (yymmdd)',\n    '% 150109 Write it based on Jimmy Shen\\'s NIfTI tool (xiangrui.li@gmail.com)',\n    '% 150202 Include renamed pigz files for Windows to trick Matlab Central',\n    '% 150203 Fix closeFile and deleteTmpFile order',\n    '% 150205 Add hdr.machine: needed for .img fopen',\n    '% 150208 Add 4th input for \\'save\\', allowing to save SPM 3D files',\n    '% 150210 Add \\'cat3D\\' to load SPM 3D files',\n    '% 150226 Assign all 8 char for \\'magic\\' (version 2 needs it)',\n    '% 150321 swapbytes(nByte) for ecode=40 with big endian',\n    '% 150401 Add \\'default\\' to set/query version and rgb_dim default setting',\n    '% 150514 read_ext: decode txt edata by dicm2nii.m',\n    '% 150517 fhandle: provide a way to use gunzipOS etc from outside',\n    '% 150617 auto detect rgb_dim 1&3 for \\'load\\' etc using ChrisR method',\n    '',\n    'persistent C para; % C columns: name, length, format, value, offset',\n    'if isempty(C), [C, para] = niiHeader; end',\n    '',\n    'if ~ischar(cmd)',\n    '    error(\\'Provide a string command as the first input for nii_tool\\');',\n    'end',\n    'if any(cmd==\\'?\\'), subFuncHelp(mfilename, cmd); return; end',\n    '',\n    'if strcmpi(cmd, \\'init\\')',\n    '    if nargin<2, error(\\'nii_tool(\\'\\'%s\\'\\') needs second input\\', cmd); end',\n    '    for i = 1:size(C,1), nii.hdr.(C{i,1}) = C{i,4}; end',\n    '    nii.img = varargin{1};',\n    '    if numel(size(nii.img))>8',\n    '        error(\\'NIfTI img can have up to 7 dimension\\');',\n    '    end',\n    '    if nargin>2',\n    '        i = varargin{2};',\n    '        if i<0 || i>8 || mod(i,1)>0, error(\\'Invalid RGB_dim number\\'); end',\n    '        nii.img = permute(nii.img, [1:i-1 i+1:8 i]); % RGB to dim8',\n    '    end',\n    '    varargout{1} = img2datatype(nii, para); % set datatype etc ',\n    '    ',\n    'elseif strcmpi(cmd, \\'save\\')',\n    '    if nargin<2, error(\\'nii_tool(\\'\\'%s\\'\\') needs second input\\', cmd); end',\n    '    nii = varargin{1};',\n    '    if ~isstruct(nii) || ~isfield(nii, \\'hdr\\') || ~isfield(nii, \\'img\\') ',\n    '        error([\\'nii_tool(\\'\\'save\\'\\') needs a struct from nii_tool(\\'\\'init\\'\\')\\' ...',\n    '            \\' or nii_tool(\\'\\'load\\'\\') as the second input\\']);',\n    '    end',\n    '    ',\n    '    % Check file name to save',\n    '    if nargin>2',\n    '        fname = varargin{2};',\n    '        if length(fname)<5 || ~ischar(fname)',\n    '            error(\\'Invalid name for NIfTI file: %s\\', fname);',\n    '        end',\n    '    elseif isfield(nii.hdr, \\'file_name\\')',\n    '        fname = nii.hdr.file_name;',\n    '    else',\n    '        error(\\'Provide a valid file name as the third input\\');',\n    '    end',\n    '    if ~ispc && strncmp(fname, \\'~/\\', 2) % matlab may err with this abbrevation',\n    '        fname = [getenv(\\'HOME\\') fname(2:end)];',\n    '    end',\n    '    [pth, fname, fext] = fileparts(fname);',\n    '    do_gzip = strcmpi(fext, \\'.gz\\');',\n    '    if do_gzip',\n    '        [~, fname, fext] = fileparts(fname); % get .nii .img .hdr',\n    '    end',\n    '    if isempty(fext), fext = \\'.nii\\'; end % default single .nii file',\n    '    fname = fullfile(pth, fname); % without file ext',\n    '    isNii = strcmpi(fext, \\'.nii\\'); % will use .img/.hdr if not .nii',\n    '    ',\n    '    % Deal with NIfTI version and sizeof_hdr',\n    '    niiVer = para.version;',\n    '    if isfield(nii.hdr, \\'version\\'), niiVer = nii.hdr.version; end',\n    '    if niiVer == 1',\n    '        nii.hdr.sizeof_hdr = 348; % in case it was loaded from other version',\n    '    elseif niiVer == 2',\n    '        nii.hdr.sizeof_hdr = 540; % version 2',\n    '    else ',\n    '        error(\\'Unsupported NIfTI version: %g\\', niiVer);',\n    '    end',\n    '    ',\n    '    if niiVer ~= para.version',\n    '        C0 = niiHeader(niiVer);',\n    '    else',\n    '        C0 = C;',\n    '    end',\n    '    ',\n    '    % Update datatype/bitpix/dim in case nii.img is changed',\n    '    [nii, fmt] = img2datatype(nii, para);',\n    '',\n    '    % This \\'if\\' block: lazy implementation SPM: split to 3D files',\n    '    if nargin>3 && ~isempty(varargin{3}) && varargin{3} && nii.hdr.dim(5)>1',\n    '        if do_gzip, fext = [fext \\'.gz\\']; end',\n    '        nii0 = nii;',\n    '        for i = 1:nii.hdr.dim(5)',\n    '            fname0 = sprintf(\\'%s_%05g%s\\', fname, i, fext);',\n    '            nii0.img = nii.img(:,:,:,i,:,:,:,:); % one vol',\n    '            if i==1 && isfield(nii, \\'ext\\'), nii0.ext = nii.ext;',\n    '            elseif i==2 && isfield(nii0, \\'ext\\'), nii0 = rmfield(nii0, \\'ext\\'); ',\n    '            end',\n    '            nii_tool(\\'save\\', nii0, fname0);',\n    '        end',\n    '        return;',\n    '    end',\n    '        ',\n    '    % re-arrange img for special datatype: RGB/RGBA/Complex.',\n    '    if any(nii.hdr.datatype == [128 511 2304]) % RGB or RGBA',\n    '        if para.rgb_dim == 1 % AFNI style',\n    '            nii.img = permute(nii.img, [8 1:7]);',\n    '        elseif para.rgb_dim == 3 % old mricron style',\n    '            nii.img = permute(nii.img, [1 2 8 3:7]);',\n    '        elseif para.rgb_dim == 4 % for fslview',\n    '            nii.img = permute(nii.img, [1:3 8 4:7]); % violate nii rule',\n    '            dim = size(nii.img);',\n    '            if numel(dim)>6 % dim7 is not 1',\n    '                i = find(dim(5:7)==1, 1, \\'last\\') + 4;',\n    '                nii.img = permute(nii.img, [1:i-1 i+1:8 i]);',\n    '            end',\n    '            nii = img2datatype(nii, para); % changed to non-RGB datatype',\n    '        end',\n    '    elseif any(nii.hdr.datatype == [32 1792]) % complex single/double',\n    '        nii.img = [real(nii.img(:))\\'; imag(nii.img(:))\\'];',\n    '    end',\n    '    ',\n    '    % Check nii extension: update esize to x16',\n    '    nExt = 0; esize = 0;',\n    '    nii.hdr.extension = [0 0 0 0]; % no nii ext',\n    '    if isfield(nii, \\'ext\\') && isstruct(nii.ext) ...',\n    '            && isfield(nii.ext(1), \\'edata\\') && ~isempty(nii.ext(1).edata)',\n    '        nExt = length(nii.ext);',\n    '        nii.hdr.extension = [1 0 0 0]; % there is nii ext',\n    '        for i = 1:nExt',\n    '            if ~isfield(nii.ext(i), \\'ecode\\') || ~isfield(nii.ext(i), \\'edata\\')',\n    '                error(\\'NIfTI header ext struct must have ecode and edata\\');',\n    '            end',\n    '            ',\n    '            n0 = numel(nii.ext(i).edata) + 8; % 8 byte for esize and ecode',\n    '            n1 = ceil(n0/16) * 16; % esize: multiple of 16',\n    '            nii.ext(i).esize = n1;',\n    '            nii.ext(i).edata(end+(1:n1-n0)) = 0; % pad zeros',\n    '            esize = esize + n1;',\n    '        end',\n    '    end',\n    '    ',\n    '    % Set magic, vox_offset, and open file for .nii or .hdr',\n    '    if isNii',\n    '        % version 1 will take only the first 4',\n    '        nii.hdr.magic = sprintf(\\'n+%g%s\\', niiVer, char([0 13 10 26 10]));',\n    '        nii.hdr.vox_offset = nii.hdr.sizeof_hdr + 4 + esize;',\n    '        fid = fopen([fname fext], \\'w\\');',\n    '    else',\n    '        nii.hdr.magic = sprintf(\\'ni%g%s\\', niiVer, char([0 13 10 26 10]));',\n    '        nii.hdr.vox_offset = 0;',\n    '        fid = fopen([fname \\'.hdr\\'], \\'w\\');',\n    '    end',\n    '    ',\n    '    % Write nii hdr',\n    '    for i = 1:size(C0,1)',\n    '        if isfield(nii.hdr, C0{i,1})',\n    '            val = nii.hdr.(C0{i,1});',\n    '        else % niiVer=2 omit some fields, also take care of other cases',\n    '            val = C0{i,4};',\n    '        end',\n    '        n = numel(val);',\n    '        len = C0{i,2};',\n    '        if n>len',\n    '            val(len+1:n) = []; % remove extra, normally for char',\n    '        elseif n<len',\n    '            val(n+1:len) = 0; % pad 0, normally for char',\n    '        end',\n    '        fwrite(fid, val, C0{i,3});',\n    '    end',\n    '    ',\n    '    % Write nii ext: extension is in hdr',\n    '    for i = 1:nExt % nExt may be 0',\n    '        fwrite(fid, nii.ext(i).esize, \\'int32\\');',\n    '        fwrite(fid, nii.ext(i).ecode, \\'int32\\');',\n    '        fwrite(fid, nii.ext(i).edata, \\'uint8\\');',\n    '    end',\n    '    ',\n    '    if ~isNii',\n    '        fclose(fid); % done with .hdr',\n    '        fid = fopen([fname \\'.img\\'], \\'w\\');',\n    '    end',\n    '',\n    '    % Write nii image',\n    '    fwrite(fid, nii.img, fmt);',\n    '    fclose(fid); % all written',\n    '',\n    '    % gzip if asked',\n    '    if do_gzip',\n    '        if isNii',\n    '            gzipOS([fname \\'.nii\\']);',\n    '        else',\n    '            gzipOS([fname \\'.hdr\\']); % better not to compress .hdr',\n    '            gzipOS([fname \\'.img\\']);',\n    '        end',\n    '    end',\n    '    ',\n    'elseif strcmpi(cmd, \\'hdr\\')',\n    '    if nargin<2, error(\\'nii_tool(\\'\\'%s\\'\\') needs second input\\', cmd); end',\n    '    if ~ischar(varargin{1})',\n    '        error(\\'nii_tool(\\'\\'hdr\\'\\') needs nii file name as second input\\'); ',\n    '    end',\n    '    ',\n    '    fname = nii_name(varargin{1}, \\'.hdr\\'); % get .hdr if it is .img',\n    '    [fid, clnObj, niiVer] = fopen_nii(fname); %#ok<ASGLU>',\n    '    varargout{1} = read_hdr(fid, niiVer, C, fname);',\n    '   ',\n    'elseif any(strcmpi(cmd, {\\'ext\\' \\'img\\' \\'load\\'})) ',\n    '    if nargin<2, error(\\'nii_tool(\\'\\'%s\\'\\') needs second input\\', cmd); end',\n    '    if ischar(varargin{1})',\n    '        fname = nii_name(varargin{1}, \\'.hdr\\');',\n    '    elseif isstruct(varargin{1}) && isfield(varargin{1}, \\'file_name\\')',\n    '        fname = varargin{1}.file_name;',\n    '    else        ',\n    '        error([\\'nii_tool(\\'\\'%s\\'\\') needs a file name or hdr struct from \\' ...',\n    '            \\'nii_tool(\\'\\'hdr\\'\\') as second input\\'], cmd); ',\n    '    end',\n    '    ',\n    '    [fid, clnObj, niiVer, isNii] = fopen_nii(fname); %#ok<ASGLU>',\n    '    nii.hdr = read_hdr(fid, niiVer, C, fname);',\n    '    ',\n    '    if strcmpi(cmd, \\'ext\\') || strcmpi(cmd, \\'load\\') ',\n    '        if ~isempty(nii.hdr.extension) && nii.hdr.extension(1)',\n    '            nii.ext = read_ext(fid, nii.hdr);',\n    '            if strcmpi(cmd, \\'ext\\')',\n    '                varargout{1} = nii.ext;',\n    '                return; ',\n    '            end',\n    '        elseif strcmpi(cmd, \\'ext\\')',\n    '            varargout{1} = []; ',\n    '            return; ',\n    '        end',\n    '    end',\n    '    ',\n    '    if strcmpi(cmd, \\'load\\') || strcmpi(cmd, \\'img\\')',\n    '        if ~isNii % close .hdr file, and open .img file',\n    '            fname = nii_name(fname, \\'.img\\');',\n    '            [fid, clnObj] = fopen_nii(fname, nii.hdr.machine); %#ok<NASGU>',\n    '        end',\n    '        nii.img = read_img(fid, nii.hdr, para);',\n    '        if strcmpi(cmd, \\'img\\')',\n    '            varargout{1} = nii.img;',\n    '        else % load',\n    '            varargout{1} = nii;',\n    '        end',\n    '    end',\n    'elseif strcmpi(cmd, \\'RGBStyle\\')',\n    '    styles = {\\'afni\\' \\'\\' \\'mricron\\' \\'fsl\\'};',\n    '    curStyle = styles{para.rgb_dim};',\n    '    if nargin<2, varargout{1} = curStyle; return; end % query only',\n    '    irgb = varargin{1};',\n    '    if isempty(irgb), irgb = 1; end % default as \\'afni\\'',\n    '    if ischar(irgb)',\n    '        if strncmpi(irgb, \\'fsl\\', 3), irgb = 4;',\n    '        elseif strncmpi(irgb, \\'mricron\\', 4), irgb = 3;',\n    '        else irgb = 1;',\n    '        end',\n    '    end',\n    '    if ~any(irgb == [1 3 4])',\n    '        error(\\'nii_tool(\\'\\'RGBStyle\\'\\') can have 1, 3, or 4 as second input\\'); ',\n    '    end',\n    '    if nargout, varargout{1} = curStyle; end % return old one',\n    '    para.rgb_dim = irgb;',\n    'elseif strcmpi(cmd, \\'cat3D\\')',\n    '    if nargin<2, error(\\'nii_tool(\\'\\'%s\\'\\') needs second input\\', cmd); end',\n    '    fnames = varargin{1};',\n    '    if ischar(fnames) % guess it is like run1*.nii',\n    '        f = dir(fnames);',\n    '        f = sort({f.name});',\n    '        fnames = strcat([fileparts(fnames) \\'/\\'], f);',\n    '    end',\n    '    ',\n    '    n = length(fnames);',\n    '    if n<2 || ~iscellstr(fnames)',\n    '        error(\\'Invalid input for nii_tool(\\'\\'cat3D\\'\\'): %s\\', varargin{1});',\n    '    end',\n    '',\n    '    nii = nii_tool(\\'load\\', fnames{1}); % all for first file',\n    '    nii.img(:,:,:,2:n) = 0; % pre-allocate',\n    '    % For now, omit all consistence check between files',\n    '    for i = 2:n, nii.img(:,:,:,i) = nii_tool(\\'img\\', fnames{i}); end',\n    '    varargout{1} = img2datatype(nii, para); % update dim',\n    'elseif strcmpi(cmd, \\'default\\')',\n    '    flds = {\\'version\\' \\'rgb_dim\\'}; % may add more in the future',\n    '    for i = 1:length(flds), val.(flds{i}) = para.(flds{i}); end',\n    '    if nargin<2, varargout{1} = val; return; end % query only',\n    '    if nargout, varargout{1} = val; end % return old val',\n    '    in2 = varargin;',\n    '    if ~isstruct(in2), in2 = struct(in2{:}); end',\n    '    nam = fieldnames(in2);',\n    '    for i = 1:length(nam)',\n    '        if strcmpi(nam{i}, \\'rgb_dim\\')',\n    '            nii_tool(\\'RGBstyle\\', in2.(nam{i}));',\n    '            continue;',\n    '        end',\n    '        ind = strcmpi(nam{i}, flds);',\n    '        if isempty(ind), continue; end',\n    '        para.(flds{ind}) = in2.(nam{i});',\n    '    end',\n    '    if val.version ~= para.version, C = niiHeader(para.version); end',\n    '    ',\n    '    fname = [fileparts(which(mfilename)) \\'/nii_tool_para.mat\\'];',\n    '    fid = fopen(fname, \\'w\\'); % check writing permission',\n    '    if fid<1',\n    '        fname = [getenv(\\'HOME\\') \\'/nii_tool_para.mat\\'];',\n    '    else',\n    '        fclose(fid);',\n    '    end',\n    '    try',\n    '        save(fname, \\'-struct\\', \\'para\\', flds{:}); % overwrite',\n    '    catch me',\n    '        fprintf(2, \\'Failed to save default parameters for future use.\\\\n\\');',\n    '        fprintf(2, \\'%s\\\\n\\', me.message);',\n    '    end',\n    'elseif strcmpi(cmd, \\'func_handle\\') % make a local function avail to outside ',\n    '    varargout{1} = eval([\\'@\\' varargin{1}]);',\n    'else',\n    '    error(\\'Invalid command for nii_tool: %s\\', cmd);',\n    'end',\n    '% End of main function',\n    '',\n    '%% Subfunction: all nii header in the order in NIfTI-1/2 file',\n    'function [C, para] = niiHeader(niiVer)',\n    'rgb_dim = 1;',\n    'if nargin<1 || isempty(niiVer)',\n    '    fname = [getenv(\\'HOME\\') \\'/nii_tool_para.mat\\'];',\n    '    if ~exist(fname, \\'file\\')',\n    '        fname = [fileparts(which(mfilename)) \\'/nii_tool_para.mat\\'];',\n    '    end',\n    '',\n    '    try',\n    '        val = load(fname);',\n    '        niiVer = val.version;',\n    '        rgb_dim = val.rgb_dim;',\n    '    catch',\n    '        niiVer = 1;',\n    '    end',\n    'end',\n    '',\n    'if niiVer == 1',\n    '    C = {',\n    '    % name              len  format     value           offset',\n    '    \\'sizeof_hdr\\'        1   \\'int32\\'     348             0',\n    '    \\'data_type\\'         10  \\'char*1\\'    \\'\\'              4                                          ',\n    '    \\'db_name\\'           18  \\'char*1\\'    \\'\\'              14',\n    '    \\'extents\\'           1   \\'int32\\'     16384           32',\n    '    \\'session_error\\'     1   \\'int16\\'     0               36',\n    '    \\'regular\\'           1   \\'char*1\\'    \\'r\\'             38',\n    '    \\'dim_info\\'          1   \\'uint8\\'     0               39',\n    '    \\'dim\\'               8   \\'int16\\'     ones(1,8)       40',\n    '    \\'intent_p1\\'         1   \\'single\\'    0               56',\n    '    \\'intent_p2\\'         1   \\'single\\'    0               60',\n    '    \\'intent_p3\\'         1   \\'single\\'    0               64',\n    '    \\'intent_code\\'       1   \\'int16\\'     0               68',\n    '    \\'datatype\\'          1   \\'int16\\'     0               70',\n    '    \\'bitpix\\'            1   \\'int16\\'     0               72',\n    '    \\'slice_start\\'       1   \\'int16\\'     0               74',\n    '    \\'pixdim\\'            8   \\'single\\'    zeros(1,8)      76',\n    '    \\'vox_offset\\'        1   \\'single\\'    0               108',\n    '    \\'scl_slope\\'         1   \\'single\\'    1               112',\n    '    \\'scl_inter\\'         1   \\'single\\'    0               116',\n    '    \\'slice_end\\'         1   \\'int16\\'     0               120',\n    '    \\'slice_code\\'        1   \\'uint8\\'     0               122',\n    '    \\'xyzt_units\\'        1   \\'uint8\\'     0               123',\n    '    \\'cal_max\\'           1   \\'single\\'    0               124',\n    '    \\'cal_min\\'           1   \\'single\\'    0               128',\n    '    \\'slice_duration\\'    1   \\'single\\'    0               132',\n    '    \\'toffset\\'           1   \\'single\\'    0               136',\n    '    \\'glmax\\'             1   \\'int32\\'     0               140',\n    '    \\'glmin\\'             1   \\'int32\\'     0               144',\n    '    \\'descrip\\'           80  \\'char*1\\'    \\'\\'              148',\n    '    \\'aux_file\\'          24  \\'char*1\\'    \\'\\'              228',\n    '    \\'qform_code\\'        1   \\'int16\\'     0               252',\n    '    \\'sform_code\\'        1   \\'int16\\'     0               254',\n    '    \\'quatern_b\\'         1   \\'single\\'    0               256',\n    '    \\'quatern_c\\'         1   \\'single\\'    0               260',\n    '    \\'quatern_d\\'         1   \\'single\\'    0               264',\n    '    \\'qoffset_x\\'         1   \\'single\\'    0               268',\n    '    \\'qoffset_y\\'         1   \\'single\\'    0               272',\n    '    \\'qoffset_z\\'         1   \\'single\\'    0               276',\n    '    \\'srow_x\\'            4   \\'single\\'    [1 0 0 0]       280',\n    '    \\'srow_y\\'            4   \\'single\\'    [0 1 0 0]       296',\n    '    \\'srow_z\\'            4   \\'single\\'    [0 0 1 0]       312',\n    '    \\'intent_name\\'       16  \\'char*1\\'    \\'\\'              328',\n    '    \\'magic\\'             4   \\'char*1\\'    \\'\\'              344',\n    '    \\'extension\\'         4   \\'uint8\\'     [0 0 0 0]       348',\n    '    };',\n    '',\n    'elseif niiVer == 2',\n    '    C = {',\n    '    \\'sizeof_hdr\\'        1   \\'int32\\'     540             0',\n    '    \\'magic\\'             8   \\'char*1\\'    \\'\\'              4',\n    '    \\'datatype\\'          1   \\'int16\\'     0               12',\n    '    \\'bitpix\\'            1   \\'int16\\'     0               14',\n    '    \\'dim\\'               8   \\'int64\\'     ones(1,8)       16',\n    '    \\'intent_p1\\'         1   \\'double\\'    0               80',\n    '    \\'intent_p2\\'         1   \\'double\\'    0               88',\n    '    \\'intent_p3\\'         1   \\'double\\'    0               96',\n    '    \\'pixdim\\'            8   \\'double\\'    zeros(1,8)      104',\n    '    \\'vox_offset\\'        1   \\'int64\\'     0               168',\n    '    \\'scl_slope\\'         1   \\'double\\'    1               176',\n    '    \\'scl_inter\\'         1   \\'double\\'    0               184',\n    '    \\'cal_max\\'           1   \\'double\\'    0               192',\n    '    \\'cal_min\\'           1   \\'double\\'    0               200',\n    '    \\'slice_duration\\'    1   \\'double\\'    0               208',\n    '    \\'toffset\\'           1   \\'double\\'    0               216',\n    '    \\'slice_start\\'       1   \\'int64\\'     0               224',\n    '    \\'slice_end\\'         1   \\'int64\\'     0               232',\n    '    \\'descrip\\'           80  \\'char*1\\'    \\'\\'              240',\n    '    \\'aux_file\\'          24  \\'char*1\\'    \\'\\'              320',\n    '    \\'qform_code\\'        1   \\'int32\\'     0               344',\n    '    \\'sform_code\\'        1   \\'int32\\'     0               348',\n    '    \\'quatern_b\\'         1   \\'double\\'    0               352',\n    '    \\'quatern_c\\'         1   \\'double\\'    0               360',\n    '    \\'quatern_d\\'         1   \\'double\\'    0               368',\n    '    \\'qoffset_x\\'         1   \\'double\\'    0               376',\n    '    \\'qoffset_y\\'         1   \\'double\\'    0               384',\n    '    \\'qoffset_z\\'         1   \\'double\\'    0               392',\n    '    \\'srow_x\\'            4   \\'double\\'    [1 0 0 0]       400',\n    '    \\'srow_y\\'            4   \\'double\\'    [0 1 0 0]       432',\n    '    \\'srow_z\\'            4   \\'double\\'    [0 0 1 0]       464',\n    '    \\'slice_code\\'        1   \\'int32\\'     0               496',\n    '    \\'xyzt_units\\'        1   \\'int32\\'     0               500',\n    '    \\'intent_code\\'       1   \\'int32\\'     0               504',\n    '    \\'intent_name\\'       16  \\'char*1\\'    \\'\\'              508',\n    '    \\'dim_info\\'          1   \\'uint8\\'     0               524',\n    '    \\'unused_str\\'        15  \\'char*1\\'    0               525',\n    '    \\'extension\\'         4   \\'uint8\\'     [0 0 0 0]       540',\n    '    };',\n    'else',\n    '    error(\\'Nifti version %g is not supported\\', niiVer);',\n    'end',\n    'if nargout<2, return; end',\n    '',\n    '%   class      datatype bitpix  valpix',\n    'D = {',\n    '    \\'ubit1\\'     1       1       1 % neither mricron nor fsl support this',\n    '    \\'uint8\\'     2       8       1',\n    '    \\'int16\\'     4       16      1',\n    '    \\'int32\\'     8       32      1',\n    '    \\'single\\'    16      32      1',\n    '    \\'single\\'    32      64      2 % complex',\n    '    \\'double\\'    64      64      1',\n    '    \\'uint8\\'     128     24      3 % RGB',\n    '    \\'int8\\'      256     8       1',\n    '    \\'single\\'    511     96      3 % RGB, not in NIfTI standard?',\n    '    \\'uint16\\'    512     16      1',\n    '    \\'uint32\\'    768     32      1',\n    '    \\'int64\\'     1024    64      1',\n    '    \\'uint64\\'    1280    64      1',\n    '%     \\'float128\\'  1536    128     1 % long double, for 22nd century?',\n    '    \\'double\\'    1792    128     2 % complex',\n    '%     \\'float128\\'  2048    256     2 % long double complex',\n    '    \\'uint8\\'     2304    32      4 % RGBA',\n    '    };',\n    '',\n    'para.format   =  D(:,1)\\';',\n    'para.datatype = [D{:,2}];',\n    'para.bitpix   = [D{:,3}];',\n    'para.valpix   = [D{:,4}];',\n    'para.rgb_dim  = rgb_dim; % dim of RGB/RGBA in NIfTI FILE',\n    'para.version  = niiVer;',\n    '',\n    '%% Subfunction: update hdr based on image class for \\'init\\' and \\'save\\'',\n    'function [nii, fmt] = img2datatype(nii, para)',\n    'dim = size(nii.img);',\n    'ndim = numel(dim);',\n    'dim(ndim+1:7) = 1;',\n    '',\n    'if ndim == 8 % RGB/RGBA data, we change img type to uint8 or single if needed',\n    '    valpix = dim(8);',\n    '    if valpix == 4 % RGBA',\n    '        typ = \\'RGBA\\'; % error info only',\n    '        nii.img = uint8(nii.img); % NIfTI only support uint8 for RGBA',\n    '    elseif valpix == 3 % RGB, must be single or uint8',\n    '        typ = \\'RGB\\';',\n    '        if max(nii.img(:))>1, nii.img = uint8(nii.img);',\n    '        else nii.img = single(nii.img);',\n    '        end',\n    '    else',\n    '        error(\\'Color dimension must have length of 3 for RGB and 4 for RGBA\\');',\n    '    end',\n    '',\n    '    dim(8) = []; % remove color-dim so numel(dim)=7 for nii.hdr',\n    '    ndim = find(dim>1, 1, \\'last\\'); % update it',\n    'elseif isreal(nii.img)',\n    '    typ = \\'real\\';',\n    '    valpix = 1; ',\n    'else',\n    '    typ = \\'complex\\';',\n    '    valpix = 2; ',\n    'end',\n    '',\n    'if islogical(nii.img), imgFmt = \\'ubit1\\'; ',\n    'else imgFmt = class(nii.img);',\n    'end',\n    'ind = find(strcmp(para.format, imgFmt) & para.valpix==valpix);',\n    '',\n    'if isempty(ind) % only RGB and complex can have this problem',\n    '    error(\\'nii_tool does not support %s image of \\'\\'%s\\'\\' type\\', typ, imgFmt);',\n    'elseif numel(ind)>1 % unlikely',\n    '    error(\\'Non-unique datatype found for %s image of \\'\\'%s\\'\\' type\\', typ, imgFmt);',\n    'end',\n    '',\n    'fmt = para.format{ind};',\n    'nii.hdr.datatype = para.datatype(ind);',\n    'nii.hdr.bitpix = para.bitpix(ind);',\n    'nii.hdr.dim = [ndim dim];',\n    '',\n    'if nii.hdr.sizeof_hdr == 348',\n    '    nii.hdr.glmax = round(double(max(nii.img(:)))); % we may remove these',\n    '    nii.hdr.glmin = round(double(min(nii.img(:))));',\n    'end',\n    '',\n    '%% Subfunction: use pigz or system gzip if available (faster)',\n    'function gzipOS(fname)',\n    'persistent cmd; % command to run gzip',\n    'if isempty(cmd)',\n    '    cmd = check_gzip;',\n    '    if ischar(cmd)',\n    '    \tcmd = [cmd \\' -f \\']; % overwrite if exist',\n    '    elseif islogical(cmd) && ~cmd',\n    '        fprintf(2, [\\'None of system pigz, gzip or Matlab gzip available. \\' ...',\n    '            \\'Files are not compressed into gz.\\\\n\\']);',\n    '    end',\n    'end',\n    '',\n    'if islogical(cmd)',\n    '    if cmd, gzip(fname); delete(fname); end',\n    '    return;',\n    'end',\n    'if ispc',\n    '\t[err, str] = system([\\'start \"\" /B \\' cmd \\'\"\\' fname \\'\"\\']); % background',\n    'else',\n    '    [err, str] = system([cmd \\'\"\\' fname \\'\" &\\']);',\n    'end',\n    '% [err, str] = system([cmd \\'\"\\' fname \\'\"\\']);',\n    'if err, errorLog([\\'Error during compression: \\' str]); end',\n    '',\n    '% Deal with pigz/gzip on path or in nii_tool folder, and matlab gzip/gunzip',\n    'function cmd = check_gzip',\n    '% first, try system pigz',\n    '[err, ~] = system(\\'pigz -V 2>&1\\');',\n    'if ~err, cmd = \\'pigz -n\\'; return; end',\n    '',\n    '% next, try pigz included with nii_tool',\n    'm_dir = fileparts(which(mfilename));',\n    'if ismac % pigz for mac is not included in the package',\n    '    fprintf(2, [\\' Please install pigz for fast compression: \\' ...',\n    '        \\'http://rudix.org/packages/pigz.html\\\\n\\']);',\n    'elseif ispc % rename back pigz for Windows. Renamed to trick Matlab Central',\n    '    try %#ok<TRYNC>',\n    '        fname = [m_dir \\'\\\\pigz.win\\'];',\n    '        if exist(fname, \\'file\\')',\n    '            movefile(fname, [m_dir \\'\\\\pigz.exe\\'], \\'f\\');',\n    '        end',\n    '        fname = [m_dir \\'\\\\pthreadGC2.win\\'];',\n    '        if exist(fname, \\'file\\')',\n    '            movefile(fname, [m_dir \\'\\\\pthreadGC2.dll\\'], \\'f\\');',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'cmd = fullfile(m_dir, \\'pigz -n\\');',\n    '[err, ~] = system([cmd \\' -V 2>&1\\']);',\n    'if ~err, return; end',\n    '',\n    '% Third, try system gzip',\n    '[err, ~] = system(\\'gzip -V 2>&1\\'); % gzip on system path?',\n    'if ~err, cmd = \\'gzip -n\\'; return; end',\n    '',\n    '% Lastly, try to use Matlab gzip/gunzip. Check only one, since they are paired',\n    'if isempty(which(\\'gunzip\\')) || ~usejava(\\'jvm\\')',\n    '    cmd = false; % none of de/compress tools available',\n    '    return;',\n    'end',\n    '    ',\n    'cmd = true; % use slower matlab gzip/gunzip',\n    '',\n    '%% Try to use in order of pigz, system gunzip, then matlab gunzip',\n    'function outName = gunzipOS(fname)',\n    'persistent cmd; % command to run gupzip',\n    'if isempty(cmd)',\n    '    cmd = check_gzip;',\n    '    if ischar(cmd)',\n    '    \tcmd = [cmd \\' -f -d \\']; % overwrite if exist',\n    '    elseif islogical(cmd) && ~cmd',\n    '        error(\\'None of system pigz, gunzip or Matlab gunzip is available\\');',\n    '    end',\n    'end',\n    'pth = tempdir; % unzip into temp dir',\n    '',\n    'if islogical(cmd)',\n    '    if cmd, outName = gunzip(fname, pth); end',\n    '    return;',\n    'end',\n    '',\n    '[pth1, outName, ext] = fileparts(fname);',\n    'outName = fullfile(pth, outName);',\n    'if ~strcmp([pth1 filesep], pth), copyfile(fname, [outName ext], \\'f\\'); end',\n    '[err, str] = system([cmd \\'\"\\' outName ext \\'\"\\']); % overwrite if exist',\n    'if err, fprintf(2, \\'Error during decompression:\\\\n%s\\\\n\\', str); end',\n    '',\n    '%% subfunction: read hdr',\n    'function hdr = read_hdr(fid, niiVer, C, fname)',\n    'if niiVer>1, C = niiHeader(niiVer); end % C defaults for version 1',\n    'fseek(fid, 0, \\'bof\\');',\n    'for i = 1:size(C,1)',\n    '    hdr.(C{i,1}) = fread(fid, C{i,2}, C{i,3})\\';',\n    '    if strcmp(C{i,3}, \\'char*1\\')',\n    '        hdr.(C{i,1}) = deblank(char(hdr.(C{i,1})));',\n    '    end',\n    'end',\n    '',\n    'hdr.version = niiVer; % for \\'save\\', unless user asks to change',\n    '[~, ~, hdr.machine]= fopen(fid); % use it for .img file',\n    '',\n    '[pth, nam, ext] = fileparts(fname); % fname may be .gz',\n    'if isempty(pth)',\n    '    [pth, nam, ext] = fileparts(which(fname)); % in current folder or path',\n    'end',\n    'pth = fullfile(getfield(what(pth), \\'path\\')); % full path',\n    'hdr.file_name = fullfile(pth, [nam ext]); % fname with full path',\n    '',\n    '%% subfunction: read ext, and decode it if known ecode',\n    'function ext = read_ext(fid, hdr)',\n    'ext = []; % to avoid error, such as no ext but hdr.extension(1) was set',\n    'fseek(fid, hdr.sizeof_hdr+4, \\'bof\\'); % +4 skip hdr.extension',\n    'nEnd = hdr.vox_offset;',\n    'if nEnd == 0 % .hdr file',\n    '    nEnd = getfield(dir(fopen(fid)), \\'bytes\\'); % total bytes of the .hdr file',\n    'end',\n    'i = 1; % nExt. It would be nice if hdr.extension(2) stores nExt',\n    'while ftell(fid) < nEnd',\n    '    esize = fread(fid, 1, \\'int32\\'); % multiple of 16',\n    '    if isempty(esize) || mod(esize,16), break; end % just to be safe',\n    '    ext(i).esize = esize; %#ok<*AGROW>',\n    '    ext(i).ecode = fread(fid, 1, \\'int32\\'); ',\n    '    ext(i).edata = fread(fid, ext(i).esize-8, \\'*uint8\\'); % -8 for esize & ecode',\n    '',\n    '    % Decode edata if we know ecode',\n    '    if ext(i).ecode == 40 % Matlab: any kind of matlab variable',\n    '        nByte = typecast(ext(i).edata(1:4), \\'int32\\'); % num of bytes of MAT data',\n    '        if strcmp(hdr.machine, \\'ieee-be\\'), nByte = swapbytes(nByte); end',\n    '        tmp = [tempname \\'.mat\\']; % temp MAT file to save edata',\n    '        fid1 = fopen(tmp, \\'w\\');',\n    '        fwrite(fid1, ext(i).edata(5:nByte+4)); % exclude padded zeros',\n    '        fclose(fid1);',\n    '        deleteMat = onCleanup(@() delete(tmp)); % delete temp file after done',\n    '        ext(i).edata_decoded = load(tmp); % load into struct',\n    '    elseif ext(i).ecode == 6 % plain text',\n    '        str = char(ext(i).edata\\');',\n    '        if isempty(strfind(str, \\'dicm2nii.m\\'))',\n    '            ext(i).edata_decoded = deblank(str);',\n    '        else % created by dicm2nii.m',\n    '            ss = struct;',\n    '            ind = strfind(str, [\\';\\' char([0 10])]); % strsplit error in Octave',\n    '            ind = [-2 ind]; % -2+3=1: start of first para',\n    '            for j = 1:numel(ind)-1',\n    '                a = str(ind(j)+3 : ind(j+1));',\n    '                a(a==0) = []; % to be safe. strtrim wont remove null',\n    '                a = strtrim(a);',\n    '                if isempty(a), continue; end',\n    '                try ',\n    '                    eval([\\'ss.\\' a]); % put all into struct',\n    '                catch me',\n    '                    fprintf(2, \\'%s\\\\n\\', me.message);',\n    '                    fprintf(2, \\'Unrecognized text: %s\\\\n\\', a);',\n    '                end',\n    '            end',\n    '            flds = fieldnames(ss); % make all vector column',\n    '            for j = 1:length(flds)',\n    '                val = ss.(flds{j});',\n    '                if isnumeric(val) && isrow(val), ss.(flds{j}) = val\\'; end',\n    '            end',\n    '            ext(i).edata_decoded = ss;',\n    '        end',\n    '    elseif ext(i).ecode == 4 % AFNI',\n    '        ext(i).edata_decoded = deblank(char(ext(i).edata)\\');',\n    '    elseif ext(i).ecode == 2 % dicom',\n    '        no_dicm_hdr = isempty(which(\\'dicm_hdr\\'));',\n    '        if no_dicm_hdr && isempty(which(\\'dicominfo\\')), return; end ',\n    '        tmp = [tempname \\'.dcm\\'];',\n    '        fid1 = fopen(tmp, \\'w\\');',\n    '        fwrite(fid1, ext(i).edata);',\n    '        fclose(fid1);',\n    '        deleteDcm = onCleanup(@() delete(tmp));',\n    '        if no_dicm_hdr',\n    '            ext(i).edata_decoded = dicominfo(tmp);',\n    '        else',\n    '            ext(i).edata_decoded = dicm_hdr(tmp);',\n    '        end',\n    '    end',\n    '    i = i + 1;',\n    'end',\n    '',\n    '%% subfunction: read img',\n    'function img = read_img(fid, hdr, para)',\n    'ind = para.datatype == hdr.datatype;',\n    'if ~any(ind)',\n    '    error(\\'Datatype %g is not supported by nii_tool.\\', hdr.datatype);',\n    'end',\n    '',\n    'dim = hdr.dim(2:8);',\n    'dim(hdr.dim(1)+1:7) = 1; % avoid some error in file',\n    'dim(dim<1) = 1;',\n    'valpix = para.valpix(ind);',\n    'n = prod(dim); % num of values',\n    'fseek(fid, hdr.vox_offset, \\'bof\\');',\n    'img = fread(fid, n*valpix, [\\'*\\' para.format{ind}]); % * to keep original class',\n    '',\n    'if any(hdr.datatype == [128 511 2304]) % RGB or RGBA',\n    '    a = reshape(single(img), valpix, n); % assume rgbrgbrgb...',\n    '    d1 = abs(a - a(:,[2:end 1])); % how similar are voxels to their neighbor',\n    '    a = reshape(a, prod(dim(1:2)), valpix*prod(dim(3:7))); % rr...rgg...gbb...b',\n    '    d2 = abs(a - a([2:end 1],:));',\n    '    j = (sum(d1(:))>sum(d2(:)))*2 + 1; % 1 for afni, 3 for mricron',\n    '    dim = [dim(1:j-1) valpix dim(j:7)]; % length=8 now',\n    '    img = reshape(img, dim);',\n    '    img = permute(img, [1:j-1 j+1:8 j]); % put RGB(A) to dim8',\n    'elseif any(hdr.datatype == [32 1792]) % complex single/double',\n    '    img = reshape(img, [2 dim]);',\n    '    img = complex(permute(img(1,:,:,:,:,:,:,:), [2:8 1]), ... % real',\n    '                  permute(img(2,:,:,:,:,:,:,:), [2:8 1]));    % imag',\n    'else % all others: valpix=1',\n    '    if hdr.datatype==1, img = logical(img); end',\n    '    img = reshape(img, dim);',\n    'end',\n    '',\n    '%% Return requested fname with ext, useful for .hdr and .img files',\n    'function fname = nii_name(fname, ext)',\n    '[~, f, e] = fileparts(fname);',\n    'n = length(fname);',\n    'if strcmpi(e, \\'.gz\\')',\n    '    n = n - 3; % 3 is length(\\'.gz\\')',\n    '    [~, ~, e] = fileparts(f); % .nii/.hdr/.img',\n    'end',\n    'if strcmpi(e, \\'.nii\\') || strcmpi(e, ext), return; end',\n    'if ~strcmpi(e, \\'.hdr\\') && ~strcmpi(e, \\'.img\\')',\n    '    error([\\'Invalid NIfTI file name: \\' fname]); ',\n    'end',\n    'fname(n+(-3:0)) = ext; % if not return or error, change it',\n    ' ',\n    '%% fopen NIfTI file, check endian, niiVer and nii/hdr by \\'magic\\' for header file',\n    '% clnObj takes care of fclose(fid) and delete(fopen(fid)) if isGz ',\n    'function [fid, clnObj, niiVer, isNii] = fopen_nii(fname, endian)',\n    'if nargin<2, endian = \\'ieee-le\\'; end % only provided for .img fopen',\n    '[fid, err] = fopen(fname, \\'r\\', endian);',\n    'if fid<1, error([err \\': \\' fname]); end',\n    '',\n    'n = fread(fid, 4, \\'*uint8\\')\\'; % sizeof_hdr or signature',\n    'isGz = isequal(n(1:2), [31 139]); % gz, tgz, tar file',\n    'fnameIn = fname; % for error msg',\n    'if isGz',\n    '    fclose(fid); % close .gz file',\n    '    fname = gunzipOS(fname); % guzipped file, return unzipped fname',\n    '    fid = fopen(fname, \\'r\\', endian);',\n    '    n = fread(fid, 4, \\'*uint8\\')\\';',\n    'end',\n    '',\n    'if nargout<3 % must return here for .img',\n    '    clnObj = onCleanup(@()closeFile(fid, isGz));',\n    '    return;',\n    'end',\n    '',\n    '% NIfTI: isBigEndian = dim(1)<0 || dim(1)>7; ',\n    'if isequal(n, [92 1 0 0]) % LE 348, nifti 1 ',\n    '    niiVer = 1;',\n    'elseif isequal(n, [0 0 1 92]) % BE 348, nifti 1',\n    '    niiVer = 1;',\n    '    fclose(fid);',\n    '    fid = fopen(fname, \\'r\\', \\'ieee-be\\');',\n    'elseif isequal(n, [28 2 0 0]) % LE 540, nifti 2',\n    '    niiVer = 2;',\n    'elseif isequal(n, [0 0 2 28]) % BE 540, nifti 2',\n    '    niiVer = 2;',\n    '    fclose(fid);',\n    '    fid = fopen(fname, \\'r\\', \\'ieee-be\\');',\n    'else',\n    '    fclose(fid);',\n    '    error(\\'Not valid NIfTI file: %s\\', fnameIn);',\n    'end',\n    'clnObj = onCleanup(@()closeFile(fid, isGz)); % return it to auto-close file',\n    '',\n    'if niiVer == 1, fseek(fid, 344, \\'bof\\'); end',\n    'magic = fread(fid, 3, \\'*char\\')\\';',\n    'vStr = num2str(niiVer);',\n    'if strcmp(magic, [\\'n+\\' vStr])',\n    '    isNii = true;',\n    'elseif strcmp(magic, [\\'ni\\' vStr])',\n    '    isNii = false;',\n    'else % likely wrong magic. Warn user and use file ext for nii detection',\n    '    fprintf(2, \\'Inconsistent sizeof_hdr and magic string for file %s\\\\n\\', fnameIn);',\n    '    fprintf(2, \\'sizeof_hdr: %g; magic: %s\\\\n\\', typecast(n, \\'int32\\'), magic);',\n    '    isNii = strcmpi(fname(end+(-3:0)), \\'.nii\\');',\n    'end',\n    '',\n    '%% fclose and delete ungzipped file if isGz',\n    'function closeFile(fid, isGz)',\n    'if isGz % close fid then delete tmp',\n    '    fname = fopen(fid); % ungzipped file',\n    '    fclose(fid);',\n    '    delete(fname);',\n    'else % only close fid',\n    '    fclose(fid);',\n    'end',\n    '',\n    '%% subfunction: get help for a command',\n    'function subFuncHelp(mfile, subcmd)',\n    'fid = fopen(which(mfile));',\n    'if fid<1, error(\\' %s not exists.\\', mfile); end',\n    'clnObj = onCleanup(@()fclose(fid));',\n    'while 1 % find first % line',\n    '    ln = strtrim(fgetl(fid));',\n    '    if feof(fid), fprintf(2, \\' No help text found.\\\\n\\'); return; end',\n    '    if ~isempty(ln) && ln(1) == \\'%\\', break; end',\n    'end',\n    '',\n    'cr = char(10);',\n    'str = [ln(2:end) cr];',\n    'while 1',\n    '    ln = strtrim(fgetl(fid));',\n    '    if isempty(ln) || ln(1) ~= \\'%\\', break; end % first non % line',\n    '    str = [str ln(2:end) cr];',\n    'end',\n    '',\n    '% detect topic line before formating the str: try each in order',\n    'topicChar = [cr \\' - \\']; % we rely on this for each topic: see help',\n    'str = strrep(str, [cr \\' -- \\'], topicChar); % \\' -- \\' is also fine',\n    'ind = strfind(str, topicChar);',\n    'if isempty(ind), disp(str); return; end % no topicChar found. Show all help text',\n    '',\n    'fakeChar = repmat(char(1), 1, numel(topicChar));',\n    'str = strrep(str, topicChar, fakeChar); % will restore later',\n    '',\n    '% format for reliable syntax and paragraph detection (order is important):',\n    'cr1 = [cr \\' \\']; % cr with a space',\n    'chars = {[mfile \\'  \\']   [mfile \\' \\']; % reduce multiple space after mfile to one',\n    '         [mfile \\' (\\']   [mfile \\'(\\']; % remove space between mfile and (',\n    '         [mfile \\'( \\']   [mfile \\'(\\']; % remove space after mfile(',\n    '         [cr \\'    \\']    [cr char(9)]; % replace 4 space with tab for beauty',\n    '         cr1            cr; % remove space after cr',\n    '         };',\n    'for i = 1:size(chars, 1)',\n    '    while ~isempty(strfind(str, chars{i,1}))',\n    '        str = strrep(str, chars{i,1}, chars{i,2}); % regexprep error in Octave',\n    '    end',\n    'end',\n    'str = strrep(str, cr, cr1); % restore one space after cr',\n    '',\n    'dashes = strfind(str, fakeChar); % index for \\' - \\' after formating',\n    'str = strrep(str, fakeChar, topicChar); % restore \\' - \\'',\n    '',\n    'prgrfs = strfind(str, [cr1 cr1]); % double blank lines',\n    'nTopic = numel(dashes);',\n    'topics = ones(1, nTopic+1); % syntax \\'mfile(\\' before each \\'-\\' line',\n    'for i = 1:nTopic',\n    '    ind = strfind(str(1:dashes(i)), [mfile \\'(\\']); % syntax before \\' - \\'',\n    '    if isempty(ind), continue; end % no syntax before \\' - \\', assume start with 1',\n    '    ind = find(prgrfs < ind(end), 1, \\'last\\'); % previous paragraph',\n    '    if isempty(ind), continue; end',\n    '    topics(i) = prgrfs(ind) + 1; % start of this topic ',\n    'end',\n    'topics(nTopic+1) = length(str); % set last topic to the end',\n    '',\n    'cmd = strrep(subcmd, \\'?\\', \\'\\'); % remove ? in case it is in subcmd',\n    'if isempty(cmd) % help for main function',\n    '    disp(str(1:topics(1))); % text before first topic',\n    '    return;',\n    'end',\n    '',\n    '% find a topic with cmd syntax, and the syntax is prior to \\' - \\'',\n    'cmd = sprintf(\\'%s(\\'\\'%s\\'\\'\\', mfile, cmd);',\n    'for i = 1:nTopic',\n    '    ind = strfind(lower(str(topics(i):dashes(i))), lower(cmd));',\n    '    if ~isempty(ind) % found the syntax in the topic',\n    '        disp(str(topics(i):topics(i+1)));',\n    '        return;',\n    '    end',\n    'end',\n    '',\n    '% if we reach here, no subcmd found in syntax',\n    'fprintf(2, \\' Unknown command for %s: %s\\\\n\\', mfile, subcmd);'\n  )\n\n  dicm2nii <- c(\n    'function varargout = dicm2nii(src, dataFolder, varargin)',\n    '% Convert dicom and more into nii or img/hdr files. ',\n    '% ',\n    '% DICM2NII(dcmSource, niiFolder, outFormat, MoCoOption)',\n    '% ',\n    '% The input arguments are all optional:',\n    '%  1. source file or folder. It can be a zip or tgz file, a folder containing',\n    '%     dicom files, or other convertible files. It can also contain wildcards',\n    '%     like \\'run1_*\\' for all files start with \\'run1_\\'.',\n    '%  2. folder to save result files.',\n    '%  3. output file format:',\n    '%      0 or \\'nii\\'           for single nii uncompressed.',\n    '%      1 or \\'nii.gz\\'        for single nii compressed (default).',\n    '%      2 or \\'hdr\\'           for hdr/img pair uncompressed.',\n    '%      3 or \\'hdr.gz\\'        for hdr/img pair compressed.',\n    '%      4 or \\'3D.nii\\'        for 3D nii uncompressed (SPM12).',\n    '%      5 or \\'3D.nii.gz\\'     for 3D nii compressed.',\n    '%      6 or \\'3D.hdr\\'        for 3D hdr/img pair uncompressed (SPM8).',\n    '%      7 or \\'3D.hdr.gz\\'     for 3D hdr/img pair compressed.',\n    '%  4. MoCo series options:',\n    '%      0 create files for both original and MoCo series.',\n    '%      1 ignore MoCo series if both present (default).',\n    '%      2 ignore original series if both present.',\n    '%     Note that if only one of the two series is present, it will be converted',\n    '%     always. In the future, this option may be removed, and all files will be',\n    '%     converted. ',\n    '% ',\n    '% The optional output is converted PatientName(s).',\n    '% ',\n    '% Typical examples:',\n    '%  dicm2nii; % bring up user interface if there is no input argument',\n    '%  dicm2nii(\\'D:/myProj/zip/subj1.zip\\', \\'D:/myProj/subj1/data\\'); % zip file',\n    '%  dicm2nii(\\'D:/myProj/subj1/dicom/\\', \\'D:/myProj/subj1/data\\'); % folder',\n    '% ',\n    '% Less useful examples:',\n    '%  dicm2nii(\\'D:/myProj/dicom/\\', \\'D:/myProj/subj2/data\\', \\'nii\\'); % no gz compress',\n    '%  dicm2nii(\\'D:/myProj/dicom/run2*\\', \\'D:/myProj/subj/data\\'); % convert run2 only',\n    '%  dicm2nii(\\'D:/dicom/\\', \\'D:/data\\', \\'3D.nii\\'); % SPM style files',\n    '% ',\n    '% If there is no input, or any of the first two input is empty, the graphic user',\n    '% interface will appear.',\n    '% ',\n    '% If the first input is a zip/tgz file, such as those downloaded from dicom',\n    '% server, DICM2NII will extract files into a temp folder, create NIfTI files',\n    '% into the data folder, and then delete the temp folder. For this reason, it is',\n    '% better to keep the compressed file as backup.',\n    '% ',\n    '% If a folder is the data source, DICM2NII will convert all files in the folder',\n    '% and its subfolders (there is no need to sort files for different series).',\n    '% ',\n    '% Please note that, if a file in the middle of a series is missing, the series',\n    '% will normally be skipped without converting, and a warning message in red text',\n    '% will be shown in Command Windows, and the message will also be saved into a',\n    '% text file under the data folder.',\n    '% ',\n    '% For MoCo series, motion parameters, RBMoCoTrans and RBMoCoRot, are also saved.',\n    '% ',\n    '% A Matlab data file, dcmHeaders.mat, is always saved into the data folder. This',\n    '% file contains dicom header from the first file for created series and some',\n    '% information from last file in field LastFile. Some extra information may also',\n    '% be saved into this file.',\n    '% ',\n    '% Slice timing information, if available, is stored in nii header, such as',\n    '% slice_code and slice_duration. But the simple way may be to use the field',\n    '% SliceTiming in dcmHeaders.mat. That timing is actually those numbers for FSL',\n    '% when using custom slice timing. This is the universal method to specify any',\n    '% kind of slice order, and for now, is the only way which works for multiband.',\n    '% Slice order is one of the most confusing parameters, and it is recommended to',\n    '% use this method to avoid mistake. Following shows how to convert this timing',\n    '% into slice timing in ms and slice order for SPM:',\n    '%   ',\n    '%  load(\\'dcmHeaders.mat\\'); % or drag and drop the MAT file into Matlab',\n    '%  s = h.myFuncSeries; % field name is the same as nii file name',\n    '%  spm_ms = (0.5 - s.SliceTiming) * s.RepetitionTime;',\n    '%  [~, spm_order] = sort(-s.SliceTiming);',\n    '% ',\n    '% Some information, such as TE, phase encoding direction and effective dwell',\n    '% time are stored in descrip of nii header. These are useful for fieldmap B0',\n    '% unwarp correction. Acquisition start time and date are also stored, and this',\n    '% may be useful if one wants to align the functional data to some physiological',\n    '% recording, like pulse, respiration or ECG.',\n    '% ',\n    '% If there is DTI series, bval and bvec files will be generated for FSL etc. For',\n    '% DTI series, B_value and DiffusionGradientDirection for all directions are',\n    '% saved into the dcmHeaders.mat file.',\n    '% ',\n    '% Starting from 20150514, the converter stores some useful information in NIfTI',\n    '% text extension (ecode=6). nii_tool can decode these information easily:',\n    '%  ext = nii_tool(\\'ext\\', \\'myNiftiFile.nii\\'); % read NIfTI extension',\n    '% ext.edata_decoded contains all above mentioned information, and more.',\n    '% ',\n    '% Please note that some information, such as the slice order information, phase',\n    '% encoding direction and DTI bvec are in image reference, rather than NIfTI',\n    '% coordinate system. This is because most analysis packages require information',\n    '% in image space. For this reason, in case the image in a NIfTI file is flipped',\n    '% or re-oriented, these information may not be correct anymore.',\n    '% ',\n    '% The output file names adopt SeriesDescription or ProtocolName of each series',\n    '% used on scanner console. If both original and MoCo series are requested,',\n    '% \\'_MoCo\\' will be appended for MoCo series. For phase image, such as those from',\n    '% field map, \\'_phase\\' will be appended to the name. If multiple subjects data',\n    '% are mixed (strongly discouraged), subject name will be in file name. In case',\n    '% of name conflict, SeriesNumber, such as \\'_s005\\', will be appended to make file',\n    '% names unique. It is suggested to use short and descriptive SeriesDescription',\n    '% on the scanner console, and use names containing only letters, numbers and',\n    '% underscores.',\n    '% ',\n    '% For SPM 3D files, the file names will have volume index in format of \\'_00001\\'',\n    '% appended to above name.',\n    '% ',\n    '% Please report any bug to xiangrui.li@gmail.com or at',\n    '% http://www.mathworks.com/matlabcentral/fileexchange/42997',\n    '',\n    '% Thanks to:',\n    '% Jimmy Shen\\'s Tools for NIfTI and ANALYZE image,',\n    '% Chris Rorden\\'s dcm2nii pascal source code,',\n    '% Przemyslaw Baranski for direction cosine matrix to quaternions. ',\n    '',\n    '% History (yymmdd):',\n    '% 130512 Publish to CCBBI users (Xiangrui Li).',\n    '% 130513 Convert img from uint16 to int16 if range allows;',\n    '%        Support output file format of img/hdr/mat.',\n    '% 130515 Change creation order to acquisition order (more natural).',\n    '%        If MoCo series is included, append _MoCo in file names.',\n    '% 130516 Use SpacingBetweenSlices, if exists, for SliceThickness. ',\n    '% 130518 Use NumberOfImagesInMosaic in CSA header (work for some old data).',\n    '% 130604 Add scl_inter/scl_slope and special naming for fieldmap.',\n    '% 130614 Work out the way to get EffectiveEchoSpacing for B0 unwarp.',\n    '% 130616 Add needed dicom field check, so it won\\'t err later.',\n    '% 130618 Reorient if non-mosaic or slice_dim is still 3 and no slice flip.',\n    '% 130619 Simplify DERIVED series detection. No \\'_mag\\' in fieldmap name.',\n    '% 130629 Improve the method to get phase direction;',\n    '%        Permute img dim1&2 (no -90 rotation) & simplify xform accordingly.',\n    '% 130711 Make MoCoOption smarter: create nii if only 1 of 2 series exists.',\n    '% 130712 Remove 5th input (allHeader). Save memory by using partial header.',\n    '% 130712 Bug fix: dim_info with reorient. No problem since no EPI reorient.',\n    '% 130715 Use 2 slices for xform. No slice flip needed except revNum mosaic.',\n    '% 130716 Take care of lower/upper cases for output file names;',\n    '%        Apply scl_slope and inter to img if range allows and no rounding;',\n    '%        Save motion parameters, if any, into dcmHeader.mat.',\n    '% 130722 Ugly fix for isMos, so it works for \\'2004A 4VA25A\\' phase data;',\n    '%        Store dTE instead of TE if two TE are used, such as fieldmap.',\n    '% 130724 Add two more ways for dwell time, useful for \\'2004A 4VA25A\\' dicom.',\n    '% 130801 Can\\'t use DERIVED since MoCoSeries may be labeled as DERIVED.',\n    '% 130807 Check PixelSpacing consistency for a series;',\n    '%        Prepare to publish to Matlab Central.',\n    '% 130809 Add 5th input for subjName, so one can choose a subject.',\n    '% 130813 Store ImageComments, if exists and is meaningful, into aux_file.',\n    '% 130818 Expand source to dicom file(s) and wildcards like run1*.dcm.',\n    '%        Update fields in dcmHeader.mat, rather than overwriting the file.',\n    '%        Include save_nii etc in the code for easy distribution.',\n    '% 130821 Bug fix for cellstr input as dicom source.',\n    '%        Change file name from dcm2nii.m to reduce confusion from MRICron.',\n    '%        GUI implemented into the single file.',\n    '% 130823 Remove dependency on Image Processing Toolbox.',\n    '% 130826 Bug fix for \\'*\\' src input. Minor improvement for dicm_hdr.',\n    '% 130827 Try and suggest to use pigz for compression (thanks Chris R.).',\n    '% 130905 Avoid the missing-field error for DTI data with 2 excitations.',\n    '%        Protect GUI from command line plotting.',\n    '% 130912 Use lDelayInTR for slice_dur, possibly useful for old data.',\n    '% 130916 Store B_matrix for DTI image, if exists.',\n    '% 130919 Make the code work for GE and Philips dicom at Chris R website.',\n    '% 130922 Remove dependence on normc from nnet toolbox (thank Zhiwei);',\n    '%        Prove no slice order info in Philips, at least for Intera 10.4.1.',\n    '% 130923 Make the code work for Philips PAR/REC pair files.',\n    '% 130926 Take care of non-mosaic DTI for Siemens (img/bval/bvec);',\n    '% 130930 Use verify_slice_dir subfun to get slice_dir even for a single file.',\n    '% 131001 dicm_hdr can deal with VR of SQ. This slows down it a little.',\n    '% 131002 Avoid fullfile for cellstr input (not supported in old ver matlab).',\n    '% 131006 Tweak dicm_hdr for multiframe dicom (some bug fixes);',\n    '%        First working version for multiframe (tested with Philips dicom).',\n    '% 131009 Put dicm_hdr, dicm_img, dicm_dict outside this file;',\n    '%        dicm_hdr can read implicit VR, and is faster with single fread;',\n    '%        Fix problem in gzipOS when folder name contains space.',\n    '% 131020 Make TR & ProtocolName non-mandatory; Set cal_min & cal_max.',\n    '% 131021 Check SamplesPerPixel, skip run if it is 1+.',\n    '% 131021 Implement conversion for AFNI HEAD/BRIK.',\n    '% 131024 Bug fix for dealing with current folder as src folder.',\n    '% 131029 Bug fix: Siemens, 2D, non-mosaic, rev-num slices were flipped.',\n    '% 131105 DTI parameters: field names more consistent; read DTI flds in',\n    '%        save_dti_para for GE/Philips (make others faster); convert Philips',\n    '%        bvec from deg into vector (need to be verified).',\n    '% 131114 Treak for multiframe dicm_hdr: MUCH faster by using only 1,2,n frames;',\n    '%        Bug fix for Philips multiframe DTI parameters;',\n    '%        Split multiframe Philips B0 map into mag and phase nii.',\n    '% 131117 Make the order of phase/mag image in Philips B0 map irrelevant.',\n    '% 131219 Write warning message to a file in data folder (Gui\\'s suggestion).',\n    '% 140120 Bug fix in save_dti_para due to missing Manufacturer (Thank Paul).',\n    '% 140121 Allow missing instance at beginning of a series.',\n    '% 140123 save_nii: bug fix for gzip.m detection, take care of ~ as home dir.',\n    '% 140206 bug fix: MoCo detetion bug introduced by removing empty cell earlier.',\n    '% 140223 add missing-file check for Philips data by slice locations.',\n    '% 140312 use slice timing to set slice_code for both GE and Siemens.',\n    '%        Interleaved order was wrong for GE data with even number of slices. ',\n    '% 140317 Use MosaicRefAcqTimes from last vol for multiband (thank Chris).',\n    '%        Don\\'t re-orient fieldmap, so make FSL happy in case of non_axial. ',\n    '%        Ugly fix for wrong dicom item VR \\'OB\\': Avoid using main header ',\n    '%        in csa_header(), convert DTI parameters to correct type. There may',\n    '%        be other wrong parameters we don\\'t realize. ',\n    '% 140319 Store SliceTiming field in dcmHeaders.mat for FSL custom slice timing.',\n    '%        Re-orient even if flipping slices for 2D MRAcquisitionType.',\n    '% 140324 Not set cal_min, cal_max anymore.',\n    '% 140327 Return unconverted subject names in 2nd output.',\n    '% 140401 Always flip image so phase dir is correct.',\n    '% 140409 Store nii extension (not enabled due to nifti ext issue).',\n    '% 140501 Fix for GE: use LocationsInAcquisition to replace ImagesInAcquisition;',\n    '%            isDTI=DiffusionDirection>0; Gradient already in image reference.',\n    '% 140505 Always re-orient DTI. bvec fix for GE DTI (thx Chris).',\n    '% 140506 Remove last DTI vol if it is computed ADC (as dcm2niix);',\n    '%        Use SeriesDescription to replace ProtocolName for file name;',\n    '%        Improved dim_info and phase direction.',\n    '% 140512 Decode GE ProtocolDataBlock for phase direction;',\n    '%        strtrim SeriesDescription for nii file name.',\n    '% 140513 change stored phase direction to image space for FSL unwarp;',\n    '%        Simplify code for dim_info.',\n    '% 140516 Switch back to ProtocolName for SIEMENS to take care of MOCO series;',\n    '%        Detect Philips Dim3IsVolume (for multi files) during dicom check; ',\n    '%        Work for GE interleaved slices even if InstanceNumber is in time order;',\n    '%        Do ImagePositionPatient check for all vendors;',\n    '%        Simplify code for save_dti_para.',\n    '% 140517 Store img with first dim flipped, to take care of DTI bvec problems. ',\n    '% 140522 Use SliceNormalVector for mosaic slice_dir, so no worry for revNumb;',\n    '%        Bug fix for interleaved descending slice_code.',\n    '% 140525 xform sliceCenter to SliceLocation in verify_slice_dir. ',\n    '% 140526 Take care of non-unique ixyz. ',\n    '% 140608 Bug fix for GE interleaved slices;',\n    '%        Take care all ixyz, put verify_slice_dir into xform_mat.',\n    '% 140610 Compute readout time for DTI, rather than dwell time.',\n    '% 140621 Support tgz file as data source.',\n    '% 140716 Bug fix due to empty src for GUI subject option.',\n    '% 140808 Simplify mosaic detection, and remove isMosaic.',\n    '% 140816 Simplify DTI detection.',\n    '% 140911 Minor fix for Siemens ProtocolName for error message.',\n    '% 141016 Remember GUI settings from last conversion;',\n    '%        Make multi-subject error message friendly.',\n    '% 141021 Show percent progress for validating dicom files.',\n    '% 141023 Get LocationsInAcquisition for GE multiframe dicom.',\n    '% 141024 Use unique ImagePositionPatient to determine LocationsInAcquisition.',\n    '% 141028 Use matlabpool if available and worthy.',\n    '% 141125 Store NumberOfTemporalPositions in dicom header.',\n    '% 141128 Minor tweaks for Octave 3.8.1 command line (GUI not working).',\n    '% 141216 Use ImagePositionPatient to derive SliceThickness if possible.',\n    '% 141217 Override LocationsInAcquisition with computed nSL (thx Luigi);',\n    '%        Check RescaleIntercept and RescaleSlope consistency.',\n    '% 141218 Allow 1e-4 diff for ImagePositionPatient of same slice location.',\n    '% 141223 multiFrameFields: return earlier if only single frame (thx Sander);',\n    '%        No re-orient for single slice (otherwise problem for mricron to read).',\n    '% 141224 mos2vol: use nSL loop (faster unless many slices).',\n    '% 141229 Save nii ext (ecode=40) if FSL is detected & it is not 5.0.5/5.0.6.',\n    '% 141230 nojvm: no matlabpool; no dicm_hdr progress due to \\'\\\\b\\' issue for WIN.',\n    '% 150109 dicm_img(s, 0) to follow the update for dicm_img.',\n    '% 150112 Use nii_tool.m, remove make_nii, save_nii etc from this file.',\n    '% 150115 Allow SamplesPerPixel>1, but likely not very useful.',\n    '% 150117 Store seq name in intent_name.',\n    '% 150119 Add phase img detection for Philips (still need it for GE).',\n    '% 150120 No file skip by EchoTime: keep all data by using EchoNumber.',\n    '% 150209 Add more output format for SPM style: 3D output;',\n    '%        GUI includes SPM 3D, separates GZ option. ',\n    '% 150211 No missing file check for all vendors, relying on ImagePosition check;',\n    '%        csa_header() relies on dicm_hdr decoding (avoid error on old data);',\n    '%        Deal with dim3-RGB and dim4-frames due to dicm_img.m update.',\n    '% 150222 Remove useless, mis-used TriggerTime for partial hdr; also B_matrix.',\n    '% 150302 No hardcoded sign change for DTI bvec, except for GE;',\n    '%        set_nii_header: do flip only once after permute;',\n    '% 150303 Bug fix for phPos: result was right by lucky mistake;',\n    '%        Progress shows nii dim, more informative than number of files.',\n    '% 150305 Replace null with cross: null gives inconsistent signs;',\n    '%        Use SPM method for xform: account for shear; no qform setting if shear.',\n    '% 150306 GE: fully sort slices by loc to ease bvec sign (test data needed);',\n    '%        bvec sign simplified by above sort & corrected R for Philips/Siemens.',\n    '% 150309 GUI: added the little popup for \\'about/license\\'.  ',\n    '% 150323 Siemens non-mosaic: RefAcqTimes from ucMode, AcquisitionTime(disabled).   ',\n    '% 150324 mandatory flds reduced to 5; get info by asc_header if possible;',\n    '% 150325 Use SeriesInstanceUID to take care of multiple Study and PatientName; ',\n    '%        Remove 5th input (subj); GUI updated; subjName in file name if needed;',\n    '%        Deal with MoCo series by output file names;',\n    '%        Convert GLM and DTI junk too; no Manufacturer check in advance.',\n    '% 150405 Implement BrainVoyager dmr/fmr/vmr conversion; GUI updated accordingly. ',\n    '% 150413 InstanceNumber is not mandatory (now total 4);',\n    '%        Check missing files for non-DTI mosaic by InstanceNumber.',\n    '% 150418 phaseDirection: bug fix for Philips, simplify for others.',\n    '% 150420 store raw timing in RefAcqTimes, avoid confusion with SliceTiming.',\n    '% 150423 fix matlabpool for later matlab versions; no auto-close anymore;',\n    '%        GUI figure handle can\\'t be uint32 for matlab 2015;',\n    '%        Turn off saveExt40: FSL 5.0.8 may read vox_offset as 352.',\n    '% 150430 xform_mat: GE, no LastScanLoc needed since sorted by ImagePosition. ',\n    '% 150508 csa2pos: bug fix for revNum, iSL==1; treat dInPlaneRot specially.',\n    '% 150514 set_nii_ext: start to store txt edata (ecode=6).',\n    '%        Avoid dict change in dicm_hdr due to vendor change (GE/Philips faster);',\n    '% 150517 Octave compatibility fix in multiple files.',\n    '% 150526 multiFrameFields: LocationsInAcquisition by ImagePosition if needed.',\n    '% 150531 Check slice loc for all volumes to catch missing files (thx CarloR).',\n    '% 150604 phaseDirection: typo fix for Philips \\'RLAPFH\\'; Show converter version.',\n    '% 150606 csa_header read both CSA image/series header.',\n    '% 150609 No t_unit and SliceTiming for DTI.',\n    '% 150613 mb_slicetiming: try to fix SOME broken multiband slice timing.',\n    '% 150620 use \\'bval\\' for nii.ext and dcmHeaders.mat, so keep original B_value.',\n    '% End of history. Don\\'t edit this line!',\n    '',\n    'if nargout, varargout{1} = \\'\\'; end',\n    'if nargin==3 && ischar(varargin{1}) % mis-use 3rd input for GUI and func handle',\n    '    if strcmp(varargin{1}, \\'gui_callback\\')',\n    '        dicm2nii_gui(dataFolder);',\n    '        return;',\n    '    elseif strcmp(varargin{1}, \\'func_handle\\')',\n    '        if strcmp(dataFolder, \\'all\\') % for command line test',\n    '            fcns = localfunctions; % only for Matlab since 2013b',\n    '            for i = 1:length(fcns)',\n    '                nam = func2str(fcns{i});',\n    '                assignin(\\'base\\', nam, eval([\\'@\\' nam]));',\n    '            end',\n    '        else',\n    '            varargout{1} = eval([\\'@\\' dataFolder]);',\n    '        end',\n    '        return;',\n    '    end',\n    'end',\n    '',\n    '%% Deal with output format first, and error out if invalid',\n    'if nargin<3 || isempty(varargin{1}), fmt = 1; % default .nii.gz',\n    'else fmt = varargin{1};',\n    'end',\n    '',\n    'if (isnumeric(fmt) && any(fmt==[0 1 4 5])) || ...',\n    '      (ischar(fmt) && ~isempty(regexpi(fmt, \\'nii\\')))',\n    '    ext = \\'.nii\\';',\n    'elseif (isnumeric(fmt) && any(fmt==[2 3 6 7])) || (ischar(fmt) && ...',\n    '        (~isempty(regexpi(fmt, \\'hdr\\')) || ~isempty(regexpi(fmt, \\'img\\'))))',\n    '    ext = \\'.img\\';',\n    'else',\n    '    error(\\' Invalid output file format (the 3rd input).\\');',\n    'end',\n    '',\n    'if (isnumeric(fmt) && mod(fmt,2)) || (ischar(fmt) && ~isempty(regexpi(fmt, \\'.gz\\')))',\n    '    ext = [ext \\'.gz\\']; % gzip file',\n    'end',\n    '',\n    'rst3D = (isnumeric(fmt) && fmt>3) || (ischar(fmt) && ~isempty(regexpi(fmt, \\'3D\\')));',\n    '',\n    '%% Deal with MoCo option',\n    'if nargin<4 || isempty(varargin{2})',\n    '    MoCo = 1; % by default, use original series if both present ',\n    'else',\n    '    MoCo = varargin{2};',\n    '    if ~any(MoCo==0:2)',\n    '        error(\\' Invalid MoCoOption. The 4th input must be 0, 1 or 2.\\');',\n    '    end',\n    'end',\n    '',\n    '%% Deal with data source',\n    'if nargin<1 || isempty(src) || (nargin<2 || isempty(dataFolder))',\n    '    create_gui; % show GUI if input is not enough',\n    '    return;',\n    'end',\n    '',\n    'tic;',\n    'unzip_cmd = \\'\\';',\n    'if isnumeric(src)',\n    '    error(\\'Invalid dicom source.\\');    ',\n    'elseif iscellstr(src) % multiple files',\n    '    dcmFolder = folderFromFile(src{1});',\n    '    n = length(src);',\n    '    fnames = src;',\n    '    for i = 1:n',\n    '        foo = dir(src{i});',\n    '        if isempty(foo), error(\\'%s does not exist.\\', src{i}); end',\n    '        fnames{i} = fullfile(dcmFolder, foo.name); ',\n    '    end',\n    'elseif ~exist(src, \\'file\\') % like input: run1*.dcm',\n    '    fnames = dir(src);',\n    '    if isempty(fnames), error(\\'%s does not exist.\\', src); end',\n    '    fnames([fnames.isdir]) = [];',\n    '    dcmFolder = folderFromFile(src);',\n    '    fnames = strcat(dcmFolder, filesep, {fnames.name});    ',\n    'elseif isdir(src) % folder',\n    '    dcmFolder = src;',\n    'elseif ischar(src) % 1 dicom or zip/tgz file',\n    '    dcmFolder = folderFromFile(src);',\n    '    unzip_cmd = compress_func(src);',\n    '    if isempty(unzip_cmd)',\n    '        fnames = dir(src);',\n    '        fnames = strcat(dcmFolder, filesep, {fnames.name});',\n    '    end',\n    'else ',\n    '    error(\\'Unknown dicom source.\\');',\n    'end',\n    'dcmFolder = fullfile(getfield(what(dcmFolder), \\'path\\'));',\n    '',\n    '%% Deal with dataFolder',\n    'if ~isdir(dataFolder), mkdir(dataFolder); end',\n    'dataFolder = fullfile([getfield(what(dataFolder), \\'path\\') filesep]);',\n    'converter = [\\'dicm2nii.m 20\\' reviseDate];',\n    'if errorLog(\\'\\', dataFolder) % let it remember dataFolder for later call',\n    '    more off;',\n    '    disp([\\'Xiangrui Li\\'\\'s \\' converter \\' (feedback to xiangrui.li@gmail.com)\\']);',\n    'end',\n    '',\n    '%% Unzip if compressed file is the source',\n    'if ~isempty(unzip_cmd)',\n    '    [~, fname, ext1] = fileparts(src);',\n    '    dcmFolder = sprintf(\\'%stmpDcm%s/\\', dataFolder, fname);',\n    '    if ~isdir(dcmFolder), mkdir(dcmFolder); end',\n    '    disp([\\'Extracting files from \\' fname ext1 \\' ...\\']);',\n    '',\n    '    if strcmp(unzip_cmd, \\'unzip\\')',\n    '        cmd = sprintf(\\'unzip -qq -o %s -d %s\\', src, dcmFolder);',\n    '        err = system(cmd); % first try system unzip',\n    '        if err, unzip(src, dcmFolder); end % Matlab\\'s unzip is too slow',\n    '    elseif strcmp(unzip_cmd, \\'untar\\')',\n    '        if isempty(which(\\'untar\\')), error(\\'No untar found in matlab path.\\'); end',\n    '        untar(src, dcmFolder);',\n    '    end',\n    '    drawnow;',\n    'end ',\n    '',\n    '%% Get all file names including those in subfolders, if not specified',\n    'if ~exist(\\'fnames\\', \\'var\\')',\n    '    dirs = genpath(dcmFolder);',\n    '    dirs = textscan(dirs, \\'%s\\', \\'Delimiter\\', pathsep);',\n    '    dirs = dirs{1}; % cell str',\n    '    fnames = {};',\n    '    for i = 1:length(dirs)',\n    '        curFolder = [dirs{i} filesep];',\n    '        foo = dir(curFolder); % all files and folders',\n    '        foo([foo.isdir]) = []; % remove folders',\n    '        foo = strcat(curFolder, {foo.name});',\n    '        fnames = [fnames foo]; %#ok<*AGROW>',\n    '    end',\n    'end',\n    'nFile = length(fnames);',\n    'if nFile<1, error(\\' No files found in the data source.\\'); end',\n    '',\n    '%% Check each file, store partial header in cell array hh',\n    '% first 4 fields are must to be valid dicom',\n    'flds = {\\'SeriesInstanceUID\\' \\'Columns\\' \\'Rows\\' \\'BitsAllocated\\' \\'InstanceNumber\\' ...',\n    '    \\'ImageOrientationPatient\\' \\'ImagePositionPatient\\' \\'PixelSpacing\\' ...',\n    '    \\'PixelRepresentation\\' \\'BitsStored\\' \\'HighBit\\' \\'SamplesPerPixel\\' ...',\n    '    \\'PlanarConfiguration\\' \\'EchoNumber\\' \\'RescaleIntercept\\' \\'RescaleSlope\\' ...',\n    '    \\'NumberOfFrames\\' \\'B_value\\' \\'DiffusionGradientDirection\\' ...',\n    '    \\'RTIA_timer\\' \\'RBMoCoTrans\\' \\'RBMoCoRot\\' ...',\n    '    \\'SliceThickness\\' \\'SpacingBetweenSlices\\'};',\n    'dict = dicm_dict(\\'SIEMENS\\', flds); % dicm_hdr will update vendor if needed',\n    '',\n    '% read header for all files, use parpool if available and worthy',\n    'fprintf(\\'Validating %g files ...\\\\n\\', nFile);',\n    'hh = cell(1, nFile); errStr = cell(1, nFile);',\n    'doPar = useParTool(nFile>1000); % use it if already open or nFile>1000',\n    'for k = 1:nFile',\n    '    [hh{k}, errStr{k}, dict] = dicm_hdr(fnames{k}, dict);',\n    '    if doPar && ~isempty(hh{k}) % parfor wont allow updating dict',\n    '        parfor i = k+1:nFile',\n    '            [hh{i}, errStr{i}] = dicm_hdr(fnames{i}, dict); ',\n    '        end',\n    '        break; ',\n    '    end',\n    'end',\n    '',\n    '%% sort headers into cell h by SeriesInstanceUID, EchoNumber and InstanceNumber',\n    'h = {}; % in case of no dicom files at all',\n    'errInfo = \\'\\';',\n    'seriesUIDs = {};',\n    'for k = 1:nFile',\n    '    s = hh{k};',\n    '    if isempty(s) || any(~isfield(s, flds(1:4))) % || isType(s, junk)',\n    '        if ~isempty(errStr{k}) % && isempty(strfind(errInfo, errStr{k}))',\n    '            errInfo = sprintf(\\'%s\\\\n%s\\\\n\\', errInfo, errStr{k});',\n    '        end',\n    '        continue; % skip the file',\n    '    end',\n    '',\n    '    m = find(strcmp(s.SeriesInstanceUID, seriesUIDs));',\n    '    if isempty(m)',\n    '        m = length(seriesUIDs)+1;',\n    '        seriesUIDs{m} = s.SeriesInstanceUID;',\n    '    end',\n    '    ',\n    '    % EchoNumber is needed for Siemens fieldmap mag series',\n    '    i = tryGetField(s, \\'EchoNumber\\', 1); if i<1, i = 1; end',\n    '    j = tryGetField(s, \\'InstanceNumber\\');',\n    '    if isempty(j) || j<1',\n    '        try j = length(h{m}{i}) + 1;',\n    '        catch, j = 1; ',\n    '        end',\n    '    end',\n    '    h{m}{i}{j} = s; % store partial header',\n    'end',\n    'clear hh errStr;',\n    '',\n    '%% Check headers: remove file-missing and dim-inconsistent series',\n    'nRun = length(h);',\n    'if nRun<1',\n    '    errorLog(sprintf(\\'No valid files found:\\\\n%s.\\', errInfo)); ',\n    '    return;',\n    'end',\n    'keep = true(1, nRun); % true for useful runs',\n    'subjs = cell(1, nRun); vendor = cell(1, nRun);',\n    'sNs = ones(1, nRun); studyIDs = cell(1, nRun);',\n    'fldsCk = {\\'ImageOrientationPatient\\' \\'NumberOfFrames\\' \\'Columns\\' \\'Rows\\' ...',\n    '          \\'PixelSpacing\\' \\'RescaleIntercept\\' \\'RescaleSlope\\' \\'SamplesPerPixel\\' ...',\n    '          \\'SpacingBetweenSlices\\' \\'SliceThickness\\'}; % last for thickness',\n    'for i = 1:nRun',\n    '    h{i} = [h{i}{:}]; % concatenate different EchoNumber',\n    '    ind = cellfun(@isempty, h{i});',\n    '    h{i}(ind) = []; % remove all empty cell for all vendors',\n    '    ',\n    '    s = h{i}{1};',\n    '    if ~isfield(s, \\'LastFile\\') % avoid re-read for PAR/HEAD/BV file',\n    '        s = dicm_hdr(s.Filename); % full header for 1st file',\n    '    end',\n    '    if ~isfield(s, \\'Manufacturer\\'), s.Manufacturer = \\'Unknown\\'; end',\n    '    subjs{i} = PatientName(s);',\n    '    vendor{i} = s.Manufacturer;',\n    '    sNs(i) = tryGetField(s, \\'SeriesNumber\\', 1);',\n    '    studyIDs{i} = tryGetField(s, \\'StudyID\\', \\'1\\');',\n    '    series = sprintf(\\'Subject %s, %s (Series %g)\\', subjs{i}, ProtocolName(s), sNs(i));',\n    '    s = multiFrameFields(s); % no-op if non multi-frame',\n    '    if isempty(s), keep(i) = 0; continue; end % invalid multiframe series',\n    '    s.isDTI = isDTI(s);',\n    '    h{i}{1} = s; % update record in case of full hdr or multiframe',\n    '    ',\n    '    % check consistency in \\'fldsCk\\'',\n    '    nFile = length(h{i});',\n    '    if nFile<2, continue; end',\n    '    nFlds = length(fldsCk);',\n    '    if isfield(s, \\'SpacingBetweenSlices\\'), nFlds = nFlds - 1; end % check 1 of 2',\n    '    for k = 1:nFlds',\n    '        val1  = tryGetField(s, fldsCk{k});',\n    '        if isempty(val1), continue; end',\n    '        for j = 2:nFile',\n    '            % At least some GE ImageOrientationPatient can have diff of 1e-6',\n    '            val2 = tryGetField(h{i}{j}, fldsCk{k});',\n    '            if isempty(val2) || any(abs(val1 - val2) > 1e-4)',\n    '                errorLog([\\'Inconsistent \\'\\'\\' fldsCk{k} \\'\\'\\' for \\' series \\'. Series skipped.\\']);',\n    '                keep(i) = 0;',\n    '                break;',\n    '            end',\n    '        end',\n    '        if ~keep(i), break; end % skip',\n    '    end',\n    '    ',\n    '    if ~isempty(csa_header(s, \\'NumberOfImagesInMosaic\\'))',\n    '        if s.isDTI, continue; end % allow missing directions for DTI',\n    '        a = zeros(1, nFile);',\n    '        for j = 1:nFile, a(j) = tryGetField(h{i}{j}, \\'InstanceNumber\\', 1); end',\n    '        if any(diff(a) ~= 1)',\n    '            errorLog([\\'Missing file(s) detected for \\' series \\'. Series skipped.\\']);',\n    '            keep(i) = 0;',\n    '        end',\n    '        continue; % no other check for mosaic',\n    '    end',\n    '        ',\n    '    if ~keep(i) || any(~isfield(s, {\\'ImagePositionPatient\\' \\'ImageOrientationPatient\\'}))',\n    '        continue;',\n    '    end',\n    '    ',\n    '    iSL = xform_mat(s); iSL = iSL(3);',\n    '    a = zeros(1, nFile);',\n    '    for j = 1:nFile, a(j) = h{i}{j}.ImagePositionPatient(iSL); end',\n    '    nSL = sum(diff(sort(a)) > 1e-4) + 1; % allow minor diff',\n    '    nVol = nFile / nSL;',\n    '    if mod(nVol, 1) > 0',\n    '        errorLog([\\'Missing file(s) detected for \\' series \\'. Series skipped.\\']);',\n    '        keep(i) = 0; continue; % skip',\n    '    end',\n    '    ',\n    '    fld = \\'LocationsInAcquisition\\';',\n    '    if isfield(s, fld) && s.(fld)~=nSL % warning but override it',\n    '        errorLog(sprintf([\\'%s: the number of slices (%g) in dicom header \\' ...',\n    '            \\'seems wrong. nSL = %g is used. Please check the result.\\'], ...',\n    '            series, s.(fld), nSL));',\n    '    end',\n    '    h{i}{1}.(fld) = uint16(nSL); % best way for nSL?',\n    '',\n    '    % re-order as Slice then Volume if Dim3IsVolume (likely Philips)',\n    '    if abs(a(1)-a(2)) < 1e-4 % the same slice location',\n    '        ind = reshape(1:nFile, [nVol nSL])\\';',\n    '        h{i} = h{i}(ind(:)); a = a(ind(:));',\n    '        h{i}{1}.Dim3IsVolume = true; % not needed, info only',\n    '    end',\n    '        ',\n    '    % re-order slices within volume by slice locations',\n    '    if strncmpi(s.Manufacturer, \\'GE\\', 2)',\n    '        [~, ind] = sort(a(1:nSL)); % slice locations for first volume',\n    '        % if iSL==1, ind = ind(nSL:-1:1); end % need to confirm for SAG slice',\n    '        if ~isequal(ind, 1:nSL)',\n    '            inc = repmat((0:nVol-1)*nSL, nSL, 1);',\n    '            ind = repmat(ind, 1, nVol) + inc(:)\\';',\n    '            h{i} = h{i}(ind); % sorted by slice locations',\n    '            if ind(1)>1 % first file changed: update info for h{i}{1}',\n    '                h{i}{1} = dicm_hdr(h{i}{1}.Filename); % read full hdr',\n    '                s = h{i}{ind==1}; % original first file',\n    '                h{i}{1}.isDTI = s.isDTI;',\n    '                h{i}{1}.LocationsInAcquisition = s.LocationsInAcquisition;',\n    '                h{i}{1}.AcquisitionDateTime = [ ... % useless based on GE data',\n    '                    tryGetField(s, \\'AcquisitionDate\\', \\'\\') ...',\n    '                    tryGetField(s, \\'AcquisitionTime\\', \\'\\')];',\n    '            end',\n    '        end',\n    '    end',\n    '    ',\n    '    [~, ind] = sort(a(1:nSL));',\n    '    if ~isequal(ind, 1:nSL) && ~isequal(ind, nSL:-1:1)',\n    '        errorLog([\\'Missing file(s) detected for \\' series \\'. Series skipped.\\']);',\n    '        keep(i) = 0; continue; % skip',\n    '    end',\n    '    ',\n    '    for j = 2:nVol',\n    '        [~, ind1] = sort(a((1:nSL)+(j-1)*nSL));',\n    '        if isequal(ind, ind1), continue; end',\n    '        errorLog([\\'Missing file(s) detected for \\' series \\'. Series skipped.\\']);',\n    '        keep(i) = 0; break; % skip',\n    '    end',\n    'end',\n    'h = h(keep); sNs = sNs(keep); studyIDs = studyIDs(keep); ',\n    'subjs = subjs(keep); vendor = vendor(keep);',\n    '',\n    '%% sort h by PatientName, then StudyID, then SeriesNumber',\n    '% Also get correct order for subjs/studyIDs/nStudy/sNs for nii file names',\n    '[subjs, ind] = sort(subjs);',\n    'subj = unique(subjs); ',\n    'h = h(ind); sNs = sNs(ind); studyIDs = studyIDs(ind); % by subjs now',\n    'nStudy = ones(1, nRun); % one for each series',\n    'for i = 1:length(subj)',\n    '    iSub = find(strcmp(subj{i}, subjs));',\n    '    study = studyIDs(iSub);',\n    '    [study, iStudy] = sort(study); % by study for each subject',\n    '    a = h(iSub);   h(iSub)   = a(iStudy);',\n    '    a = sNs(iSub); sNs(iSub) = a(iStudy);',\n    '    studyIDs(iSub) = study; % done for h/sNs/studyIDs by studyIDs for a subj',\n    '    uID = unique(study);',\n    '    nStudy(iSub) = length(uID);',\n    '    for k = 1:length(uID) % now sort h/sNs by sNs for each studyID',\n    '        iStudy = strcmp(uID{k}, study);',\n    '        ind = iSub(iStudy); ',\n    '        [sNs(ind), iSN] = sort(sNs(ind));',\n    '        a = h(ind); h(ind) = a(iSN);',\n    '    end',\n    'end',\n    '',\n    '%% Generate unique result file names',\n    '% Unique names are in format of SeriesDescription_s007. Special cases are: ',\n    '%  for phase image, such as field_map phase, append \\'_phase\\' to the name;',\n    '%  for MoCo series, append \\'_MoCo\\' to the name if both series are created.',\n    '%  for multiple subjs, it is SeriesDescription_subj_s007',\n    '%  for multiple Study, it is SeriesDescription_subj_Study1_s007',\n    'nRun = length(h); % update it, since we have removed some',\n    'if nRun<1',\n    '    errorLog(\\'No valid series found\\');',\n    '    return;',\n    'end',\n    'rNames = cell(1, nRun);',\n    'isMoCo = false(1, nRun);',\n    'multiSubj = length(subj)>1; ',\n    'for i = 1:nRun',\n    '    s = h{i}{1};',\n    '    a = strtrim(ProtocolName(s));',\n    '    if isType(s, \\'\\\\P\\\\\\') || strcmpi(tryGetField(s, \\'ComplexImageComponent\\', \\'\\'), \\'PHASE\\')',\n    '        a = [a \\'_phase\\']; % phase image',\n    '    end',\n    '    isMoCo(i) = isType(s, \\'\\\\MOCO\\\\\\');',\n    '    if MoCo==0 && isMoCo(i), a = [a \\'_MoCo\\']; end',\n    '    if multiSubj, a = [a \\'_\\' subjs{i}]; end',\n    '    if nStudy(i)>1, a = [a \\'_Study\\' studyIDs{i}]; end',\n    '    a(~isstrprop(a, \\'alphanum\\')) = \\'_\\'; % make str valid for field name',\n    '    while true % remove repeated underscore',\n    '        ind = strfind(a, \\'__\\');',\n    '        if isempty(ind), break; end',\n    '        a(ind) = \\'\\';',\n    '    end',\n    '    sN = sNs(i);',\n    '    if sN>100 && strncmp(s.Manufacturer, \\'Philips\\', 7)',\n    '        sN = tryGetField(s, \\'AcquisitionNumber\\', floor(sN/100));',\n    '    end',\n    '    rNames{i} = sprintf(\\'%s_s%03.0f\\', a, sN);',\n    'end',\n    'rNames = genvarname(rNames); % add \\'x\\' if started with a digit, and more',\n    '',\n    '% deal with MoCo series',\n    'if MoCo>0 && any(isMoCo)',\n    '    keep = true(1, nRun);',\n    '    for i = 2:nRun',\n    '        if isMoCo(i) && sNs(i)==sNs(i-1)+1 && ...',\n    '                strcmp(rNames{i}(1:end-5), rNames{i-1}(1:end-5))',\n    '            if MoCo==1',\n    '                keep(i) = 0; % skip MOCO',\n    '            elseif MoCo==2',\n    '                keep(i-1) = 0; % skip original',\n    '            end',\n    '        end',\n    '    end',\n    '    h = h(keep); rNames = rNames(keep);',\n    '    vendor = vendor(keep); subj = unique(subjs(keep));',\n    '    nRun = length(h);',\n    'end',\n    '',\n    'vendor = strtok(unique(vendor));',\n    'if nargout>0, varargout{1} = subj; end % return converted subject IDs',\n    'if nargout>1, varargout{2} = {}; end % will remove in the future',\n    '',\n    '% After following sort, we need to compare only neighboring names. Remove',\n    '% _s007 if there is no conflict. Have to ignore letter case for Windows & MAC',\n    'fnames = rNames; % copy it, keep letter cases',\n    '[rNames, iRuns] = sort(lower(fnames));',\n    'for i = 1:nRun',\n    '    a = rNames{i}(1:end-5); % remove _s003',\n    '    % no conflict with both previous and next name',\n    '    if nRun==1 || ... % only one run',\n    '         (i==1    && ~strcmpi(a, rNames{2}(1:end-5))) || ... % first',\n    '         (i==nRun && ~strcmpi(a, rNames{i-1}(1:end-5))) || ... % last',\n    '         (i>1 && i<nRun && ~strcmpi(a, rNames{i-1}(1:end-5)) ...',\n    '                        && ~strcmpi(a, rNames{i+1}(1:end-5))); % middle ones',\n    '        fnames{iRuns(i)}(end+(-4:0)) = [];',\n    '    end',\n    'end',\n    'fmtStr = sprintf(\\' %%-%gs %%gx%%gx%%gx%%g\\\\n\\', max(cellfun(@length, fnames))+6);',\n    '',\n    '%% Now ready to convert nii series by series',\n    'subjStr = sprintf(\\'\\'\\'%s\\'\\', \\', subj{:}); subjStr(end+(-1:0)) = [];',\n    'vendor = sprintf(\\'%s, \\', vendor{:}); vendor(end+(-1:0)) = [];',\n    'fprintf(\\'Converting %g series (%s) into %g-D %s: subject %s\\\\n\\', ...',\n    '            nRun, vendor, 4-rst3D, ext, subjStr);',\n    'for i = 1:nRun',\n    '    nFile = length(h{i});',\n    '    s = h{i}{1};',\n    '    img = dicm_img(s, 0); % initialize with proper data type and img size',\n    '',\n    '    if nFile > 1',\n    '        if ~isfield(s, \\'LastFile\\')',\n    '            h{i}{1}.LastFile = h{i}{nFile}; % store partial last header into 1st',\n    '        end',\n    '        n = ndims(img);',\n    '        if n == 2 % for most dicom files',\n    '            img(:, :, 2:nFile) = 0; % pre-allocate',\n    '            for j = 2:nFile, img(:,:,j) = dicm_img(h{i}{j}, 0); end',\n    '        elseif n == 3 % SamplesPerPixel>1 is the only case I know for now',\n    '            img(:, :, :, 2:nFile) = 0; % pre-allocate',\n    '            for j = 2:nFile, img(:,:,:,j) = dicm_img(h{i}{j}, 0); end',\n    '        else % err out, likely won\\'t work for other series',\n    '            error(\\'dicm2nii can\\'\\'t deal with multiple %g-dim dicom image\\', n);',\n    '        end',\n    '    elseif size(img,3) == 1 % single gray file (multi-frame dicm, par or brik)',\n    '        img = permute(img, [1 2 4 3]); % put frames into dim3',\n    '    end',\n    '    ',\n    '    nSL = csa_header(s, \\'NumberOfImagesInMosaic\\', 1);',\n    '    if nSL>1 % SIEMENS mosaic',\n    '        img = mos2vol(img, nSL); % mosaic to volume',\n    '    elseif ndims(img)==4 && tryGetField(s, \\'Dim3IsVolume\\', false) % BV/BRIK',\n    '        img = permute(img, [1 2 4 3]);',\n    '    elseif ndims(img) == 3 % may need to reshape to 4D',\n    '        nSL = double(tryGetField(s, \\'LocationsInAcquisition\\'));        ',\n    '        if nSL>1',\n    '            dim = size(img);',\n    '            dim(3:4) = [nSL dim(3)/nSL]; % verified integer earlier',\n    '            if nFile==1 && tryGetField(s, \\'Dim3IsVolume\\', false)',\n    '                % for PAR and single multiframe dicom',\n    '                img = reshape(img, dim([1 2 4 3]));',\n    '                img = permute(img, [1 2 4 3]);',\n    '            else',\n    '                img = reshape(img, dim);',\n    '            end',\n    '        end',\n    '    end',\n    '    % This \\'if\\' block takes care of SamplesPerPixel>1',\n    '    if tryGetField(s, \\'SamplesPerPixel\\', 1) > 1',\n    '        img = permute(img, [1 2 4:8 3]); % put RGB into dim8 for nii_tool',\n    '    end',\n    '    dim = size(img);',\n    '    if numel(dim)<3, dim(3) = 1; end',\n    '    fld = \\'NumberOfTemporalPositions\\';',\n    '    if ~isfield(s, fld) && numel(dim)>3 && dim(4)>1, h{i}{1}.(fld) = dim(4); end',\n    '',\n    '    if any(~isfield(s, {\\'ImageOrientationPatient\\' \\'ImagePositionPatient\\'}))',\n    '        h{i}{1} = csa2pos(s, dim(3));',\n    '    end',\n    '    ',\n    '    % Store GE slice timing. No slice order info for Philips at all!',\n    '    if isfield(s, \\'RTIA_timer\\') && ~s.isDTI',\n    '        t = zeros(dim(3), 1);',\n    '        for j = 1:dim(3), t(j) = tryGetField(h{i}{j}, \\'RTIA_timer\\', nan); end',\n    '        if ~all(diff(t)==0), h{i}{1}.RefAcqTimes = t/10; end % in ms',\n    '        ',\n    '%     % Get slice timing for non-mosaic Siemens file. Could remove Manufacturer',\n    '%     % check, but GE/Philips AcquisitionTime seems useless',\n    '%     elseif numel(dim)>3 && dim(4)>2 && ~isfield(s, \\'MosaicRefAcqTimes\\') ...',\n    '%             && strncmpi(s.Manufacturer, \\'SIEMENS\\', 7) && ~s.isDTI',\n    '%         dict = dicm_dict(\\'\\', {\\'AcquisitionDate\\' \\'AcquisitionTime\\'});',\n    '%         t = zeros(dim(3), 1);',\n    '%         for j = 1:dim(3)',\n    '%             s1 = dicm_hdr(h{i}{j}.Filename, dict);',\n    '%             str = [s1.AcquisitionDate s1.AcquisitionTime];',\n    '%             t(j) = datenum(str, \\'yyyymmddHHMMSS.fff\\');',\n    '%         end',\n    '%         h{i}{1}.RefAcqTimes = (t - min(t)) * 24 * 3600 * 1000; % day to ms',\n    '    end',\n    '    ',\n    '    % Store motion parameters for MoCo series',\n    '    if all(isfield(s, {\\'RBMoCoTrans\\' \\'RBMoCoRot\\'})) && numel(dim)>3',\n    '        inc = nFile / dim(4);',\n    '        trans = zeros(dim(4), 3);',\n    '        rotat = zeros(dim(4), 3);',\n    '        for j = 1:inc:nFile',\n    '            trans(j,:) = tryGetField(h{i}{j}, \\'RBMoCoTrans\\', [0 0 0]);',\n    '            rotat(j,:) = tryGetField(h{i}{j}, \\'RBMoCoRot\\',   [0 0 0]);',\n    '        end',\n    '        h{i}{1}.RBMoCoTrans = trans;',\n    '        h{i}{1}.RBMoCoRot = rotat;',\n    '    end',\n    '    ',\n    '    if isa(img, \\'uint16\\') && max(img(:))<32768',\n    '        img = int16(img); % use int16 if lossless. seems always true',\n    '    end',\n    '    ',\n    '    nii = nii_tool(\\'init\\', img); % create nii struct based on img',\n    '    fname = [dataFolder fnames{i}]; % name without ext',\n    '',\n    '    % Compute bval & bvec in dicom image reference for DTI series',\n    '    if s.isDTI, [h{i}, nii] = get_dti_para(h{i}, nii); end',\n    '    ',\n    '    [nii, h{i}{1}] = set_nii_header(nii, h{i}{1}); % set most nii header',\n    '    h{i}{1}.NiftiCreator = converter;',\n    '    nii.ext = set_nii_ext(h{i}{1}); % NIfTI extension',\n    '',\n    '    % Save bval and bvec files after bvec perm/sign adjusted in set_nii_header',\n    '    if s.isDTI, save_dti_para(h{i}{1}, fname); end',\n    '',\n    '    [nii, niiP] = split_philips_phase(nii, s); % split Philips mag&phase img',\n    '    if ~isempty(niiP)',\n    '        fprintf(fmtStr, [fnames{i} \\'_phase\\'], niiP.hdr.dim(2:5));',\n    '        nii_tool(\\'save\\', niiP, [fname \\'_phase\\' ext], rst3D); % save phase nii',\n    '    end',\n    '    ',\n    '    fprintf(fmtStr, fnames{i}, nii.hdr.dim(2:5)); % show info and progress',\n    '    nii_tool(\\'save\\', nii, [fname ext], rst3D);',\n    '    h{i} = h{i}{1}; % keep 1st dicm header only',\n    '    if isnumeric(h{i}.PixelData), h{i} = rmfield(h{i}, \\'PixelData\\'); end % BV',\n    'end',\n    '',\n    'h = cell2struct(h, fnames, 2); % convert into struct',\n    'fname = [dataFolder \\'dcmHeaders.mat\\'];',\n    'if exist(fname, \\'file\\') % if file exists, we update fields only',\n    '    S = load(fname);',\n    '    for i = 1:length(fnames), S.h.(fnames{i}) = h.(fnames{i}); end',\n    '    h = S.h; %#ok',\n    'end',\n    'save(fname, \\'h\\', \\'-v7\\'); % -v7 better compatibility',\n    'fprintf(\\'Elapsed time by dicm2nii is %.1f seconds\\\\n\\\\n\\', toc);',\n    'if ~isempty(unzip_cmd), rmdir(dcmFolder, \\'s\\'); end % delete tmp dicom folder',\n    'return;',\n    '',\n    '%% Subfunction: return folder name for a file name',\n    'function folder = folderFromFile(fname)',\n    'folder = fileparts(fname);',\n    'if isempty(folder), folder = pwd; end',\n    '',\n    '%% Subfunction: return PatientName',\n    'function subj = PatientName(s)',\n    'subj = tryGetField(s, \\'PatientName\\');',\n    'if isempty(subj), subj = tryGetField(s, \\'PatientID\\', \\'Anonymous\\'); end',\n    '',\n    '%% Subfunction: return SeriesDescription',\n    'function name = ProtocolName(s)',\n    'name = tryGetField(s, \\'SeriesDescription\\');',\n    'if isempty(name) || (strncmp(s.Manufacturer, \\'SIEMENS\\', 7) && ...',\n    '        numel(name)>9 && strcmp(name(end+(-9:0)), \\'MoCoSeries\\'))',\n    '    name = tryGetField(s, \\'ProtocolName\\');',\n    'end',\n    'if isempty(name), [~, name] = fileparts(s.Filename); end',\n    '',\n    '%% Subfunction: return true if any of keywords is in s.ImageType',\n    'function tf = isType(s, keywords)',\n    'typ = tryGetField(s, \\'ImageType\\', \\'\\');',\n    'if ischar(keywords) % single keyword',\n    '    tf = ~isempty(strfind(typ, keywords));',\n    '    return;',\n    'end',\n    'for i = 1:length(keywords)',\n    '    tf = ~isempty(strfind(typ, keywords{i}));',\n    '    if tf, return; end',\n    'end',\n    '',\n    '%% Subfunction: return true if series is DTI',\n    'function tf = isDTI(s)',\n    'tf = isType(s, \\'\\\\DIFFUSION\\'); % Siemens, Philips',\n    'if tf, return; end',\n    'if strncmp(s.Manufacturer, \\'GE\\', 2) % not labeled as /DIFFISION',\n    '    tf = tryGetField(s, \\'DiffusionDirection\\', 0)>0;',\n    'elseif strncmpi(s.Manufacturer, \\'Philips\\', 7)',\n    '    tf = strcmp(tryGetField(s, \\'MRSeriesDiffusion\\', \\'N\\'), \\'Y\\');',\n    'else % Some Siemens DTI are not labeled as \\\\DIFFUSION',\n    '    tf = ~isempty(csa_header(s, \\'B_value\\'));',\n    'end',\n    '        ',\n    '%% Subfunction: get field if exist, return default value otherwise',\n    'function val = tryGetField(s, field, dftVal)',\n    'if isfield(s, field), val = s.(field); ',\n    'elseif nargin>2, val = dftVal;',\n    'else val = [];',\n    'end',\n    '',\n    '%% Subfunction: Set most nii header and re-orient img',\n    'function [nii, s] = set_nii_header(nii, s)',\n    '% Transformation matrix: most important feature for nii',\n    'dim = nii.hdr.dim(2:4); % space dim, set by nii_tool according to img',\n    '[ixyz, R, pixdim, xyz_unit] = xform_mat(s, dim);',\n    'R(1:2,:) = -R(1:2,:); % dicom LPS to nifti RAS, xform matrix before reorient',\n    '',\n    '% dim_info byte: freq_dim, phase_dim, slice_dim low to high, each 2 bits',\n    '[phPos, iPhase] = phaseDirection(s); % phPos relative to image in FSL feat!',\n    'if     iPhase == 2, fps_bits = [1 4 16];',\n    'elseif iPhase == 1, fps_bits = [4 1 16]; ',\n    'else                fps_bits = [0 0 16];',\n    'end',\n    '',\n    '% set TR and slice timing related info before re-orient',\n    '[s, nii.hdr] = sliceTiming(s, nii.hdr);',\n    'nii.hdr.xyzt_units = xyz_unit + nii.hdr.xyzt_units; % normally: mm (2) + sec (8)',\n    '',\n    '% Reorient if MRAcquisitionType==3D || isDTI && nSL>1',\n    '% If FSL etc can read dim_info for STC, we can always reorient.',\n    '[~, perm] = sort(ixyz); % may permute 3 dimensions in this order',\n    'if (strcmp(tryGetField(s, \\'MRAcquisitionType\\', \\'\\'), \\'3D\\') || s.isDTI) && ...',\n    '        dim(3)>1 && (~isequal(perm, 1:3)) % skip if already standard view',\n    '    R(:, 1:3) = R(:, perm); % xform matrix after perm',\n    '    fps_bits = fps_bits(perm);',\n    '    ixyz = ixyz(perm); % 1:3 after perm',\n    '    dim = dim(perm);',\n    '    pixdim = pixdim(perm);',\n    '    nii.hdr.dim(2:4) = dim;',\n    '    nii.img = permute(nii.img, [perm 4:8]);',\n    '    if isfield(s, \\'bvec\\'), s.bvec = s.bvec(:,perm); end',\n    'end',\n    'iSL = find(fps_bits==16);',\n    'iPhase = find(fps_bits==4); % axis index for phase_dim in re-oriented img',\n    '',\n    'nii.hdr.dim_info = (1:3) * fps_bits\\'; % useful for EPI only',\n    'nii.hdr.pixdim(2:4) = pixdim; % voxel zize',\n    '',\n    '% Flip image to make first axis negative and other two positive',\n    'ind4 = ixyz + [0 4 8]; % index in 4xN matrix',\n    'flp = R(ind4)<0; % flip an axis if true',\n    'flp(1) = ~flp(1); % first axis negative: comment this to make all positive',\n    'rotM = diag([1-flp*2 1]); % 1 or -1 on diagnal',\n    'rotM(1:3, 4) = (dim-1) .* flp; % 0 or dim-1',\n    'R = R / rotM; % xform matrix after flip',\n    'for k = 1:3, if flp(k), nii.img = flipdim(nii.img, k); end; end',\n    'if flp(iPhase), phPos = ~phPos; end',\n    'if isfield(s, \\'bvec\\'), s.bvec(:, flp) = -s.bvec(:, flp); end',\n    'if isfield(s, \\'SliceTiming\\') && flp(iSL) % slices flipped',\n    '    s.SliceTiming = s.SliceTiming(end:-1:1);',\n    '    sc = nii.hdr.slice_code;',\n    '    if sc>0, nii.hdr.slice_code = sc+mod(sc,2)*2-1; end % 1<->2, 3<->4, 5<->6',\n    'end',\n    '',\n    '% sform',\n    'frmCode = all(isfield(s, {\\'ImageOrientationPatient\\' \\'ImagePositionPatient\\'}));',\n    'frmCode = tryGetField(s, \\'TemplateSpace\\', frmCode); % 1: SCANNER_ANAT',\n    'nii.hdr.sform_code = frmCode;',\n    'nii.hdr.srow_x = R(1,:);',\n    'nii.hdr.srow_y = R(2,:);',\n    'nii.hdr.srow_z = R(3,:);',\n    '',\n    '% qform',\n    'if abs(sum(R(:,iSL).^2) - pixdim(iSL)^2) < 0.01 % no shear at slice direction',\n    '    nii.hdr.qform_code = frmCode;',\n    '    nii.hdr.qoffset_x = R(1,4);',\n    '    nii.hdr.qoffset_y = R(2,4);',\n    '    nii.hdr.qoffset_z = R(3,4);',\n    '',\n    '    R = R(1:3, 1:3); % for quaternion',\n    '    R = bsxfun(@rdivide, R, sqrt(sum(R.^2))); % normalize',\n    '    [q, nii.hdr.pixdim(1)] = dcm2quat(R); % 3x3 dir cos matrix to quaternion',\n    '    nii.hdr.quatern_b = q(2);',\n    '    nii.hdr.quatern_c = q(3);',\n    '    nii.hdr.quatern_d = q(4);',\n    'end',\n    '',\n    '% store some possibly useful info in descrip and other text hdr',\n    'str = tryGetField(s, \\'ImageComments\\');',\n    'if isType(s, \\'\\\\MOCO\\\\\\'), str = \\'\\'; end % useless for MoCo',\n    'foo = tryGetField(s, \\'StudyComments\\');',\n    'if ~isempty(foo), str = [str \\';\\' foo]; end',\n    'str = [str \\';\\' strtok(s.Manufacturer)];',\n    'foo = tryGetField(s, \\'ProtocolName\\');',\n    'if ~isempty(foo), str = [str \\';\\' foo]; end',\n    'nii.hdr.aux_file = str; % char[24], info only',\n    'seq = asc_header(s, \\'tSequenceFileName\\'); % like \\'%SiemensSeq%\\\\ep2d_bold\\'',\n    'if isempty(seq), seq = tryGetField(s, \\'ScanningSequence\\'); ',\n    'else [~, seq] = strtok(seq, \\'\\\\\\'); seq = strtok(seq, \\'\\\\\\'); % like \\'ep2d_bold\\'',\n    'end',\n    'nii.hdr.db_name = PatientName(s); % char[18], optional',\n    'nii.hdr.intent_name = seq; % char[16], meaning of the data',\n    '',\n    'if ~isfield(s, \\'AcquisitionDateTime\\') && isfield(s, \\'AcquisitionTime\\')',\n    '    s.AcquisitionDateTime = [tryGetField(s, \\'AcquisitionDate\\', \\'\\') ...',\n    '                             tryGetField(s, \\'AcquisitionTime\\', \\'\\')];',\n    'end',\n    'foo = tryGetField(s, \\'AcquisitionDateTime\\');',\n    'descrip = sprintf(\\'time=%s;\\', foo(1:min(18,end))); ',\n    'TE0 = asc_header(s, \\'alTE[0]\\')/1000; % s.EchoTime stores only 1 TE',\n    'dTE = abs(asc_header(s, \\'alTE[1]\\')/1000 - TE0); % TE difference',\n    'if isempty(TE0), TE0 = tryGetField(s, \\'EchoTime\\'); end % GE, philips',\n    'if isempty(dTE) && tryGetField(s, \\'NumberOfEchoes\\', 1)>1',\n    '    dTE = tryGetField(s, \\'SecondEchoTime\\') - TE0; % need to update',\n    'end',\n    'if ~isempty(dTE)',\n    '    descrip = sprintf(\\'dTE=%.4g;%s\\', dTE, descrip);',\n    '    s.deltaTE = dTE;',\n    'elseif ~isempty(TE0)',\n    '    descrip = sprintf(\\'TE=%.4g;%s\\', TE0, descrip);',\n    'end',\n    '',\n    '% Get dwell time',\n    'if ~strcmp(tryGetField(s, \\'MRAcquisitionType\\'), \\'3D\\') && ~isempty(iPhase)',\n    '    hz = csa_header(s, \\'BandwidthPerPixelPhaseEncode\\');',\n    '    dwell = 1000 ./ hz / dim(iPhase); % in ms',\n    '    if isempty(dwell) % true for syngo MR 2004A',\n    '        % ppf = [1 2 4 8 16] represent [4 5 6 7 8] 8ths PartialFourier',\n    '        % ppf = asc_header(s, \\'sKSpace.ucPhasePartialFourier\\');',\n    '        lns = asc_header(s, \\'sKSpace.lPhaseEncodingLines\\');',\n    '        dur = csa_header(s, \\'SliceMeasurementDuration\\');',\n    '        dwell = dur ./ lns; % ./ (log2(ppf)+4) * 8;',\n    '    end',\n    '    if isempty(dwell) % next is not accurate, so as last resort',\n    '        dur = csa_header(s, \\'RealDwellTime\\') * 1e-6; % ns to ms',\n    '        dwell = dur * asc_header(s, \\'sKSpace.lBaseResolution\\');',\n    '    end',\n    '    if isempty(dwell)',\n    '        dwell = double(tryGetField(s, \\'EffectiveEchoSpacing\\')) / 1000; % GE',\n    '    end',\n    '    % http://www.spinozacentre.nl/wiki/index.php/NeuroWiki:Current_developments',\n    '    if isempty(dwell) % Philips',\n    '        wfs = tryGetField(s, \\'WaterFatShift\\');',\n    '        epiFactor = tryGetField(s, \\'EPIFactor\\');',\n    '        dwell = wfs ./ (434.215 * (double(epiFactor)+1)) * 1000;',\n    '    end',\n    '    if ~isempty(dwell)',\n    '        if s.isDTI',\n    '            % ppf = asc_header(s, \\'sKSpace.ucPhasePartialFourier\\');',\n    '            % lns = asc_header(s, \\'sKSpace.lPhaseEncodingLines\\');',\n    '            % pat = asc_header(s, \\'sPat.ucPATMode\\');',\n    '            % readout = dwell*pat * (lns * (log2(ppf)+4)/8 / pat - 1) / 1000;',\n    '            readout = dwell * dim(iPhase) / 1000; % in sec',\n    '            descrip = sprintf(\\'readout=%.3g;%s\\', readout, descrip);',\n    '            s.ReadoutSeconds = readout;',\n    '        else',\n    '            descrip = sprintf(\\'dwell=%.3g;%s\\', dwell, descrip);',\n    '            s.EffectiveEPIEchoSpacing = dwell;',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'if ~isempty(iPhase)',\n    '    if isempty(phPos), pm = \\'?\\'; elseif phPos, pm = \\'\\'; else pm = \\'-\\'; end',\n    '    axes = \\'xyz\\';',\n    '    phDir = [pm axes(iPhase)];',\n    '    s.UnwarpDirection = phDir;',\n    '    descrip = sprintf(\\'phase=%s;%s\\', phDir, descrip);',\n    'end',\n    'nii.hdr.descrip = descrip; % char[80], drop from end if exceed',\n    '',\n    '% data slope and intercept: apply to img if no rounding error ',\n    'nii.hdr.scl_slope = 1; % default scl_inter is 0',\n    'if any(isfield(s, {\\'RescaleSlope\\' \\'RescaleIntercept\\'}))',\n    '    slope = tryGetField(s, \\'RescaleSlope\\', 1); ',\n    '    inter = tryGetField(s, \\'RescaleIntercept\\', 0); ',\n    '    val = sort([max(nii.img(:)) min(nii.img(:))] * slope + inter);',\n    '    dClass = class(nii.img);',\n    '    if isa(nii.img, \\'float\\') || (mod(slope,1)==0 && mod(inter,1)==0 ... ',\n    '            && val(1)>=intmin(dClass) && val(2)<=intmax(dClass))',\n    '        nii.img = nii.img * slope + inter; % apply to img if no rounding',\n    '    else',\n    '        nii.hdr.scl_slope = slope;',\n    '        nii.hdr.scl_inter = inter;',\n    '    end',\n    'end',\n    '',\n    '% Possible patient position: HFS/HFP/FFS/FFP / HFDR/HFDL/FFDR/FFDL',\n    '% Seems dicom takes care of this, and maybe nothing needs to do here.',\n    '% patientPos = tryGetField(s, \\'PatientPosition\\', \\'\\');',\n    '',\n    '%% Subfunction, reshape mosaic into volume, remove padded zeros',\n    'function vol = mos2vol(mos, nSL)',\n    'nMos = ceil(sqrt(nSL)); % always nMos x nMos tiles',\n    '[nr, nc, nv] = size(mos); % number of row, col and vol in mosaic',\n    '',\n    'nr = nr / nMos; nc = nc / nMos; % number of row and col in slice',\n    'vol = zeros([nr nc nSL nv], class(mos));',\n    'for i = 1:nSL',\n    '    r =    mod(i-1, nMos) * nr + (1:nr); % 2nd slice is tile(2,1)',\n    '    c = floor((i-1)/nMos) * nc + (1:nc);',\n    '    % r = floor((i-1)/nMos) * nr + (1:nr); % 2nd slice is tile(1,2)',\n    '    % c =    mod(i-1, nMos) * nc + (1:nc);',\n    '    vol(:, :, i, :) = mos(r, c, :);',\n    'end',\n    '',\n    '%% subfunction: set slice timing related info',\n    'function [s, hdr] = sliceTiming(s, hdr)',\n    'TR = tryGetField(s, \\'RepetitionTime\\'); % in ms',\n    'if isempty(TR), TR = tryGetField(s, \\'TemporalResolution\\', 0); end',\n    'if TR == 0, return; end',\n    'hdr.pixdim(5) = TR / 1000;',\n    'if tryGetField(s, \\'isDTI\\', 0), return; end',\n    'hdr.xyzt_units = 8; % seconds',\n    'if hdr.dim(5)<3, return; end % skip structual, fieldmap etc',\n    '',\n    't = csa_header(s, \\'MosaicRefAcqTimes\\'); % in ms',\n    'delay = asc_header(s, \\'lDelayTimeInTR\\')/1000; % in ms now',\n    'if isempty(delay), delay = 0; end',\n    'TA = TR - delay;',\n    'if ~isempty(t) && isfield(s, \\'LastFile\\') && max(t)-min(t)>TA % MB wrong vol 1',\n    '    try t = mb_slicetiming(s); end',\n    'end',\n    'if isempty(t), t = tryGetField(s, \\'RefAcqTimes\\'); end % GE or Siemens non-mosaic',\n    '',\n    'nSL = hdr.dim(4);',\n    'if isempty(t) % non-mosaic Siemens: create \\'t\\' based on ucMode',\n    '    ucMode = asc_header(s, \\'sSliceArray.ucMode\\'); % 1/2/4: Asc/Desc/Inter',\n    '    if isempty(ucMode), return; end',\n    '    t = linspace(0, TA, nSL+1)\\'; t(end) = [];',\n    '    if ucMode==2',\n    '        t = t(nSL:-1:1);',\n    '    elseif ucMode==4',\n    '        if mod(nSL,2), t([1:2:nSL 2:2:nSL]) = t;',\n    '        else t([2:2:nSL 1:2:nSL]) = t;',\n    '        end',\n    '    end',\n    '    if asc_header(s, \\'sSliceArray.ucImageNumb\\'), t = t(nSL:-1:1); end % rev-num',\n    '    s.RefAcqTimes = t;',\n    'end',\n    '',\n    'if numel(t)<2, return; end',\n    't = t - min(t); % it may be relative to 1st slice',\n    '',\n    't1 = sort(t);',\n    'dur = mean(diff(t1));',\n    'dif = mean(diff(t));',\n    'if dur==0 || (t1(end)>TA), sc = 0; % no useful info, or bad timing MB',\n    'elseif t1(1) == t1(2), sc = 7; % timing available MB, madeup code 7',\n    'elseif abs(dif-dur)<1e-3, sc = 1; % ascending',\n    'elseif abs(dif+dur)<1e-3, sc = 2; % descending',\n    'elseif t(1)<t(3) % ascending interleaved',\n    '    if t(1)<t(2), sc = 3; % odd slices first',\n    '    else sc = 5; % Siemens even number of slices',\n    '    end',\n    'elseif t(1)>t(3) % descending interleaved',\n    '    if t(1)>t(2), sc = 4;',\n    '    else sc = 6; % Siemens even number of slices',\n    '    end',\n    'else sc = 0; % unlikely to reach',\n    'end',\n    '',\n    's.SliceTiming = 0.5 - t/TR; % as for FSL custom timing',\n    'hdr.slice_code = sc;',\n    'hdr.slice_end = nSL-1; % 0-based, slice_start default to 0',\n    'hdr.slice_duration = min(diff(t1))/1000;',\n    '',\n    '%% subfunction: extract bval & bvec, store in 1st header',\n    'function [h, nii] = get_dti_para(h, nii)',\n    'nSL = nii.hdr.dim(4);',\n    'nDir = nii.hdr.dim(5);',\n    'if nDir<2, return; end',\n    'bval = nan(nDir, 1);',\n    'bvec = nan(nDir, 3);',\n    's = h{1};',\n    '',\n    'if isfield(s, \\'bvec_original\\')',\n    '    bval = s.B_value;',\n    '    bvec = tryGetField(s, \\'bvec_original\\');',\n    'elseif isfield(s, \\'PerFrameFunctionalGroupsSequence\\')',\n    '    fld = \\'PerFrameFunctionalGroupsSequence\\';',\n    '    if tryGetField(s, \\'Dim3IsVolume\\', false), iDir = 1:nDir;',\n    '    else iDir = 1:nSL:nSL*nDir;',\n    '    end',\n    '    dict = dicm_dict(s.Manufacturer, {fld \\'B_value\\' \\'MRDiffusionSequence\\' ...',\n    '        \\'DiffusionGradientDirectionSequence\\' \\'DiffusionGradientDirection\\'});',\n    '    s2 = dicm_hdr(s.Filename, dict, iDir); % re-read needed frames',\n    '    sq = s2.(fld);',\n    '    for j = 1:nDir',\n    '        item = sprintf(\\'Item_%g\\', iDir(j));',\n    '        try',\n    '            a = sq.(item).MRDiffusionSequence.Item_1;',\n    '            bval(j) = a.B_value;',\n    '            a = a.DiffusionGradientDirectionSequence.Item_1;',\n    '            bvec(j,:) = a.DiffusionGradientDirection;',\n    '        end',\n    '    end',\n    'else % multiple files: order already in slices then volumes',\n    '    dict = dicm_dict(s.Manufacturer, {\\'B_value\\' \\'B_factor\\' \\'SlopInt_6_9\\' ...',\n    '       \\'DiffusionDirectionX\\' \\'DiffusionDirectionY\\' \\'DiffusionDirectionZ\\'});',\n    '    iDir = (0:nDir-1) * length(h)/nDir + 1; % could be mosaic ',\n    '    for j = 1:nDir % no these values for 1st file of each excitation',\n    '        s2 = h{iDir(j)};',\n    '        val = tryGetField(s2, \\'B_value\\');',\n    '        if val == 0, continue; end',\n    '        vec = tryGetField(s2, \\'DiffusionGradientDirection\\');',\n    '        imgRef = isempty(vec); % likely GE if true. B_value=0 won\\'t reach here',\n    '        if isempty(val) || isempty(vec) % likely GE',\n    '            s2 = dicm_hdr(s2.Filename, dict);',\n    '        end',\n    '        ',\n    '        if isempty(val), val = tryGetField(s2, \\'B_factor\\'); end % old Philips',\n    '        if isempty(val) && isfield(s2, \\'SlopInt_6_9\\') % GE',\n    '            val = s2.SlopInt_6_9(1);',\n    '        end',\n    '        if isempty(val), val = 0; end % may be B_value=0',\n    '        bval(j) = val;',\n    '        ',\n    '        if isempty(vec) % GE, old Philips',\n    '            vec(1) = tryGetField(s2, \\'DiffusionDirectionX\\', 0);',\n    '            vec(2) = tryGetField(s2, \\'DiffusionDirectionY\\', 0);',\n    '            vec(3) = tryGetField(s2, \\'DiffusionDirectionZ\\', 0);',\n    '        end',\n    '        bvec(j,:) = vec;',\n    '    end',\n    'end',\n    '',\n    'if all(isnan(bval)) && all(isnan(bvec(:)))',\n    '    errorLog([\\'Failed to get DTI parameters: \\' ProtocolName(s)]);',\n    '    return; ',\n    'end',\n    'bval(isnan(bval)) = 0;',\n    'bvec(isnan(bvec)) = 0;',\n    '',\n    'if strncmpi(s.Manufacturer, \\'Philips\\', 7)',\n    '    if max(sum(bvec.^2, 2)) > 2 % guess in degree',\n    '        for j = 1:nDir, bvec(j,:) = ang2vec(bvec(j,:)); end % deg to dir cos mat',\n    '        errorLog([\\'Please validate bvec (direction in deg): \\' ProtocolName(s)]);',\n    '    end',\n    '    fld = \\'DiffusionDirectionality\\';',\n    '    if bval(nDir)~=0 && all(abs(bvec(nDir,:))<1e-4)',\n    '        if ~isfield(s, \\'LastFile\\') || ~isfield(s.LastFile, fld) || ...',\n    '                ~strncmpi(s.LastFile.(fld), \\'ISO\\', 3)',\n    '            % Remove last vol if it is computed ADC',\n    '            bval(nDir) = [];',\n    '            bvec(nDir,:) = [];',\n    '            nii.img(:,:,:,nDir) = [];',\n    '            nDir = nDir - 1;',\n    '            nii.hdr.dim(5) = nDir;',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'h{1}.bval = bval; % store all into header of 1st file',\n    'h{1}.bvec_original = bvec; % original from dicom',\n    '',\n    '% http://wiki.na-mic.org/Wiki/index.php/NAMIC_Wiki:DTI:DICOM_for_DWI_and_DTI',\n    'if exist(\\'imgRef\\', \\'var\\') && imgRef % GE bvec already in image reference',\n    '    % Following sign change is based on FSL result. non-axial slice not tested',\n    '    % GE slices have been sorted by ImagePositionPatient',\n    '    if strcmp(tryGetField(s, \\'InPlanePhaseEncodingDirection\\'), \\'ROW\\')',\n    '        bvec = bvec(:, [2 1 3]);',\n    '        bvec(:, 2:3) = -bvec(:, 2:3);',\n    '    else',\n    '        bvec(:, 1:2) = -bvec(:, 1:2);',\n    '    end',\n    'else % Siemens/Philips',\n    '    [~, R] = xform_mat(s, nii.hdr.dim(2:4)); % R takes care of slice dir',\n    '    R = R(1:3, 1:3);',\n    '    R = bsxfun(@rdivide, R, sqrt(sum(R.^2))); % normalize',\n    '    bvec = bvec * R; % dicom plane to image plane',\n    'end',\n    '',\n    'h{1}.bvec = bvec; % computed bvec',\n    '',\n    '%% subfunction: save bval & bvec files',\n    'function save_dti_para(s, fname)',\n    'if ~isfield(s, \\'bvec\\') || all(s.bvec(:)==0), return; end',\n    'if isfield(s, \\'bval\\')',\n    '    fid = fopen([fname \\'.bval\\'], \\'w\\');',\n    '    fprintf(fid, \\'%g \\', s.bval); % one row',\n    '    fclose(fid);',\n    'end',\n    '',\n    'str = repmat(\\'%.6g \\', 1, size(s.bvec,1));',\n    'fid = fopen([fname \\'.bvec\\'], \\'w\\');',\n    'fprintf(fid, [str \\'\\\\n\\'], s.bvec); % 3 rows by # direction cols',\n    'fclose(fid);',\n    '',\n    '%% Subfunction: convert rotation angles to vector',\n    'function vec = ang2vec(ang)',\n    '% do the same as in philips_par: not sure it is right',\n    'ca = cosd(ang); sa = sind(ang);',\n    'rx = [1 0 0; 0 ca(1) -sa(1); 0 sa(1) ca(1)]; % standard 3D rotation',\n    'ry = [ca(2) 0 sa(2); 0 1 0; -sa(2) 0 ca(2)];',\n    'rz = [ca(3) -sa(3) 0; sa(3) ca(3) 0; 0 0 1];',\n    'R = rx * ry * rz;',\n    '% [~, iSL] = max(abs(R(:,3)));',\n    '% if iSL == 1 % Sag',\n    '%     R(:,[1 3]) = -R(:,[1 3]);',\n    '%     R = R(:, [2 3 1]);',\n    '% elseif iSL == 2 % Cor',\n    '%     R(:,3) = -R(:,3);',\n    '%     R = R(:, [1 3 2]);',\n    '% end',\n    '% http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm',\n    'vec = [R(3,2)-R(2,3); R(1,3)-R(3,1); R(2,1)-R(1,2)];',\n    'vec = vec / sqrt(sum(vec.^2));',\n    '',\n    '%% Subfunction, return a parameter from CSA Image/Series header',\n    'function val = csa_header(s, key, dft)',\n    'if isfield(s, \\'CSAImageHeaderInfo\\') && isfield(s.CSAImageHeaderInfo, key)',\n    '    val = s.CSAImageHeaderInfo.(key);',\n    'elseif isfield(s, \\'CSASeriesHeaderInfo\\') && isfield(s.CSASeriesHeaderInfo, key)',\n    '    val = s.CSASeriesHeaderInfo.(key);',\n    'elseif nargin>2',\n    '    val = dft;',\n    'else',\n    '    val = [];',\n    'end',\n    '',\n    '%% Subfunction, Convert 3x3 direction cosine matrix to quaternion',\n    '% Simplied from Quaternions by Przemyslaw Baranski ',\n    'function [q, proper] = dcm2quat(R)',\n    'proper = sign(det(R)); % always -1 if flip_dim1',\n    'if proper<0, R(:,3) = -R(:,3); end',\n    '',\n    'q = sqrt([1 1 1; 1 -1 -1; -1 1 -1; -1 -1 1] * diag(R) + 1) / 2;',\n    'if ~isreal(q(1)), q(1) = 0; end % if trace(R)+1<0, zero it',\n    '[m, ind] = max(q);',\n    '',\n    'switch ind',\n    '    case 1',\n    '        q(2) = (R(3,2) - R(2,3)) /m/4;',\n    '        q(3) = (R(1,3) - R(3,1)) /m/4;',\n    '        q(4) = (R(2,1) - R(1,2)) /m/4;',\n    '    case 2',\n    '        q(1) = (R(3,2) - R(2,3)) /m/4;',\n    '        q(3) = (R(1,2) + R(2,1)) /m/4;',\n    '        q(4) = (R(3,1) + R(1,3)) /m/4;',\n    '    case 3',\n    '        q(1) = (R(1,3) - R(3,1)) /m/4;',\n    '        q(2) = (R(1,2) + R(2,1)) /m/4;',\n    '        q(4) = (R(2,3) + R(3,2)) /m/4;',\n    '    case 4',\n    '        q(1) = (R(2,1) - R(1,2)) /m/4;',\n    '        q(2) = (R(3,1) + R(1,3)) /m/4;',\n    '        q(3) = (R(2,3) + R(3,2)) /m/4;',\n    'end',\n    'if q(1)<0, q = -q; end % as MRICron',\n    '',\n    '%% Subfunction: get dicom xform matrix and related info',\n    'function [ixyz, R, pixdim, xyz_unit] = xform_mat(s, dim)',\n    'R = reshape(tryGetField(s, \\'ImageOrientationPatient\\', [1 0 0 0 1 0]), 3, 2);',\n    'R(:,3) = cross(R(:,1), R(:,2)); % right handed, but sign may be wrong',\n    'foo = abs(R);',\n    '[~, ixyz] = max(foo); % orientation info: perm of 1:3',\n    'if ixyz(2) == ixyz(1), foo(ixyz(2),2) = 0; [~, ixyz(2)] = max(foo(:,2)); end',\n    'if any(ixyz(3) == ixyz(1:2)), ixyz(3) = setdiff(1:3, ixyz(1:2)); end',\n    'if nargout<2, return; end',\n    'iSL = ixyz(3); % 1/2/3 for Sag/Cor/Tra slice',\n    'cosSL = R(iSL, 3);',\n    '',\n    'thk = tryGetField(s, \\'SpacingBetweenSlices\\');',\n    'if isempty(thk), thk = tryGetField(s, \\'SliceThickness\\'); end',\n    'pixdim = tryGetField(s, \\'PixelSpacing\\');',\n    'if isempty(thk) || isempty(pixdim), xyz_unit = 0; else xyz_unit = 2; end % mm',\n    'if isempty(thk), thk = 1; end',\n    'if isempty(pixdim), pixdim = [1 1]; end',\n    'pixdim = [pixdim(:); thk];',\n    'R = R * diag(pixdim); % apply vox size',\n    '% Next is almost dicom xform matrix, except mosaic trans and unsure slice_dir',\n    'R = [R tryGetField(s, \\'ImagePositionPatient\\', [0 0 0]\\'); 0 0 0 1];',\n    '',\n    '% rest are former: R = verify_slice_dir(R, s, dim, iSL)',\n    'if dim(3)<2, return; end % don\\'t care direction for single slice',\n    '',\n    'if s.Columns > dim(1) % Siemens mosaic: use dim(1) since no transpose to img',\n    '    R(:,4) = R * [ceil(sqrt(dim(3))-1)*dim(1:2)/2 0 1]\\'; % real slice location',\n    '    vec = csa_header(s, \\'SliceNormalVector\\'); % mosaic has this',\n    '    if ~isempty(vec) % exist for all tested data',\n    '        if sign(vec(iSL)) ~= sign(cosSL), R(:,3) = -R(:,3); end',\n    '        return;',\n    '    end',\n    'elseif isfield(s, \\'LastFile\\') && isfield(s.LastFile, \\'ImagePositionPatient\\')',\n    '    R(1:3, 3) = (s.LastFile.ImagePositionPatient - R(1:3,4)) / (dim(3)-1);',\n    '    pixdim(3) = abs(R(iSL,3) / cosSL); % override slice thickness of dcm hdr',\n    '    return; % almost all non-mosaic images return from here',\n    'end',\n    '',\n    '% Rest of the code is almost unreachable',\n    'if isfield(s, \\'CSASeriesHeaderInfo\\') % Siemens',\n    '    ori = {\\'Sag\\' \\'Cor\\' \\'Tra\\'}; ori = ori{iSL};',\n    '    sNormal = asc_header(s, [\\'sSliceArray.asSlice[0].sNormal.d\\' ori]);',\n    '    % csa_header(s, \\'ProtocolSliceNumber\\') won\\'t work for Mprage ',\n    '    if asc_header(s, [\\'sSliceArray.ucImageNumb\\' ori]), sNormal = -sNormal; end',\n    '    if sign(sNormal) ~= sign(cosSL), R(:,3) = -R(:,3); end',\n    '    return;',\n    'end',\n    '',\n    '% GE: sorted by ImagePosition, so slice dir is determined',\n    'if strncmpi(tryGetField(s, \\'Manufacturer\\', \\'\\'),  \\'GE\\', 2)',\n    '    % if iSL==1, cosSL = -cosSL; end % turn on this if SAG sorted descending',\n    '    if cosSL<0, R(:,3) = -R(:,3); end',\n    '    return;',\n    'end',\n    '',\n    'pos = []; % SliceLocation for last or center slice we try to retrieve',\n    '% if isempty(pos) && isfield(s, \\'LastScanLoc\\') && isfield(s, \\'FirstScanLocation\\')',\n    '%     pos = [s.LastScanLoc s.FirstScanLocation];',\n    '%     if iSL<3, pos = -pos; end % RAS convention!',\n    '%     % if iSL==1, pos = -pos; end',\n    '%     pos = max(pos);',\n    '%     pos = [R(iSL, 1:2) pos] * [-(dim(1:2)-1)/2 1]\\'; % 1st or last SliceLocation',\n    '% end',\n    '',\n    '% May be useful for Philips dicom: use volume centre info',\n    'if isempty(pos) && isfield(s, \\'Stack\\')',\n    '    ori = {\\'RL\\' \\'AP\\' \\'FH\\'}; ori = ori{iSL};',\n    '    pos = tryGetField(s.Stack.Item_1, [\\'MRStackOffcentre\\' ori]);',\n    '    if ~isempty(pos)',\n    '        pos = [R(iSL, 1:2) pos] * [-dim(1:2)/2 1]\\'; % mid-slice location',\n    '    end',\n    'end',\n    '',\n    'if ~isempty(pos) % have SliceLocation for last/center slice',\n    '    flp = sign(pos-R(iSL,4)) ~= sign(cosSL); % same direction?',\n    'else % we do some guess work and warn user',\n    '    errorLog([\\'Please check whether slices are flipped: \\' ProtocolName(s)]);',\n    '    pos1 = R(iSL, 3:4) * [dim(3)-1 1]\\'; % last SliceLocation based on current R',\n    '    pos2 = R(iSL, 3:4) * [1-dim(3) 1]\\'; % opposite slice direction',\n    '    % if pos1 is larger than the other dir, and is way outside head',\n    '    flp = all(abs(pos1) > [abs(pos2) 150]); % arbituary 150 mm',\n    'end',\n    'if flp, R(:,3) = -R(:,3); end % change to opposite direction',\n    '',\n    '%% Subfunction: get a parameter in CSA series ASC header: MrPhoenixProtocol',\n    'function val = asc_header(s, key)',\n    'val = []; ',\n    'fld = \\'CSASeriesHeaderInfo\\';',\n    'if ~isfield(s, fld), return; end',\n    'if isfield(s.(fld), \\'MrPhoenixProtocol\\')',\n    '    str = s.(fld).MrPhoenixProtocol;',\n    'elseif isfield(s.(fld), \\'MrProtocol\\') % older version dicom',\n    '    str = s.(fld).MrProtocol;',\n    'else',\n    '    str = char(s.(fld)\\');',\n    '    k0 = strfind(str, \\'### ASCCONV BEGIN ###\\');',\n    '    k  = strfind(str, \\'### ASCCONV END ###\\');',\n    '    str = str(k0:k); % avoid key before BEGIN and after END',\n    'end',\n    'k = strfind(str, [char(10) key]); % start with new line: safer',\n    'if isempty(k), return; end',\n    'str = strtok(str(k(1):end), char(10)); % the line',\n    '[~, str] = strtok(str, \\'=\\'); % \\'=\\' and the vaule',\n    'str = strtrim(strtok(str, \\'=\\')); % remvoe \\'=\\' and space ',\n    '',\n    'if strncmp(str, \\'\"\"\\', 2) % str parameter',\n    '    val = str(3:end-2);',\n    'elseif strncmp(str, \\'\"\\', 1) % str parameter for version like 2004A',\n    '    val = str(2:end-1);',\n    'elseif strncmp(str, \\'0x\\', 2) % hex parameter, convert to decimal',\n    '    val = sscanf(str(3:end), \\'%x\\', 1);',\n    'else % decimal',\n    '    val = str2double(str);',\n    'end',\n    '',\n    '%% Subfunction: return matlab decompress command if the file is compressed',\n    'function func = compress_func(fname)',\n    'func = \\'\\';',\n    'fid = fopen(fname);',\n    'if fid<0, return; end',\n    'sig = fread(fid, 2, \\'*uint8\\')\\';',\n    'fclose(fid);',\n    'if isequal(sig, [80 75]) % zip file',\n    '    func = \\'unzip\\';',\n    'elseif isequal(sig, [31 139]) % gz, tgz, tar',\n    '    func = \\'untar\\';',\n    'end',\n    '% ! \"c:\\\\program Files (x86)\\\\7-Zip\\\\7z.exe\" x -y -oF:\\\\tmp\\\\ F:\\\\zip\\\\3047ZL.zip',\n    '',\n    '%% Subfuction: for GUI subfunctions',\n    'function dicm2nii_gui(cmd, hs)',\n    'if nargin<2',\n    '    fh = figure(\\'dicm\\' * 256.^(0:3)\\'); % arbitury integer',\n    '    hs = guidata(fh); ',\n    'end',\n    'drawnow;',\n    'switch cmd',\n    '    case \\'do_convert\\'',\n    '        if get(hs.srcType, \\'Value\\') > 2 % dicom, PAR, HEAD files',\n    '            src = get(hs.src, \\'UserData\\');',\n    '        else',\n    '            src = get(hs.src, \\'String\\');',\n    '        end',\n    '        dst = get(hs.dst, \\'String\\');',\n    '        if isempty(src) || isempty(dst)',\n    '            str = \\'Dicom source and Result folder must be specified\\';',\n    '            errordlg(str, \\'Error Dialog\\');',\n    '            return;',\n    '        end',\n    '        rstFmt = (get(hs.rstFmt, \\'Value\\') - 1) * 2; % 0 or 2',\n    '        if get(hs.gzip,  \\'Value\\'), rstFmt = rstFmt + 1; end % 1 or 3 ',\n    '        if get(hs.rst3D, \\'Value\\'), rstFmt = rstFmt + 4; end % 4 to 7',\n    '        mocoOpt = get(hs.mocoOpt, \\'Value\\') - 1;',\n    '        set(hs.convert, \\'Enable\\', \\'off\\', \\'string\\', \\'Conversion in progress\\');',\n    '        clnObj = onCleanup(@()set(hs.convert, \\'Enable\\', \\'on\\', \\'String\\', \\'Start conversion\\')); ',\n    '        drawnow;',\n    '        dicm2nii(src, dst, rstFmt, mocoOpt);',\n    '        ',\n    '        para.srcType = get(hs.srcType, \\'Value\\');',\n    '        para.rstFmt = get(hs.rstFmt, \\'Value\\');',\n    '        para.rst3D = get(hs.rst3D, \\'Value\\');',\n    '        para.gzip = get(hs.gzip, \\'Value\\');',\n    '        para.mocoOpt = get(hs.mocoOpt, \\'Value\\');',\n    '        para.src = get(hs.src, \\'String\\');',\n    '        para.dst = get(hs.dst, \\'String\\');',\n    '        try save(get(hs.convert, \\'UserData\\'), \\'para\\'); end %#ok<*TRYNC>        ',\n    '    case \\'srcType\\'',\n    '        i = get(hs.srcType, \\'Value\\');',\n    '        txt = {\\'Source folder\\' \\'Zip / tar file\\' \\'Dicom files\\' \\'PAR files\\' \\'HEAD files\\' \\'BV files\\'};',\n    '        set(hs.srcTxt, \\'String\\' , txt{i});',\n    '        srcdir = isdir(get(hs.src, \\'String\\'));',\n    '        if (i==1 && ~srcdir) || (i>1 && srcdir)',\n    '            set(hs.src, \\'String\\', \\'\\');',\n    '        end',\n    '    case \\'dstDialog\\'',\n    '        folder = get(hs.dst, \\'String\\'); % current folder',\n    '        if ~isdir(folder), folder = get(hs.src, \\'String\\'); end',\n    '        if ~isdir(folder), folder = fileparts(folder); end',\n    '        if ~isdir(folder), folder = pwd; end',\n    '        dst = uigetdir(folder, \\'Select a folder to save data files\\');',\n    '        if isnumeric(dst), return; end',\n    '        set(hs.dst, \\'String\\' , dst);',\n    '    case \\'srcDialog\\'',\n    '        folder = get(hs.src, \\'String\\'); % initial folder',\n    '        if ~isdir(folder), folder = fileparts(folder); end',\n    '        if ~isdir(folder), folder = pwd; end',\n    '        i = get(hs.srcType, \\'Value\\');',\n    '        if i == 1 % folder',\n    '            src = uigetdir(folder, \\'Select a folder containing convertible files\\');',\n    '            if isnumeric(src), return; end',\n    '            set(hs.src, \\'UserData\\', src);',\n    '        elseif i == 2 % zip/tgz file',\n    '            [src, folder] = uigetfile([folder \\'/*.zip;*.tgz;*.tar;*.tar.gz\\'], ...',\n    '                \\'Select the compressed file containing data files\\');',\n    '            if isnumeric(src), return; end',\n    '            src = fullfile(folder, src);',\n    '            set(hs.src, \\'UserData\\', src);',\n    '        elseif i == 3 % dicom files',\n    '            [src, folder] = uigetfile([folder \\'/*.dcm\\'], ...',\n    '                \\'Select one or more DICOM files\\', \\'MultiSelect\\', \\'on\\');',\n    '            if isnumeric(src), return; end',\n    '            src = cellstr(src); % in case only 1 file selected',\n    '            src = strcat(folder, filesep, src);',\n    '            set(hs.src, \\'UserData\\', src);',\n    '            src = src{1};',\n    '        elseif i == 4 % PAR',\n    '            [src, folder] = uigetfile([folder \\'/*.PAR\\'], ...',\n    '                \\'Select one or more PAR files\\', \\'MultiSelect\\', \\'on\\');',\n    '            if isnumeric(src), return; end',\n    '            src = cellstr(src); % in case only 1 file selected',\n    '            src = strcat(folder, src);',\n    '            set(hs.src, \\'UserData\\', src);',\n    '            src = src{1};',\n    '        elseif i == 5 % HEAD/BRIK',\n    '            [src, folder] = uigetfile([folder \\'/*.HEAD\\'], ...',\n    '                \\'Select one or more HEAD files\\', \\'MultiSelect\\', \\'on\\');',\n    '            if isnumeric(src), return; end',\n    '            src = cellstr(src); % in case only 1 file selected',\n    '            src = strcat(folder, src);',\n    '            set(hs.src, \\'UserData\\', src);',\n    '            src = src{1};',\n    '        elseif i == 6 % BV files',\n    '            [src, folder] = uigetfile([folder \\'/*.fmr;*.vmr;*.dmr\\'], ...',\n    '                \\'Select one or more BrainVoyager fmr/vmr/dmr files\\', \\'MultiSelect\\', \\'on\\');',\n    '            if isnumeric(src), return; end',\n    '            src = cellstr(src); % in case only 1 file selected',\n    '            src = strcat(folder, src);',\n    '            set(hs.src, \\'UserData\\', src);',\n    '            src = src{1};',\n    '        end',\n    '        set(hs.src, \\'String\\' , src);',\n    '    case \\'set_src\\'',\n    '        str = get(hs.src, \\'String\\');',\n    '        if ~exist(str, \\'file\\')',\n    '            val = dir(str);',\n    '            folder = fileparts(str);',\n    '            if isempty(val)',\n    '                val = get(hs.src, \\'UserData\\');',\n    '                if iscellstr(val), val = val{1}; end',\n    '                set(hs.src, \\'String\\', val);',\n    '                errordlg(\\'Invalid input\\', \\'Error Dialog\\');',\n    '                return;',\n    '            end',\n    '            str = {val.name};',\n    '            str = strcat(folder, filesep, str);',\n    '        end',\n    '        set(hs.src, \\'UserData\\', str);',\n    '    case \\'set_dst\\'',\n    '        str = get(hs.dst, \\'String\\');',\n    '        if isempty(str), return; end',\n    '        if ~exist(str, \\'file\\') && ~mkdir(str)',\n    '            set(hs.dst, \\'String\\', \\'\\');',\n    '            errordlg([\\'Invalid folder name \\'\\'\\' str \\'\\'\\'\\'], \\'Error Dialog\\');',\n    '            return;',\n    '        end',\n    '    case \\'SPMStyle\\' % turn off compression',\n    '        if get(hs.rst3D, \\'Value\\'), set(hs.gzip, \\'Value\\', 0); end',\n    '    case \\'about\\'',\n    '        if get(hs.about, \\'Value\\')==1',\n    '            str = sprintf([\\'dicm2nii.m by Xiangrui Li\\\\n\\\\n\\' ...',\n    '                \\'Feedback to: xiangrui.li@gmail.com\\\\n\\\\n\\' ...',\n    '                \\'Last updated on 20%s\\\\n\\'], reviseDate);',\n    '            helpdlg(str, \\'About dicm2nii\\')',\n    '        else',\n    '            fid = fopen([fileparts(which(mfilename)) \\'/license.txt\\']);',\n    '            if fid<1',\n    '                str = \\'license.txt file not found\\';',\n    '            else',\n    '                str = strtrim(fread(fid, \\'*char\\')\\');',\n    '                fclose(fid);',\n    '            end',\n    '            helpdlg(str, \\'License\\')',\n    '        end',\n    '        set(hs.about, \\'Value\\', 1);',\n    '    otherwise',\n    '        create_gui;',\n    'end',\n    '',\n    '%% Subfuction: create GUI or bring it to front if exists',\n    'function create_gui',\n    'fh = figure(\\'dicm\\' * 256.^(0:3)\\'); % arbitury integer',\n    'if strcmp(\\'dicm2nii_fig\\', get(fh, \\'Tag\\')), return; end',\n    '',\n    'fnameH = [getenv(\\'HOME\\') \\'/dicm2nii_gui_para.mat\\'];',\n    'fname = fnameH;',\n    'if ~exist(fname, \\'file\\')',\n    '    fname = [fileparts(which(mfilename)) \\'/dicm2nii_gui_para.mat\\'];',\n    '    if ~exist(fname, \\'file\\')',\n    '        fid = fopen(fname, \\'w\\'); % check permission',\n    '        if fid<1',\n    '            fname = fnameH;',\n    '        else',\n    '            fclose(fid); delete(fname);',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'scrSz = get(0, \\'ScreenSize\\');',\n    'set(fh, \\'Toolbar\\', \\'none\\', \\'Menubar\\', \\'none\\', \\'Resize\\', \\'off\\', ...',\n    '    \\'Tag\\', \\'dicm2nii_fig\\', \\'Position\\', [200 scrSz(4)-500 420 256], ...',\n    '    \\'Name\\', \\'DICOM to NIfTI Converter\\', \\'NumberTitle\\', \\'off\\');',\n    'clr = get(fh, \\'color\\');',\n    '',\n    'str = \\'Choose what kind of data source you are using\\';',\n    'uicontrol(\\'Style\\', \\'text\\', \\'Position\\', [10 206 90 30], ...',\n    '    \\'FontSize\\', 9, \\'HorizontalAlignment\\', \\'left\\', ...',\n    '    \\'String\\', \\'Source type\\', \\'Background\\', clr, \\'TooltipString\\', str);',\n    'uicontrol(\\'Style\\', \\'popup\\', \\'Background\\', \\'white\\', \\'Tag\\', \\'srcType\\', ...',\n    '    \\'String\\', [\\' Folder containing convertible files and/or folders|\\' ...',\n    '               \\' Compressed file containing data|\\' ...',\n    '               \\' Dicom files|\\' ...',\n    '               \\' Philips PAR files|\\' ...',\n    '               \\' AFNI HEAD files|\\' ...',\n    '               \\' BrainVoyager dmr/fmr/vmr files\\'], ...',\n    '    \\'Position\\', [88 210 320 30], \\'TooltipString\\', str, ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'srcType\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '',\n    'str = \\'Enter or browse the data source according to the source type\\';',\n    'uicontrol(\\'Style\\', \\'text\\', \\'Position\\', [10 166 90 30], ...',\n    '    \\'Tag\\', \\'srcTxt\\', \\'FontSize\\', 9, \\'HorizontalAlignment\\', \\'left\\', ...',\n    '    \\'String\\', \\'Source folder\\', \\'Background\\', clr, \\'TooltipString\\', str);',\n    'uicontrol(\\'Style\\', \\'edit\\', \\'Position\\', [88 176 296 24],\\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'Background\\', \\'white\\', \\'Tag\\', \\'src\\', ...',\n    '    \\'TooltipString\\', str, ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'set_src\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    'uicontrol(\\'Style\\', \\'pushbutton\\', \\'Position\\', [384 177 24 22], ...',\n    '    \\'FontSize\\', 9, \\'String\\', \\'...\\', ...',\n    '    \\'TooltipString\\', \\'Browse dicom source\\', ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'srcDialog\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '',\n    'str = \\'Enter or browse a folder to save result files\\';',\n    'uicontrol(\\'Style\\', \\'text\\', \\'Position\\', [10 126 90 30], ...',\n    '    \\'FontSize\\', 9, \\'HorizontalAlignment\\', \\'left\\', ...',\n    '    \\'String\\', \\'Result folder\\', \\'Background\\', clr, \\'TooltipString\\', str);',\n    'uicontrol(\\'Style\\', \\'edit\\', \\'Position\\', [88 136 296 24], \\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'Background\\', \\'white\\', ...',\n    '    \\'Tag\\', \\'dst\\', \\'TooltipString\\', str, ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'set_dst\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    'uicontrol(\\'Style\\', \\'pushbutton\\', \\'Position\\', [384 137 24 22], ...',\n    '    \\'FontSize\\', 9, \\'String\\', \\'...\\', ...',\n    '    \\'TooltipString\\', \\'Browse result folder\\', ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'dstDialog\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '',\n    'str = \\'Choose output file format\\';',\n    'uicontrol(\\'Style\\', \\'text\\', \\'Position\\', [10 88 90 30], \\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'String\\', \\'Output format\\', ...',\n    '    \\'Background\\', clr, \\'TooltipString\\', str);',\n    '',\n    'uicontrol(\\'Style\\', \\'popup\\', \\'Background\\', \\'white\\', \\'Tag\\', \\'rstFmt\\', ...',\n    '    \\'Value\\', 1, \\'Position\\', [88 92 100 30], \\'TooltipString\\', str, ...',\n    '    \\'String\\', \\' .nii| .hdr/.img\\');',\n    '',\n    'str = \\'Compress into .gz files\\';',\n    'uicontrol(\\'Style\\', \\'checkbox\\', \\'Position\\', [220 96 112 30], \\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'String\\', \\'Compress\\', ...',\n    '    \\'Background\\', clr, \\'TooltipString\\', str, \\'Tag\\', \\'gzip\\');',\n    '',\n    'str = \\'Save one file for each volume (SPM style)\\';',\n    'uicontrol(\\'Style\\', \\'checkbox\\', \\'Position\\', [330 96 72 30], \\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'String\\', \\'SPM 3D\\', ...',\n    '    \\'Background\\', clr, \\'TooltipString\\', str, \\'Tag\\', \\'rst3D\\', ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'SPMStyle\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '           ',\n    'str = \\'Choose the way to deal with SIEMENS MoCo series\\';',\n    'uicontrol(\\'Style\\', \\'text\\', \\'Position\\', [10 46 90 30], \\'FontSize\\', 9, ...',\n    '    \\'HorizontalAlignment\\', \\'left\\', \\'String\\', \\'MoCoSeries\\', ...',\n    '    \\'Background\\', clr, \\'TooltipString\\', str);',\n    'uicontrol(\\'Style\\', \\'popup\\', \\'Background\\', \\'white\\', \\'Tag\\', \\'mocoOpt\\', ...',\n    '     \\'Position\\', [88 50 320 30], \\'Value\\', 2, \\'TooltipString\\', str, ...',\n    '     \\'String\\', [\\' Convert both original and MoCo series|\\' ...',\n    '                \\' Convert only original series if both exist|\\' ...',\n    '                \\' Convert only MoCo series if both exist\\']);',\n    '',\n    'uicontrol(\\'Style\\', \\'pushbutton\\', \\'Position\\', [104 10 200 30], ...',\n    '    \\'FontSize\\', 9, \\'String\\', \\'Start conversion\\', \\'Tag\\', \\'convert\\', ...',\n    '    \\'UserData\\', fname, ...',\n    '    \\'TooltipString\\', \\'Dicom source and Result folder needed before start\\', ...',\n    '    \\'Callback\\', \\'dicm2nii([],\\'\\'do_convert\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '',\n    'uicontrol(\\'Style\\', \\'popup\\', \\'Tag\\', \\'about\\', \\'String\\', \\'About|License\\', ...',\n    '    \\'Position\\', [354 4 56 30], \\'Callback\\', \\'dicm2nii([],\\'\\'about\\'\\',\\'\\'gui_callback\\'\\');\\');',\n    '',\n    'hs = guihandles(fh); % get handles',\n    'guidata(fh, hs); % store handles',\n    'set(fh, \\'HandleVisibility\\', \\'callback\\'); % protect from command line',\n    '',\n    'if ~exist(fname, \\'file\\'), return; end',\n    'para = load(fname); para = para.para;',\n    'fn = fieldnames(para);',\n    'for i = 1:length(fn)',\n    '    tag = fn{i};',\n    '    if ~isfield(hs, tag)',\n    '        continue;  % avoid error',\n    '    elseif strcmpi(get(hs.(tag), \\'Style\\'), \\'edit\\')',\n    '        set(hs.(tag), \\'String\\', para.(tag));',\n    '    else',\n    '        set(hs.(tag), \\'Value\\', para.(tag));',\n    '    end',\n    '    cb = get(hs.(tag), \\'Callback\\');',\n    '    if ~isempty(cb), eval(cb); end',\n    'end',\n    '',\n    '%% subfunction: return phase positive and phase axis (1/2) in image reference',\n    'function [phPos, iPhase] = phaseDirection(s)',\n    'phPos = []; iPhase = [];',\n    'fld = \\'InPlanePhaseEncodingDirection\\';',\n    'if isfield(s, fld)',\n    '    if     strncmpi(s.(fld), \\'COL\\', 3), iPhase = 2; % based on dicm_img(s,0)',\n    '    elseif strncmpi(s.(fld), \\'ROW\\', 3), iPhase = 1;',\n    '    else errorLog([\\'Unknown \\' fld \\' for \\' ProtocolName(s) \\': \\' s.(fld)]);',\n    '    end',\n    'end',\n    '',\n    'if strncmpi(s.Manufacturer, \\'SIEMENS\\', 7)',\n    '    phPos = csa_header(s, \\'PhaseEncodingDirectionPositive\\'); % image ref',\n    'elseif strncmpi(s.Manufacturer, \\'GE\\', 2)',\n    '    fld = \\'ProtocolDataBlock\\';',\n    '    if isfield(s, fld) && isfield(s.(fld), \\'VIEWORDER\\')',\n    '        phPos = s.(fld).VIEWORDER == 1; % 1 == bottom_up',\n    '    end',\n    'elseif strncmpi(s.Manufacturer, \\'Philips\\', 7)',\n    '    if ~isfield(s, \\'ImageOrientationPatient\\'), return; end',\n    '    fld = \\'MRStackPreparationDirection\\';',\n    '    if ~isfield(s, \\'Stack\\') || ~isfield(s.Stack.Item_1, fld), return; end',\n    '    R = reshape(s.ImageOrientationPatient, 3, 2);',\n    '    [~, ixy] = max(abs(R)); % like [1 2]',\n    '    d = s.Stack.Item_1.(fld)(1); % 2-letter like \\'AP\\'',\n    '    if isempty(iPhase) % if no InPlanePhaseEncodingDirection',\n    '        iPhase = strfind(\\'RLAPFH\\', d);',\n    '        iPhase = ceil(iPhase/2); % 1/2/3 for RL/AP/FH',\n    '        iPhase = find(ixy==iPhase); % now 1 or 2',\n    '    end',\n    '    if     any(d == \\'LPH\\'), phPos = false;',\n    '    elseif any(d == \\'RAF\\'), phPos = true;',\n    '    end',\n    '    if R(ixy(iPhase), iPhase)<0, phPos = ~phPos; end % tricky',\n    'end',\n    '',\n    '%% subfunction: extract useful fields for multiframe dicom',\n    'function s = multiFrameFields(s)',\n    'if any(~isfield(s, {\\'SharedFunctionalGroupsSequence\\' ...',\n    '        \\'PerFrameFunctionalGroupsSequence\\'}))',\n    '    return; % do nothing',\n    'end',\n    's1 = s.SharedFunctionalGroupsSequence.Item_1;',\n    's2 = s.PerFrameFunctionalGroupsSequence.Item_1;',\n    '',\n    'fld = \\'EffectiveEchoTime\\'; n1 = \\'MREchoSequence\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1; val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, \\'EchoTime\\') && ~isempty(val), s.EchoTime = val; end',\n    'if ~isfield(s, \\'EchoTime\\') && isfield(s, \\'EchoTimeDisplay\\')',\n    '\ts.EchoTime = s.EchoTimeDisplay;',\n    'end',\n    '',\n    'n1 = \\'MRTimingAndRelatedParametersSequence\\';',\n    'fld = \\'RepetitionTime\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'PixelSpacing\\'; n1 = \\'PixelMeasuresSequence\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'SpacingBetweenSlices\\';  val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'SliceThickness\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'RescaleIntercept\\'; n1 = \\'PixelValueTransformationSequence\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'RescaleSlope\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'ImageOrientationPatient\\'; n1 = \\'PlaneOrientationSequence\\'; val = [];',\n    'if isfield(s1, n1)',\n    '    a = s1.(n1).Item_1;  val = tryGetField(a, fld);',\n    'elseif isfield(s2, n1)',\n    '    a = s2.(n1).Item_1;  val = tryGetField(a, fld);',\n    'end',\n    'if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    '',\n    'fld = \\'ImagePositionPatient\\'; n1 = \\'PlanePositionSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1); val = tryGetField(a.Item_1, fld);',\n    '    if ~isfield(s, fld) && ~isempty(val), s.(fld) = val; end',\n    'end',\n    '',\n    's2 = s.PerFrameFunctionalGroupsSequence;',\n    'n1 = fieldnames(s2);',\n    'if length(n1) < 2, return; end % in case of only 1 frame',\n    's2 = s2.(n1{end}); % last frame',\n    '',\n    'fld = \\'DiffusionDirectionality\\'; n1 = \\'MRDiffusionSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val), s.LastFile.(fld) = val; end',\n    'end',\n    '',\n    '% check ImageOrientationPatient consistency for 1st and last frame only',\n    'fld = \\'ImageOrientationPatient\\'; n1 = \\'PlaneOrientationSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val)',\n    '        try',\n    '            if any(abs(val-s.ImageOrientationPatient) > 1e-4)',\n    '                s = []; % silently ignore it',\n    '                return; % inconsistent orientation, remove the field',\n    '            end',\n    '        end',\n    '    end',\n    'end',\n    '',\n    '% GE data may need this to get LocationsInAcquisition',\n    'fld = \\'DimensionIndexValues\\'; n1 = \\'FrameContentSequence\\';',\n    'if isfield(s2, n1) && ~isfield(s, \\'LocationsInAcquisition\\')',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if numel(val)>1, s.LocationsInAcquisition = val(2); end',\n    'end',\n    '',\n    'fld = \\'ImagePositionPatient\\'; n1 = \\'PlanePositionSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val), s.LastFile.(fld) = val; end',\n    'end',\n    '',\n    'fld = \\'ComplexImageComponent\\'; n1 = \\'MRImageFrameTypeSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val), s.LastFile.(fld) = val; end',\n    'end',\n    '',\n    'fld = \\'RescaleIntercept\\'; n1 = \\'PixelValueTransformationSequence\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val), s.LastFile.(fld) = val; end',\n    'end',\n    'fld = \\'RescaleSlope\\';',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if ~isempty(val), s.LastFile.(fld) = val; end',\n    'end',\n    '',\n    'fld = \\'ImagePositionPatient\\'; n1 = \\'PlanePositionSequence\\';',\n    's2 = s.PerFrameFunctionalGroupsSequence.Item_2;',\n    'if isfield(s2, n1)',\n    '    a = s2.(n1).Item_1; val = tryGetField(a, fld);',\n    '    if isfield(s, fld) && all(abs(s.(fld)-val)<1e-4)',\n    '        s.Dim3IsVolume = true;',\n    '    end',\n    '    if isfield(s, \\'LocationsInAcquisition\\'), return; end',\n    '    ',\n    '    % Following code try to get LocationsInAcquisition',\n    '    if isempty(val) || ~isfield(s, \\'ImageOrientationPatient\\') || ...',\n    '          ~isfield(s, \\'LastFile\\') || ~isfield(s.LastFile, fld)',\n    '        return; % give up: no needed info',\n    '    end',\n    '    ',\n    '    R = reshape(s.ImageOrientationPatient, 3, 2);',\n    '    [cosSL, iSL] = max(abs(cross(R(:,1), R(:,2))));',\n    '    dVL = s.LastFile.(fld) - s.(fld); dVL = dVL(iSL);',\n    '',\n    '    if ~tryGetField(s, \\'Dim3IsVolume\\', false) % frames 1&2 are different slices',\n    '        dSL = val(iSL) - s.(fld)(iSL);',\n    '        s.LocationsInAcquisition = abs(round(dVL/dSL)) + 1;',\n    '        return;',\n    '    end',\n    '    ',\n    '    thk = tryGetField(s, \\'SpacingBetweenSlices\\');',\n    '    if isempty(thk), thk = tryGetField(s, \\'SliceThickness\\'); end',\n    '    if ~isempty(thk)',\n    '        s.LocationsInAcquisition = abs(round(dVL/cosSL/thk)) + 1;',\n    '        return;',\n    '    end',\n    '    ',\n    '    % By ImagePositionPatient of all frames: slow',\n    '    dict = dicm_dict(\\'\\', {\\'PerFrameFunctionalGroupsSequence\\' n1 fld});',\n    '    s2 = dicm_hdr(s.Filename, dict, \\'all\\');',\n    '    s2 = s2.PerFrameFunctionalGroupsSequence;',\n    '    flds = fieldnames(s2);',\n    '    n = length(flds);',\n    '    a = nan(n, 1);',\n    '    for i = 1:n, a(i) = s2.(flds{i}).(n1).Item_1.(fld)(iSL); end',\n    '    s.LocationsInAcquisition = sum(diff(sort(a)) > 1e-4) + 1;',\n    'end',\n    '',\n    '%% subfunction: split nii into mag and phase for Philips single file',\n    'function [nii, niiP] = split_philips_phase(nii, s)',\n    'niiP = [];',\n    'if ~strcmp(tryGetField(s, \\'ComplexImageComponent\\', \\'\\'), \\'MIXED\\') ... % multiframe',\n    '        && (~isfield(s, \\'VolumeIsPhase\\') || ... ',\n    '            all(s.VolumeIsPhase) || ~any(s.VolumeIsPhase)) % not MIXED',\n    '    return;',\n    'end',\n    '',\n    'if ~isfield(s, \\'VolumeIsPhase\\') % PAR file and single-frame file have this',\n    '    dim = nii.hdr.dim(4:5);',\n    '    if tryGetField(s, \\'Dim3IsVolume\\'), iFrames = 1:dim(2);',\n    '    else iFrames = 1:dim(1):dim(1)*dim(2);',\n    '    end',\n    '    flds = {\\'PerFrameFunctionalGroupsSequence\\' ...',\n    '        \\'MRImageFrameTypeSequence\\' \\'ComplexImageComponent\\'};',\n    '    if dim(2) == 2 % 2 volumes, no need to re-read ComplexImageComponent',\n    '        iFrames(2) = dim(1)*dim(2); % use last frame',\n    '        s1.(flds{1}) = s.(flds{1});        ',\n    '    else',\n    '        dict = dicm_dict(s.Manufacturer, flds);',\n    '        s1 = dicm_hdr(s.Filename, dict, iFrames);',\n    '    end',\n    '    s.VolumeIsPhase = false(dim(2), 1);',\n    '    for i = 1:dim(2)',\n    '        Item = sprintf(\\'Item_%g\\', iFrames(i));',\n    '        foo = s1.(flds{1}).(Item).(flds{2}).Item_1.(flds{3});',\n    '        s.VolumeIsPhase(i) = strcmp(foo, \\'PHASE\\');',\n    '    end',\n    'end',\n    '',\n    'niiP = nii;',\n    'niiP.img = nii.img(:,:,:,s.VolumeIsPhase);',\n    'n = sum(s.VolumeIsPhase);',\n    'niiP.hdr.dim(5) = n; % may be 1 always',\n    'niiP.hdr.dim(1) = 3 + (n>1);',\n    '',\n    'nii.img(:,:,:,s.VolumeIsPhase) = []; % now only mag',\n    'n = sum(~s.VolumeIsPhase);',\n    'nii.hdr.dim(5) = n; % may be 1 always',\n    'nii.hdr.dim(1) = 3 + (n>1);',\n    '',\n    '% undo scale for 2nd set img if it was applied in set_nii_header',\n    'if (nii.hdr.scl_inter==0) && (nii.hdr.scl_slope==1) && ...',\n    '        (tryGetfield(s, \\'RescaleIntercept\\') ~=0 ) && ...',\n    '        (tryGetfield(s, \\'RescaleSlope\\') ~= 1)',\n    '    if s.VolumeIsPhase(1)',\n    '        nii.img = (nii.img - s.RescaleIntercept) / s.RescaleSlope;',\n    '        nii.hdr.scl_inter = s.LastFile.RescaleIntercept;',\n    '        nii.hdr.scl_slope = s.LastFile.RescaleSlope;',\n    '    else',\n    '        niiP.img = (niiP.img - s.RescaleIntercept) / s.RescaleSlope;',\n    '        niiP.hdr.scl_inter = s.LastFile.RescaleIntercept;',\n    '        niiP.hdr.scl_slope = s.LastFile.RescaleSlope;',\n    '    end',\n    'end',\n    '',\n    '%% Write error info to a file in case user ignores Command Window output',\n    'function firstTime = errorLog(errInfo, folder)',\n    'persistent dataFolder;',\n    'if nargin>1, firstTime = isempty(dataFolder); dataFolder = folder; end',\n    'if isempty(errInfo), return; end',\n    'fprintf(2, \\' %s\\\\n\\', errInfo); % red text in Command Window',\n    'fid = fopen([dataFolder \\'dicm2nii_warningMsg.txt\\'], \\'a\\');',\n    'fseek(fid, 0, -1); ',\n    'fprintf(fid, \\'%s\\\\n\\', errInfo);',\n    'fclose(fid);',\n    '',\n    '%% Get the last date string in history',\n    'function dStr = reviseDate',\n    'dStr = \\'150609?\\';',\n    'fid = fopen(which(mfilename));',\n    'if fid<1, return; end',\n    'str = fread(fid, \\'*char\\')\\';',\n    'fclose(fid);',\n    'ind = strfind(str, \\'% End of history. Don\\'\\'t edit this line!\\');',\n    'if isempty(ind), return; end',\n    'ind = ind(1);',\n    'ret = str(ind-1); % new line char: \\\\r or \\\\n',\n    'str = str(max(1, ind-500):ind+2); % go back several lines',\n    'ind = strfind(str, [ret \\'% \\']); % new line with % and space',\n    'for i = 1:numel(ind)-1',\n    '    ln = str(ind(i)+3 : ind(i+1)-1);',\n    '    if length(ln)>5 && all(isstrprop(ln(1:6), \\'digit\\'))',\n    '        dStr = ln(1:6);',\n    '    end ',\n    'end',\n    '',\n    '%% Get position info from Siemens CSA header',\n    '% The only case this is useful for now is for DTI_ColFA, where Siemens omit ',\n    '% ImageOrientationPatient, ImagePositionPatient, PixelSpacing.',\n    '% This shows how to get info from Siemens CSA header.',\n    'function s = csa2pos(s, nSL)',\n    'if ~isfield(s, \\'CSASeriesHeaderInfo\\'); return; end',\n    'if ~isfield(s, \\'PixelSpacing\\')',\n    '    a = asc_header(s, \\'sSliceArray.asSlice[0].dReadoutFOV\\');',\n    '    a = a ./ asc_header(s, \\'sKSpace.lBaseResolution\\');',\n    '    interp = asc_header(s, \\'sKSpace.uc2DInterpolation\\');',\n    '    if interp, a = a ./ 2; end',\n    '    if ~isempty(a), s.PixelSpacing =  a * [1 1]\\'; end',\n    'end',\n    '',\n    'revNum = ~isempty(asc_header(s, \\'sSliceArray.ucImageNumb\\'));',\n    'isMos = ~isempty(csa_header(s, \\'NumberOfImagesInMosaic\\'));',\n    'ori = {\\'Sag\\' \\'Cor\\' \\'Tra\\'}; % 1/2/3',\n    'if ~isfield(s, \\'ImageOrientationPatient\\')',\n    '    R = zeros(3);',\n    '    for i = 1:3',\n    '        a = asc_header(s, [\\'sSliceArray.asSlice[0].sNormal.d\\' ori{i}]);',\n    '        if ~isempty(a), R(i,3) = a; end',\n    '    end',\n    '    ',\n    '    % set SliceNormalVector for mosaic if it is missing',\n    '    if isMos && ~isfield(s.CSAImageHeaderInfo, \\'SliceNormalVector\\')',\n    '        sNormal = R(:,3);',\n    '        if revNum, sNormal = -sNormal; end',\n    '        s.CSAImageHeaderInfo.SliceNormalVector = sNormal;',\n    '    end',\n    '',\n    '    [~, iSL] = max(abs(R(:,3)));',\n    '    if iSL==3',\n    '        R(:,2) = [0 R(3,3) -R(2,3)] / sqrt(sum(R(2:3,3).^2));',\n    '        R(:,1) = cross(R(:,2), R(:,3));',\n    '    elseif iSL==2',\n    '        R(:,1) = [R(2,3) -R(1,3) 0] / sqrt(sum(R(1:2,3).^2));',\n    '        R(:,2) = cross(R(:,3), R(:,1));',\n    '    elseif iSL==1',\n    '        R(:,1) = [-R(2,3) R(1,3) 0] / sqrt(sum(R(1:2,3).^2));',\n    '        R(:,2) = cross(R(:,1), R(:,3));',\n    '    end',\n    '',\n    '    rot = asc_header(s, \\'sSliceArray.asSlice[0].dInPlaneRot\\');',\n    '    if isempty(rot), rot = 0; end',\n    '    rot = rot - round(rot/pi*2)*pi/2; % -45 to 45 deg, is this right?',\n    '    ca = cos(rot); sa = sin(rot);',\n    '    R = R * [ca sa 0; -sa ca 0; 0 0 1];',\n    '    s.ImageOrientationPatient = R(1:6)\\';',\n    'end',\n    '',\n    'if ~isfield(s, \\'ImagePositionPatient\\')',\n    '    pos = zeros(3,2);',\n    '    sl = [0 nSL-1];',\n    '    for j = 1:2',\n    '        key = sprintf(\\'sSliceArray.asSlice[%g].sPosition.d\\', sl(j));',\n    '        for i = 1:3',\n    '            a = asc_header(s, [key ori{i}]);',\n    '            if ~isempty(a), pos(i,j) = a; end',\n    '        end',\n    '    end',\n    '    ',\n    '    R = reshape(s.ImageOrientationPatient, 3, 2);',\n    '    R = R * diag(s.PixelSpacing);',\n    '    dim = double([s.Columns s.Rows]);',\n    '    if all(pos(:,2) == 0) % Mprage, dThickness and sPosition are for volume',\n    '        sNormal = zeros(3,1);',\n    '        for i = 1:3',\n    '            a = asc_header(s, [\\'sSliceArray.asSlice[0].sNormal.d\\' ori{i}]);',\n    '            if ~isempty(a), sNormal(i) = a; end',\n    '        end',\n    '        v3 = asc_header(s, \\'sSliceArray.asSlice[0].dThickness\\');',\n    '        R = [R sNormal*v3/nSL];',\n    '        x = [-dim\\'/2*[1 1]; (1-nSL)/2*[1 -1]];',\n    '        pos = R * x + pos(:,1) * [1 1];',\n    '    else % likely mosaic',\n    '        pos = pos - R * dim\\'/2 * [1 1];',\n    '    end',\n    '    if revNum, pos = pos(:, [2 1]); end',\n    '    if isMos, pos(:,2) = pos(:,1); end % set LastFile same as first for mosaic',\n    '    s.ImagePositionPatient = pos(:,1);',\n    '    s.LastFile.ImagePositionPatient = pos(:,2);',\n    'end',\n    '',\n    '%% subfuction: check whether parpool is available',\n    '% Return true if it is already open, or open it if available',\n    'function doParal = useParTool(toOpen)',\n    'doParal = usejava(\\'jvm\\');',\n    'if ~doParal, return; end',\n    '',\n    'if isempty(which(\\'parpool\\')) % for early matlab versions',\n    '    try ',\n    '        if matlabpool(\\'size\\')<1 %#ok<*DPOOL>',\n    '            try',\n    '                if toOpen, matlabpool; ',\n    '                else doParal = false;',\n    '                end',\n    '            catch me',\n    '                fprintf(2, \\'%s\\\\n\\', me.message);',\n    '                doParal = false;',\n    '            end',\n    '        end',\n    '    catch',\n    '        doParal = false;',\n    '    end',\n    '    return;',\n    'end',\n    '',\n    '% Following for later matlab with parpool',\n    'try ',\n    '    if isempty(gcp(\\'nocreate\\'))',\n    '        try',\n    '            if toOpen, parpool; ',\n    '            else doParal = false;',\n    '            end',\n    '        catch me',\n    '            fprintf(2, \\'%s\\\\n\\', me.message);',\n    '            doParal = false;',\n    '        end',\n    '    end',\n    'catch',\n    '    doParal = false;',\n    'end',\n    '',\n    '%% subfunction: return nii ext from dicom struct',\n    '% The txt extension is in format of: name = parameter;',\n    '% Each parameter ends with [\\';\\' char(0 10)]. Examples:',\n    '% Modality = \\'MR\\'; % str parameter enclosed in single quotation marks',\n    '% FlipAngle = 72; % single numeric value, brackets may be used, but optional',\n    '% SliceTiming = [0.5 0.1 ... ]; % vector parameter enclosed in brackets',\n    '% bvec = [0 -0 0 ',\n    '% -0.25444411 0.52460458 -0.81243353 ',\n    '% ...',\n    '% 0.9836791 0.17571079 0.038744]; % matrix rows separated by char(10) and/or \\';\\'',\n    'function ext = set_nii_ext(s)',\n    'flds = { % fields to put into nifti ext',\n    '  \\'NiftiCreator\\' \\'SeriesNumber\\' \\'SeriesDescription\\' \\'ImageType\\' \\'Modality\\' ...',\n    '  \\'AcquisitionDateTime\\' \\'bval\\' \\'bvec\\' \\'ReadoutSeconds\\' \\'SliceTiming\\' ...',\n    '  \\'UnwarpDirection\\' \\'EffectiveEPIEchoSpacing\\' \\'EchoTime\\' \\'deltaTE\\' ...',\n    '  \\'PatientName\\' \\'PatientSex\\' \\'PatientAge\\' \\'PatientSize\\' \\'PatientWeight\\' ...',\n    '  \\'SliceThickness\\' \\'FlipAngle\\' \\'RBMoCoTrans\\' \\'RBMoCoRot\\' ...',\n    '  \\'Manufacturer\\' \\'SoftwareVersion\\' \\'MRAcquisitionType\\' \\'InstitutionName\\' ...',\n    '  \\'ScanningSequence\\' \\'SequenceVariant\\' \\'ScanOptions\\' \\'SequenceName\\'};',\n    '',\n    'ext.ecode = 6; % text ext',\n    'ext.edata = \\'\\';',\n    'for i = 1:length(flds)',\n    '    val = tryGetField(s, flds{i});',\n    '    if isempty(val)',\n    '        continue;',\n    '    elseif ischar(val)',\n    '        str = sprintf(\\'\\'\\'%s\\'\\'\\', val);',\n    '    elseif numel(val) == 1 % single numeric',\n    '        str = sprintf(\\'%.8g\\', val);',\n    '    elseif isvector(val) % row or column',\n    '        str = sprintf(\\'%.8g \\', val);',\n    '        str = sprintf(\\'[%s]\\', str(1:end-1)); % drop last space',\n    '    else % matrix, like DTI bvec',\n    '        fmt = repmat(\\'%.8g \\', 1, size(val, 2));',\n    '        str = sprintf([fmt char(10)], val\\');',\n    '        str = sprintf(\\'[%s]\\', str(1:end-2)); % drop last space and char(10)',\n    '    end',\n    '    ext.edata = [ext.edata flds{i} \\' = \\' str \\';\\' char([0 10])];',\n    'end',\n    '',\n    '% % Matlab ext: ecode = 40',\n    '% fname = [tempname \\'.mat\\'];',\n    '% save(fname, \\'-struct\\', \\'s\\', \\'-v7\\'); % field as variable',\n    '% fid = fopen(fname);',\n    '% b = fread(fid, inf, \\'*uint8\\'); % data bytes',\n    '% fclose(fid);',\n    '% delete(fname);',\n    '% ',\n    '% % first 4 bytes (int32) encode real data length, endian-dependent',\n    '% if exist(\\'ext\\', \\'var\\'), n = length(ext)+1; else n = 1; end',\n    '% ext(n).edata = [typecast(int32(numel(b)), \\'uint8\\')\\'; b];',\n    '% ext(n).ecode = 40; % Matlab',\n    ' ',\n    '% % Dicom ext: ecode = 2',\n    '% if isfield(s, \\'SOPInstanceUID\\') % make sure it is dicom',\n    '%     if exist(\\'ext\\', \\'var\\'), n = length(ext)+1; else n = 1; end',\n    '%     ext(n).ecode = 2; % dicom',\n    '%     fid = fopen(s.Filename);',\n    '%     ext(n).edata = fread(fid, s.PixelData.Start, \\'*uint8\\');',\n    '%     fclose(fid);',\n    '% end',\n    '',\n    '%% Fix some broken multiband sliceTiming. Hope this won\\'t be needed in future.',\n    '% Odd number of nShot is fine, but some even nShot may have problem.',\n    '% This gives inconsistent result to the following example in PDF doc, but I',\n    '% would rather believe the example is wrong:',\n    '% nSL=20; mb=2; nShot=nSL/mb; % inc=3',\n    '% In PDF: 0,10 - 3,13 - 6,16 - 9,19 - 1,11 - 4,14 - 7,17 - 2,12 - 5,15 - 8,18',\n    '% result: 0,10 - 3,13 - 6,16 - 9,19 - 2,12 - 5,15 - 8,18 - 1,11 - 4,14 - 7,17',\n    'function t = mb_slicetiming(s)',\n    't = s.MosaicRefAcqTimes;',\n    'delay = asc_header(s, \\'lDelayTimeInTR\\')/1000; % in ms now',\n    'if isempty(delay), delay = 0; end',\n    'TA = s.RepetitionTime - delay; % effective TR',\n    '',\n    'if max(t)-min(t)>TA && isfield(s, \\'LastFile\\') % try last volume first',\n    '    dict = dicm_dict(s.Manufacturer, \\'MosaicRefAcqTimes\\');',\n    '    s2 = dicm_hdr(s.LastFile.Filename, dict);',\n    '    t = s2.MosaicRefAcqTimes; % use the last file',\n    'end',\n    '',\n    '% No SL acc factor. Not even multiband flag. This is UGLY',\n    'nSL = double(s.LocationsInAcquisition);',\n    'mb = ceil((max(t) - min(t)) / TA); % based on the wrong timing pattern',\n    'nShot = nSL / mb;',\n    'if mb==1 || mod(nShot,1)>0, return; end % good t, not MB, or wrong acc factor',\n    '',\n    'ucMode = asc_header(s, \\'sSliceArray.ucMode\\'); % 1/2/4: Asc/Desc/Inter',\n    'if isempty(ucMode), return; end',\n    't = linspace(0, TA, nShot+1)\\'; t(end) = [];',\n    't = repmat(t, mb, 1); % ascending',\n    'if ucMode == 2 % descending',\n    '    t = t(nSL:-1:1);',\n    'elseif ucMode == 4 % interleaved',\n    '    if mod(nShot,2) % odd number of shots',\n    '        inc = 2;',\n    '    else',\n    '        inc = nShot / 2 - 1;',\n    '        if mod(inc,2) == 0, inc = inc - 1; end',\n    '        errorLog([ProtocolName(s) \\': multiband interleaved order, even\\' ...',\n    '            \\' number of shots.\\\\nThe SliceTiming information may be wrong.\\']);',\n    '    end',\n    '    ',\n    '% % This gives the result in the PDF doc for example above',\n    '%     ind = nan(nShot, 1); j = 0; i = 1; k = 0;',\n    '%     while 1',\n    '%         ind(i) = j + k*inc;',\n    '%         if ind(i)+(mb-1)*nShot > nSL-1',\n    '%             j = j + 1; k = 0;',\n    '%         else',\n    '%             i = i + 1; k = k + 1;',\n    '%         end',\n    '%         if i>nShot, break; end',\n    '%     end',\n    '    ',\n    '    ind = mod((0:nShot-1)*inc, nShot)\\'; % my guess based on chris data',\n    '    ',\n    '    if nShot==6, ind = [0 2 4 1 5 3]\\'; end % special case',\n    '    ind = bsxfun(@plus, ind*ones(1,mb), (0:mb-1)*nShot);',\n    '    ind = ind + 1;',\n    '',\n    '    t = zeros(nSL, 1);',\n    '    for i = 1:nShot',\n    '        t(ind(i,:)) = (i-1) / nShot;',\n    '    end',\n    '    t = t * TA;',\n    'end',\n    'if csa_header(s, \\'ProtocolSliceNumber\\')>0, t = t(nSL:-1:1); end % rev-num'\n  )\n\n  dicm_dict <- c(\n    'function dict = dicm_dict(vendor, flds)',\n    '% Return dicom dictionary for specified vendor.',\n    '% ',\n    '% dict = dicm_hdr(vendor, dicmFields);',\n    '% ',\n    '% The vendor is used to assign those vendor-specific private tags for SIEMENS,',\n    '% GE and Philips. Other vendors can be added easily into the file.',\n    '% ',\n    '% If only partial dictionary is needed, the struct fields can be used as',\n    '% the 2nd input.',\n    '% ',\n    '% See also DICM_HDR, DICM2NII, DICM_IMG',\n    '',\n    '% History (yymmdd):',\n    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com)',\n    '% 131105 Make DTI parameter names more consistent across vendors.',\n    '% 141021 Store requested fields, so set dict when switching vendors.',\n    '% 141024 Use LocationsInAcquisition as nSL for all vendors.',\n    '% 141030 Make ScanningSequence & SequenceVariant consistent for vendors.',\n    '% 150114 Add two more CSA header duplicate tags, and more command tags.',\n    '',\n    'if nargin<1, vendor = \\'SIEMENS\\'; end',\n    'dict.vendor = vendor;',\n    '% Shortened items common across vendors from Matlab dicom-dict.txt',\n    '%    group element vr  name',\n    'C = {   ',\n    '    \\'0000\\' \\'0002\\' \\'UI\\' \\'AffectedSOPClassUID\\'',\n    '    \\'0000\\' \\'0100\\' \\'US\\' \\'CommandField\\'',\n    '    \\'0000\\' \\'0110\\' \\'US\\' \\'MessageID\\'',\n    '    \\'0000\\' \\'0700\\' \\'US\\' \\'Priority\\'',\n    '    \\'0000\\' \\'0800\\' \\'US\\' \\'DataSetType\\'',\n    '    \\'0000\\' \\'1000\\' \\'UI\\' \\'AffectedSOPInstanceUID\\'',\n    '    \\'0002\\' \\'0001\\' \\'OB\\' \\'FileMetaInformationVersion\\'',\n    '    \\'0002\\' \\'0002\\' \\'UI\\' \\'MediaStorageSOPClassUID\\'',\n    '    \\'0002\\' \\'0003\\' \\'UI\\' \\'MediaStorageSOPInstanceUID\\'',\n    '    \\'0002\\' \\'0010\\' \\'UI\\' \\'TransferSyntaxUID\\'',\n    '    \\'0002\\' \\'0012\\' \\'UI\\' \\'ImplementationClassUID\\'',\n    '    \\'0002\\' \\'0013\\' \\'SH\\' \\'ImplementationVersionName\\'',\n    '    \\'0002\\' \\'0016\\' \\'AE\\' \\'SourceApplicationEntityTitle\\'',\n    '    \\'0002\\' \\'0100\\' \\'UI\\' \\'PrivateInformationCreatorUID\\'',\n    '    \\'0008\\' \\'0005\\' \\'CS\\' \\'SpecificCharacterSet\\'',\n    '    \\'0008\\' \\'0008\\' \\'CS\\' \\'ImageType\\'',\n    '    \\'0008\\' \\'0012\\' \\'DA\\' \\'InstanceCreationDate\\'',\n    '    \\'0008\\' \\'0013\\' \\'TM\\' \\'InstanceCreationTime\\'',\n    '    \\'0008\\' \\'0014\\' \\'UI\\' \\'InstanceCreatorUID\\'',\n    '    \\'0008\\' \\'0016\\' \\'UI\\' \\'SOPClassUID\\'',\n    '    \\'0008\\' \\'0018\\' \\'UI\\' \\'SOPInstanceUID\\'',\n    '    \\'0008\\' \\'0020\\' \\'DA\\' \\'StudyDate\\'',\n    '    \\'0008\\' \\'0021\\' \\'DA\\' \\'SeriesDate\\'',\n    '    \\'0008\\' \\'0022\\' \\'DA\\' \\'AcquisitionDate\\'',\n    '    \\'0008\\' \\'0023\\' \\'DA\\' \\'ContentDate\\'',\n    '    \\'0008\\' \\'002A\\' \\'DT\\' \\'AcquisitionDateTime\\'',\n    '    \\'0008\\' \\'0030\\' \\'TM\\' \\'StudyTime\\'',\n    '    \\'0008\\' \\'0031\\' \\'TM\\' \\'SeriesTime\\'',\n    '    \\'0008\\' \\'0032\\' \\'TM\\' \\'AcquisitionTime\\'',\n    '    \\'0008\\' \\'0033\\' \\'TM\\' \\'ContentTime\\'',\n    '    \\'0008\\' \\'0050\\' \\'SH\\' \\'AccessionNumber\\'',\n    '    \\'0008\\' \\'0060\\' \\'CS\\' \\'Modality\\'',\n    '    \\'0008\\' \\'0064\\' \\'CS\\' \\'ConversionType\\'',\n    '    \\'0008\\' \\'0070\\' \\'LO\\' \\'Manufacturer\\'',\n    '    \\'0008\\' \\'0080\\' \\'LO\\' \\'InstitutionName\\'',\n    '    \\'0008\\' \\'0081\\' \\'ST\\' \\'InstitutionAddress\\'',\n    '    \\'0008\\' \\'0090\\' \\'PN\\' \\'ReferringPhysicianName\\'',\n    '    \\'0008\\' \\'0100\\' \\'SH\\' \\'CodeValue\\'',\n    '    \\'0008\\' \\'0102\\' \\'SH\\' \\'CodingSchemeDesignator\\'',\n    '    \\'0008\\' \\'0104\\' \\'LO\\' \\'CodeMeaning\\'',\n    '    \\'0008\\' \\'010B\\' \\'CS\\' \\'ContextGroupExtensionFlag\\'',\n    '    \\'0008\\' \\'0201\\' \\'SH\\' \\'TimezoneOffsetFromUTC\\'',\n    '    \\'0008\\' \\'1010\\' \\'SH\\' \\'StationName\\'',\n    '    \\'0008\\' \\'1030\\' \\'LO\\' \\'StudyDescription\\'',\n    '    \\'0008\\' \\'1032\\' \\'SQ\\' \\'ProcedureCodeSequence\\'',\n    '    \\'0008\\' \\'103E\\' \\'LO\\' \\'SeriesDescription\\'',\n    '    \\'0008\\' \\'1040\\' \\'LO\\' \\'InstitutionalDepartmentName\\'',\n    '    \\'0008\\' \\'1048\\' \\'PN\\' \\'PhysicianOfRecord\\'',\n    '    \\'0008\\' \\'1050\\' \\'PN\\' \\'PerformingPhysicianName\\'',\n    '    \\'0008\\' \\'1060\\' \\'PN\\' \\'PhysicianReadingStudy\\'',\n    '    \\'0008\\' \\'1070\\' \\'PN\\' \\'OperatorName\\'',\n    '    \\'0008\\' \\'1080\\' \\'LO\\' \\'AdmittingDiagnosesDescription\\'',\n    '    \\'0008\\' \\'1090\\' \\'LO\\' \\'ManufacturerModelName\\'',\n    '    \\'0008\\' \\'1110\\' \\'SQ\\' \\'ReferencedStudySequence\\'',\n    '    \\'0008\\' \\'1111\\' \\'SQ\\' \\'ReferencedPerformedProcedureStepSequence\\'',\n    '    \\'0008\\' \\'1115\\' \\'SQ\\' \\'ReferencedSeriesSequence\\'',\n    '    \\'0008\\' \\'1120\\' \\'SQ\\' \\'ReferencedPatientSequence\\'',\n    '    \\'0008\\' \\'1140\\' \\'SQ\\' \\'ReferencedImageSequence\\'',\n    '    \\'0008\\' \\'1150\\' \\'UI\\' \\'ReferencedSOPClassUID\\'',\n    '    \\'0008\\' \\'1155\\' \\'UI\\' \\'ReferencedSOPInstanceUID\\'',\n    '    \\'0008\\' \\'1160\\' \\'IS\\' \\'ReferencedFrameNumber\\'',\n    '    \\'0008\\' \\'1199\\' \\'SQ\\' \\'ReferencedSOPSequence\\'',\n    '    \\'0008\\' \\'2112\\' \\'SQ\\' \\'SourceImageSequence\\'',\n    '    \\'0008\\' \\'2218\\' \\'SQ\\' \\'AnatomicRegionSequence\\'',\n    '    \\'0008\\' \\'9007\\' \\'CS\\' \\'FrameType\\'',\n    '    \\'0008\\' \\'9092\\' \\'SQ\\' \\'ReferencedImageEvidenceSequence\\'',\n    '    \\'0008\\' \\'9121\\' \\'SQ\\' \\'ReferencedRawDataSequence\\'',\n    '    \\'0008\\' \\'9123\\' \\'UI\\' \\'CreatorVersionUID\\'',\n    '    \\'0008\\' \\'9205\\' \\'CS\\' \\'PixelPresentation\\'',\n    '    \\'0008\\' \\'9206\\' \\'CS\\' \\'VolumetricProperties\\'',\n    '    \\'0008\\' \\'9207\\' \\'CS\\' \\'VolumeBasedCalculationTechnique\\'',\n    '    \\'0008\\' \\'9208\\' \\'CS\\' \\'ComplexImageComponent\\'',\n    '    \\'0008\\' \\'9209\\' \\'CS\\' \\'AcquisitionContrast\\'',\n    '    \\'0010\\' \\'0010\\' \\'PN\\' \\'PatientName\\'',\n    '    \\'0010\\' \\'0020\\' \\'LO\\' \\'PatientID\\'',\n    '    \\'0010\\' \\'0030\\' \\'DA\\' \\'PatientBirthDate\\'',\n    '    \\'0010\\' \\'0040\\' \\'CS\\' \\'PatientSex\\'',\n    '    \\'0010\\' \\'1000\\' \\'LO\\' \\'OtherPatientID\\'',\n    '    \\'0010\\' \\'1010\\' \\'AS\\' \\'PatientAge\\'',\n    '    \\'0010\\' \\'1020\\' \\'DS\\' \\'PatientSize\\'',\n    '    \\'0010\\' \\'1030\\' \\'DS\\' \\'PatientWeight\\'',\n    '    \\'0010\\' \\'1080\\' \\'LO\\' \\'MilitaryRank\\'',\n    '    \\'0010\\' \\'21B0\\' \\'LT\\' \\'AdditionalPatientHistory\\'',\n    '    \\'0010\\' \\'21C0\\' \\'US\\' \\'PregnancyStatus\\'',\n    '    \\'0010\\' \\'4000\\' \\'LT\\' \\'PatientComments\\'',\n    '    \\'0012\\' \\'0062\\' \\'CS\\' \\'PatientIdentityRemoved\\'',\n    '    \\'0012\\' \\'0063\\' \\'LO\\' \\'DeidentificationMethod\\'',\n    '    \\'0018\\' \\'0015\\' \\'CS\\' \\'BodyPartExamined\\'',\n    '    \\'0018\\' \\'0020\\' \\'CS\\' \\'ScanningSequence\\'',\n    '    \\'0018\\' \\'0021\\' \\'CS\\' \\'SequenceVariant\\'',\n    '    \\'0018\\' \\'0022\\' \\'CS\\' \\'ScanOptions\\'',\n    '    \\'0018\\' \\'0023\\' \\'CS\\' \\'MRAcquisitionType\\'',\n    '    \\'0018\\' \\'0024\\' \\'SH\\' \\'SequenceName\\'',\n    '    \\'0018\\' \\'0025\\' \\'CS\\' \\'AngioFlag\\'',\n    '    \\'0018\\' \\'0050\\' \\'DS\\' \\'SliceThickness\\'',\n    '    \\'0018\\' \\'0060\\' \\'DS\\' \\'KVP\\'',\n    '    \\'0018\\' \\'0080\\' \\'DS\\' \\'RepetitionTime\\'',\n    '    \\'0018\\' \\'0081\\' \\'DS\\' \\'EchoTime\\'',\n    '    \\'0018\\' \\'0082\\' \\'DS\\' \\'InversionTime\\'',\n    '    \\'0018\\' \\'0083\\' \\'DS\\' \\'NumberOfAverages\\'',\n    '    \\'0018\\' \\'0084\\' \\'DS\\' \\'ImagingFrequency\\'',\n    '    \\'0018\\' \\'0085\\' \\'SH\\' \\'ImagedNucleus\\'',\n    '    \\'0018\\' \\'0086\\' \\'IS\\' \\'EchoNumber\\'',\n    '    \\'0018\\' \\'0087\\' \\'DS\\' \\'MagneticFieldStrength\\'',\n    '    \\'0018\\' \\'0088\\' \\'DS\\' \\'SpacingBetweenSlices\\'',\n    '    \\'0018\\' \\'0089\\' \\'IS\\' \\'NumberOfPhaseEncodingSteps\\'',\n    '    \\'0018\\' \\'0090\\' \\'DS\\' \\'DataCollectionDiameter\\'',\n    '    \\'0018\\' \\'0091\\' \\'IS\\' \\'EchoTrainLength\\'',\n    '    \\'0018\\' \\'0093\\' \\'DS\\' \\'PercentSampling\\'',\n    '    \\'0018\\' \\'0094\\' \\'DS\\' \\'PercentPhaseFieldOfView\\'',\n    '    \\'0018\\' \\'0095\\' \\'DS\\' \\'PixelBandwidth\\'',\n    '    \\'0018\\' \\'1000\\' \\'LO\\' \\'DeviceSerialNumber\\'',\n    '    \\'0018\\' \\'1012\\' \\'DA\\' \\'DateOfSecondaryCapture\\'',\n    '    \\'0018\\' \\'1014\\' \\'TM\\' \\'TimeOfSecondaryCapture\\'',\n    '    \\'0018\\' \\'1020\\' \\'LO\\' \\'SoftwareVersion\\'',\n    '    \\'0018\\' \\'1030\\' \\'LO\\' \\'ProtocolName\\'',\n    '    \\'0018\\' \\'1050\\' \\'DS\\' \\'SpatialResolution\\'',\n    '    \\'0018\\' \\'1060\\' \\'DS\\' \\'TriggerTime\\'',\n    '    \\'0018\\' \\'1063\\' \\'DS\\' \\'FrameTime\\'',\n    '    \\'0018\\' \\'1088\\' \\'IS\\' \\'HeartRate\\'',\n    '    \\'0018\\' \\'1090\\' \\'IS\\' \\'CardiacNumberOfImages\\'',\n    '    \\'0018\\' \\'1094\\' \\'IS\\' \\'TriggerWindow\\'',\n    '    \\'0018\\' \\'1100\\' \\'DS\\' \\'ReconstructionDiameter\\'',\n    '    \\'0018\\' \\'1110\\' \\'DS\\' \\'DistanceSourceToDetector\\'',\n    '    \\'0018\\' \\'1111\\' \\'DS\\' \\'DistanceSourceToPatient\\'',\n    '    \\'0018\\' \\'1120\\' \\'DS\\' \\'GantryDetectorTilt\\'',\n    '    \\'0018\\' \\'1130\\' \\'DS\\' \\'TableHeight\\'',\n    '    \\'0018\\' \\'1140\\' \\'CS\\' \\'RotationDirection\\'',\n    '    \\'0018\\' \\'1150\\' \\'IS\\' \\'ExposureTime\\'',\n    '    \\'0018\\' \\'1151\\' \\'IS\\' \\'XrayTubeCurrent\\'',\n    '    \\'0018\\' \\'1152\\' \\'IS\\' \\'Exposure\\'',\n    '    \\'0018\\' \\'1160\\' \\'SH\\' \\'FilterType\\'',\n    '    \\'0018\\' \\'1170\\' \\'IS\\' \\'GeneratorPower\\'',\n    '    \\'0018\\' \\'1190\\' \\'DS\\' \\'FocalSpot\\'',\n    '    \\'0018\\' \\'1210\\' \\'SH\\' \\'ConvolutionKernel\\'',\n    '    \\'0018\\' \\'1200\\' \\'DA\\' \\'DateOfLastCalibration\\'',\n    '    \\'0018\\' \\'1201\\' \\'TM\\' \\'TimeOfLastCalibration\\'',\n    '    \\'0018\\' \\'1250\\' \\'SH\\' \\'ReceiveCoilName\\'',\n    '    \\'0018\\' \\'1251\\' \\'SH\\' \\'TransmitCoilName\\'   ',\n    '    \\'0018\\' \\'1310\\' \\'US\\' \\'AcquisitionMatrix\\'',\n    '    \\'0018\\' \\'1312\\' \\'CS\\' \\'InPlanePhaseEncodingDirection\\'',\n    '    \\'0018\\' \\'1314\\' \\'DS\\' \\'FlipAngle\\'',\n    '    \\'0018\\' \\'1315\\' \\'CS\\' \\'VariableFlipAngleFlag\\'',\n    '    \\'0018\\' \\'1316\\' \\'DS\\' \\'SAR\\'',\n    '    \\'0018\\' \\'1318\\' \\'DS\\' \\'dBdt\\'',\n    '    \\'0018\\' \\'1081\\' \\'IS\\' \\'LowRRValue\\'',\n    '    \\'0018\\' \\'1082\\' \\'IS\\' \\'HighRRValue\\'',\n    '    \\'0018\\' \\'1083\\' \\'IS\\' \\'IntervalsAcquired\\'',\n    '    \\'0018\\' \\'1084\\' \\'IS\\' \\'IntervalsRejected\\'',\n    '    \\'0018\\' \\'2003\\' \\'DS\\' \\'FramePrimaryAngleVector\\'',\n    '    \\'0018\\' \\'2004\\' \\'DS\\' \\'FrameSecondaryAngleVector\\'',\n    '    \\'0018\\' \\'2005\\' \\'DS\\' \\'SliceLocationVector\\'',\n    '    \\'0018\\' \\'5100\\' \\'CS\\' \\'PatientPosition\\'',\n    '    \\'0018\\' \\'9004\\' \\'CS\\' \\'ContentQualification\\'',\n    '    \\'0018\\' \\'9005\\' \\'SH\\' \\'PulseSequenceName\\'',\n    '    \\'0018\\' \\'9006\\' \\'SQ\\' \\'MRImagingModifierSequence\\'',\n    '    \\'0018\\' \\'9008\\' \\'CS\\' \\'EchoPulseSequence\\'',\n    '    \\'0018\\' \\'9009\\' \\'CS\\' \\'InversionRecovery\\'',\n    '    \\'0018\\' \\'9010\\' \\'CS\\' \\'FlowCompensation\\'',\n    '    \\'0018\\' \\'9011\\' \\'CS\\' \\'MultipleSpinEcho\\'',\n    '    \\'0018\\' \\'9012\\' \\'CS\\' \\'MultiplanarExcitation\\'',\n    '    \\'0018\\' \\'9014\\' \\'CS\\' \\'PhaseContrast\\'',\n    '    \\'0018\\' \\'9015\\' \\'CS\\' \\'TimeOfFlightContrast\\'',\n    '    \\'0018\\' \\'9016\\' \\'CS\\' \\'Spoiling\\'',\n    '    \\'0018\\' \\'9017\\' \\'CS\\' \\'SteadyStatePulseSequence\\'',\n    '    \\'0018\\' \\'9018\\' \\'CS\\' \\'EchoPlanarPulseSequence\\'',\n    '    \\'0018\\' \\'9019\\' \\'FD\\' \\'TagAngleFirstAxis\\'',\n    '    \\'0018\\' \\'9020\\' \\'CS\\' \\'MagnetizationTransfer\\'',\n    '    \\'0018\\' \\'9021\\' \\'CS\\' \\'T2Preparation\\'',\n    '    \\'0018\\' \\'9022\\' \\'CS\\' \\'BloodSignalNulling\\'',\n    '    \\'0018\\' \\'9024\\' \\'CS\\' \\'SaturationRecovery\\'',\n    '    \\'0018\\' \\'9025\\' \\'CS\\' \\'SpectrallySelectedSuppression\\'',\n    '    \\'0018\\' \\'9026\\' \\'CS\\' \\'SpectrallySelectedExcitation\\'',\n    '    \\'0018\\' \\'9027\\' \\'CS\\' \\'SpatialPresaturation\\'',\n    '    \\'0018\\' \\'9028\\' \\'CS\\' \\'Tagging\\'',\n    '    \\'0018\\' \\'9029\\' \\'CS\\' \\'OversamplingPhase\\'',\n    '    \\'0018\\' \\'9030\\' \\'FD\\' \\'TagSpacingFirstDimension\\'',\n    '    \\'0018\\' \\'9032\\' \\'CS\\' \\'GeometryOfKSpaceTraversal\\'',\n    '    \\'0018\\' \\'9033\\' \\'CS\\' \\'SegmentedKSpaceTraversal\\'',\n    '    \\'0018\\' \\'9034\\' \\'CS\\' \\'RectilinearPhaseEncodeReordering\\'',\n    '    \\'0018\\' \\'9035\\' \\'FD\\' \\'TagThickness\\'',\n    '    \\'0018\\' \\'9036\\' \\'CS\\' \\'PartialFourierDirection\\'',\n    '    \\'0018\\' \\'9037\\' \\'CS\\' \\'CardiacSynchronizationTechnique\\'',\n    '    \\'0018\\' \\'9042\\' \\'SQ\\' \\'MRReceiveCoilSequence\\'',\n    '    \\'0018\\' \\'9043\\' \\'CS\\' \\'ReceiveCoilType\\'',\n    '    \\'0018\\' \\'9044\\' \\'CS\\' \\'QuadratureReceiveCoil\\'',\n    '    \\'0018\\' \\'9045\\' \\'SQ\\' \\'MultiCoilDefinitionSequence\\'',\n    '    \\'0018\\' \\'9047\\' \\'SH\\' \\'MultiCoilElementName\\'',\n    '    \\'0018\\' \\'9048\\' \\'CS\\' \\'MultiCoilElementUsed\\'',\n    '    \\'0018\\' \\'9049\\' \\'SQ\\' \\'MRTransmitCoilSequence\\'',\n    '    \\'0018\\' \\'9051\\' \\'CS\\' \\'TransmitCoilType\\'',\n    '    \\'0018\\' \\'9052\\' \\'FD\\' \\'SpectralWidth\\'',\n    '    \\'0018\\' \\'9053\\' \\'FD\\' \\'ChemicalShiftReference\\'',\n    '    \\'0018\\' \\'9058\\' \\'US\\' \\'MRAcquisitionFrequencyEncodingSteps\\'',\n    '    \\'0018\\' \\'9059\\' \\'CS\\' \\'Decoupling\\'',\n    '    \\'0018\\' \\'9064\\' \\'CS\\' \\'KSpaceFiltering\\'',\n    '    \\'0018\\' \\'9069\\' \\'FD\\' \\'ParallelReductionFactorInPlane\\'',\n    '    \\'0018\\' \\'9073\\' \\'FD\\' \\'AcquisitionDuration\\'',\n    '    \\'0018\\' \\'9074\\' \\'DT\\' \\'FrameAcquisitionDatetime\\'',\n    '    \\'0018\\' \\'9075\\' \\'CS\\' \\'DiffusionDirectionality\\'',\n    '    \\'0018\\' \\'9076\\' \\'SQ\\' \\'DiffusionGradientDirectionSequence\\'',\n    '    \\'0018\\' \\'9077\\' \\'CS\\' \\'ParallelAcquisition\\'',\n    '    \\'0018\\' \\'9078\\' \\'CS\\' \\'ParallelAcquisitionTechnique\\'',\n    '    \\'0018\\' \\'9079\\' \\'FD\\' \\'InversionTimes\\'',\n    '    \\'0018\\' \\'9080\\' \\'ST\\' \\'MetaboliteMapDescription\\'',\n    '    \\'0018\\' \\'9081\\' \\'CS\\' \\'PartialFourier\\'',\n    '    \\'0018\\' \\'9082\\' \\'FD\\' \\'EffectiveEchoTime\\'',\n    '    \\'0018\\' \\'9087\\' \\'FD\\' \\'B_value\\' % \\'DiffusionBValue\\'',\n    '    \\'0018\\' \\'9089\\' \\'FD\\' \\'DiffusionGradientDirection\\' % DiffusionGradientOrientation',\n    '    \\'0018\\' \\'9090\\' \\'FD\\' \\'VelocityEncodingDirection\\'',\n    '    \\'0018\\' \\'9091\\' \\'FD\\' \\'VelocityEncodingMinimumValue\\'',\n    '    \\'0018\\' \\'9093\\' \\'US\\' \\'NumberOfKSpaceTrajectories\\'',\n    '    \\'0018\\' \\'9094\\' \\'CS\\' \\'CoverageOfKSpace\\'',\n    '    \\'0018\\' \\'9098\\' \\'FD\\' \\'TransmitterFrequency\\'',\n    '    \\'0018\\' \\'9100\\' \\'CS\\' \\'ResonantNucleus\\'',\n    '    \\'0018\\' \\'9101\\' \\'CS\\' \\'FrequencyCorrection\\'',\n    '    \\'0018\\' \\'9103\\' \\'SQ\\' \\'MRSpectroscopyFOVGeometrySequence\\'',\n    '    \\'0018\\' \\'9112\\' \\'SQ\\' \\'MRTimingAndRelatedParametersSequence\\'',\n    '    \\'0018\\' \\'9114\\' \\'SQ\\' \\'MREchoSequence\\'',\n    '    \\'0018\\' \\'9115\\' \\'SQ\\' \\'MRModifierSequence\\'',\n    '    \\'0018\\' \\'9117\\' \\'SQ\\' \\'MRDiffusionSequence\\'',\n    '    \\'0018\\' \\'9119\\' \\'SQ\\' \\'MRAveragesSequence\\'',\n    '    \\'0018\\' \\'9125\\' \\'SQ\\' \\'MRFOVGeometrySequence\\'',\n    '    \\'0018\\' \\'9147\\' \\'CS\\' \\'DiffusionAnisotropyType\\'',\n    '    \\'0018\\' \\'9151\\' \\'DT\\' \\'FrameReferenceDatetime\\'',\n    '    \\'0018\\' \\'9152\\' \\'SQ\\' \\'MRMetaboliteMapSequence\\'',\n    '    \\'0018\\' \\'9155\\' \\'FD\\' \\'ParallelReductionFactorOutOfPlane\\'',\n    '    \\'0018\\' \\'9168\\' \\'FD\\' \\'ParallelReductionFactorSecondInPlane\\'',\n    '    \\'0018\\' \\'9170\\' \\'CS\\' \\'RespiratoryMotionCompensationTechnique\\'',\n    '    \\'0018\\' \\'9171\\' \\'CS\\' \\'RespiratorySignalSource\\'',\n    '    \\'0018\\' \\'9172\\' \\'CS\\' \\'BulkMotionCompensationTechnique\\'',\n    '    \\'0018\\' \\'9174\\' \\'CS\\' \\'ApplicableSafetyStandardAgency\\'',\n    '    \\'0018\\' \\'9176\\' \\'SQ\\' \\'OperatingModeSequence\\'',\n    '    \\'0018\\' \\'9177\\' \\'CS\\' \\'OperatingModeType\\'',\n    '    \\'0018\\' \\'9178\\' \\'CS\\' \\'OperatingMode\\'',\n    '    \\'0018\\' \\'9179\\' \\'CS\\' \\'SpecificAbsorptionRateDefinition\\'',\n    '    \\'0018\\' \\'9180\\' \\'CS\\' \\'GradientOutputType\\'',\n    '    \\'0018\\' \\'9181\\' \\'FD\\' \\'SpecificAbsorptionRateValue\\'',\n    '    \\'0018\\' \\'9182\\' \\'FD\\' \\'GradientOutput\\'',\n    '    \\'0018\\' \\'9183\\' \\'CS\\' \\'FlowCompensationDirection\\'',\n    '    \\'0018\\' \\'9199\\' \\'CS\\' \\'WaterReferencedPhaseCorrection\\'',\n    '    \\'0018\\' \\'9220\\' \\'FD\\' \\'FrameAcquisitionDuration\\'',\n    '    \\'0018\\' \\'9226\\' \\'SQ\\' \\'MRImageFrameTypeSequence\\'',\n    '    \\'0018\\' \\'9231\\' \\'US\\' \\'MRAcquisitionPhaseEncodingStepsInPlane\\'',\n    '    \\'0018\\' \\'9232\\' \\'US\\' \\'MRAcquisitionPhaseEncodingStepsOutOfPlane\\'',\n    '    \\'0018\\' \\'9239\\' \\'SQ\\' \\'SpecificAbsorptionRateSequence\\'',\n    '    \\'0018\\' \\'9240\\' \\'US\\' \\'RFEchoTrainLength\\'',\n    '    \\'0018\\' \\'9241\\' \\'US\\' \\'GradientEchoTrainLength\\'',\n    '    \\'0020\\' \\'000D\\' \\'UI\\' \\'StudyInstanceUID\\'',\n    '    \\'0020\\' \\'000E\\' \\'UI\\' \\'SeriesInstanceUID\\'',\n    '    \\'0020\\' \\'0010\\' \\'SH\\' \\'StudyID\\'',\n    '    \\'0020\\' \\'0011\\' \\'IS\\' \\'SeriesNumber\\'',\n    '    \\'0020\\' \\'0012\\' \\'IS\\' \\'AcquisitionNumber\\'',\n    '    \\'0020\\' \\'0013\\' \\'IS\\' \\'InstanceNumber\\'',\n    '    \\'0020\\' \\'0020\\' \\'CS\\' \\'PatientOrientation\\'',\n    '    \\'0020\\' \\'0032\\' \\'DS\\' \\'ImagePositionPatient\\'',\n    '    \\'0020\\' \\'0037\\' \\'DS\\' \\'ImageOrientationPatient\\'',\n    '    \\'0020\\' \\'0052\\' \\'UI\\' \\'FrameOfReferenceUID\\'',\n    '    \\'0020\\' \\'0100\\' \\'IS\\' \\'TemporalPositionIdentifier\\'',\n    '    \\'0020\\' \\'0110\\' \\'DS\\' \\'TemporalResolution\\'',\n    '    \\'0020\\' \\'0105\\' \\'IS\\' \\'NumberOfTemporalPositions\\'',\n    '    \\'0020\\' \\'1000\\' \\'IS\\' \\'SeriesInStudy\\'',\n    '    \\'0020\\' \\'1001\\' \\'IS\\' \\'AcquisitionsInSeries\\'',\n    '    \\'0020\\' \\'1002\\' \\'IS\\' \\'ImagesInAcquisition\\'',\n    '    \\'0020\\' \\'1003\\' \\'IS\\' \\'ImagesInSeries\\'',\n    '    \\'0020\\' \\'1004\\' \\'IS\\' \\'AcquisitionsInStudy\\'',\n    '    \\'0020\\' \\'1005\\' \\'IS\\' \\'ImagesInStudy\\'',\n    '    \\'0020\\' \\'1040\\' \\'LO\\' \\'PositionReferenceIndicator\\'',\n    '    \\'0020\\' \\'1041\\' \\'DS\\' \\'SliceLocation\\'',\n    '    \\'0020\\' \\'4000\\' \\'LT\\' \\'ImageComments\\'',\n    '    \\'0020\\' \\'9056\\' \\'SH\\' \\'StackID\\'',\n    '    \\'0020\\' \\'9057\\' \\'UL\\' \\'InStackPositionNumber\\'',\n    '    \\'0020\\' \\'9071\\' \\'SQ\\' \\'FrameAnatomySequence\\'',\n    '    \\'0020\\' \\'9072\\' \\'CS\\' \\'FrameLaterality\\'',\n    '    \\'0020\\' \\'9111\\' \\'SQ\\' \\'FrameContentSequence\\'',\n    '    \\'0020\\' \\'9113\\' \\'SQ\\' \\'PlanePositionSequence\\'',\n    '    \\'0020\\' \\'9116\\' \\'SQ\\' \\'PlaneOrientationSequence\\'',\n    '    \\'0020\\' \\'9128\\' \\'UL\\' \\'TemporalPositionIndex\\'',\n    '    \\'0020\\' \\'9156\\' \\'US\\' \\'FrameAcquisitionNumber\\'',\n    '    \\'0020\\' \\'9157\\' \\'UL\\' \\'DimensionIndexValues\\'',\n    '    \\'0020\\' \\'9164\\' \\'UI\\' \\'DimensionOrganizationUID\\'',\n    '    \\'0020\\' \\'9165\\' \\'AT\\' \\'DimensionIndexPointer\\'',\n    '    \\'0020\\' \\'9167\\' \\'AT\\' \\'FunctionalGroupPointer\\'',\n    '    \\'0020\\' \\'9221\\' \\'SQ\\' \\'DimensionOrganizationSequence\\'',\n    '    \\'0020\\' \\'9222\\' \\'SQ\\' \\'DimensionIndexSequence\\'',\n    '    \\'0020\\' \\'9254\\' \\'FD\\' \\'RespiratoryIntervalTime\\'',\n    '    \\'0020\\' \\'9255\\' \\'FD\\' \\'RespiratoryTriggerDelayTime\\'',\n    '    \\'0020\\' \\'9421\\' \\'LO\\' \\'DimensionDescriptionLabel\\'',\n    '    \\'0028\\' \\'0002\\' \\'US\\' \\'SamplesPerPixel\\'',\n    '    \\'0028\\' \\'0004\\' \\'CS\\' \\'PhotometricInterpretation\\'',\n    '    \\'0028\\' \\'0006\\' \\'US\\' \\'PlanarConfiguration\\'',\n    '    \\'0028\\' \\'0008\\' \\'IS\\' \\'NumberOfFrames\\'',\n    '    \\'0028\\' \\'0009\\' \\'AT\\' \\'FrameIncrementPointer\\'',\n    '    \\'0028\\' \\'000A\\' \\'AT\\' \\'FrameDimensionPointer\\'',\n    '    \\'0028\\' \\'0010\\' \\'US\\' \\'Rows\\'',\n    '    \\'0028\\' \\'0011\\' \\'US\\' \\'Columns\\'',\n    '    \\'0028\\' \\'0030\\' \\'DS\\' \\'PixelSpacing\\'',\n    '    \\'0028\\' \\'0034\\' \\'IS\\' \\'PixelAspectRatio\\'',\n    '    \\'0028\\' \\'0100\\' \\'US\\' \\'BitsAllocated\\'',\n    '    \\'0028\\' \\'0101\\' \\'US\\' \\'BitsStored\\'',\n    '    \\'0028\\' \\'0102\\' \\'US\\' \\'HighBit\\'',\n    '    \\'0028\\' \\'0103\\' \\'US\\' \\'PixelRepresentation\\'',\n    '    \\'0028\\' \\'0104\\' \\'US\\' \\'SmallestValidPixelValue\\'',\n    '    \\'0028\\' \\'0105\\' \\'US\\' \\'LargestValidPixelValue\\'',\n    '    \\'0028\\' \\'0106\\' \\'US\\' \\'SmallestImagePixelValue\\'',\n    '    \\'0028\\' \\'0107\\' \\'US\\' \\'LargestImagePixelValue\\'',\n    '    \\'0028\\' \\'0120\\' \\'SS\\' \\'PixelPaddingValue\\'',\n    '    \\'0028\\' \\'0301\\' \\'CS\\' \\'BurnedInAnnotation\\'',\n    '    \\'0028\\' \\'1050\\' \\'DS\\' \\'WindowCenter\\'',\n    '    \\'0028\\' \\'1051\\' \\'DS\\' \\'WindowWidth\\'',\n    '    \\'0028\\' \\'1052\\' \\'DS\\' \\'RescaleIntercept\\'',\n    '    \\'0028\\' \\'1053\\' \\'DS\\' \\'RescaleSlope\\'',\n    '    \\'0028\\' \\'1054\\' \\'LO\\' \\'RescaleType\\'',\n    '    \\'0028\\' \\'1055\\' \\'LO\\' \\'WindowCenterWidthExplanation\\'',\n    '    \\'0028\\' \\'1080\\' \\'LT\\' \\'GrayScale\\'',\n    '    \\'0028\\' \\'1101\\' \\'US\\' \\'RedPaletteColorLookupTableDescriptor\\'',\n    '    \\'0028\\' \\'1102\\' \\'US\\' \\'GreenPaletteColorLookupTableDescriptor\\'',\n    '    \\'0028\\' \\'1103\\' \\'US\\' \\'BluePaletteColorLookupTableDescriptor\\'',\n    '    \\'0028\\' \\'1201\\' \\'OW\\' \\'RedPaletteColorLookupTableData\\'',\n    '    \\'0028\\' \\'1202\\' \\'OW\\' \\'GreenPaletteColorLookupTableData\\'',\n    '    \\'0028\\' \\'1203\\' \\'OW\\' \\'BluePaletteColorLookupTableData\\'',\n    '    \\'0028\\' \\'2110\\' \\'CS\\' \\'LossyImageCompression\\'',\n    '    \\'0028\\' \\'2112\\' \\'DS\\' \\'LossyImageCompressionRatio\\'',\n    '    \\'0028\\' \\'2114\\' \\'CS\\' \\'LossyImageCompressionMethod\\'',\n    '    \\'0028\\' \\'3003\\' \\'LO\\' \\'LUTExplanation\\'',\n    '    \\'0028\\' \\'9001\\' \\'UL\\' \\'DataPointRows\\'',\n    '    \\'0028\\' \\'9002\\' \\'UL\\' \\'DataPointColumns\\'',\n    '    \\'0028\\' \\'9110\\' \\'SQ\\' \\'PixelMeasuresSequence\\'',\n    '    \\'0028\\' \\'9132\\' \\'SQ\\' \\'FrameVOILUTSequence\\'',\n    '    \\'0028\\' \\'9145\\' \\'SQ\\' \\'PixelValueTransformationSequence\\'',\n    '    \\'0032\\' \\'000A\\' \\'CS\\' \\'StudyStatusID\\'',\n    '    \\'0032\\' \\'000C\\' \\'CS\\' \\'StudyPriorityID\\'',\n    '    \\'0032\\' \\'1030\\' \\'LO\\' \\'ReasonForStudy\\'',\n    '    \\'0032\\' \\'1032\\' \\'PN\\' \\'RequestingPhysician\\'',\n    '    \\'0032\\' \\'1033\\' \\'LO\\' \\'RequestingService\\'',\n    '    \\'0032\\' \\'1060\\' \\'LO\\' \\'RequestedProcedureDescription\\'',\n    '    \\'0032\\' \\'1064\\' \\'SQ\\' \\'RequestedProcedureCodeSequence\\'',\n    '    \\'0032\\' \\'4000\\' \\'LT\\' \\'StudyComments\\'',\n    '    \\'0038\\' \\'0300\\' \\'LO\\' \\'CurrentPatientLocation\\'',\n    '    \\'0040\\' \\'0006\\' \\'PN\\' \\'ScheduledPerformingPhysicianName\\'',\n    '    \\'0040\\' \\'0007\\' \\'LO\\' \\'ScheduledProcedureStepDescription\\'',\n    '    \\'0040\\' \\'0008\\' \\'SQ\\' \\'ScheduledProtocolCodeSequence\\'',\n    '    \\'0040\\' \\'0009\\' \\'SH\\' \\'ScheduledProcedureStepID\\'',\n    '    \\'0040\\' \\'0241\\' \\'AE\\' \\'PerformedStationAETitle\\'',\n    '    \\'0040\\' \\'0242\\' \\'SH\\' \\'PerformedStationName\\'',\n    '    \\'0040\\' \\'0243\\' \\'SH\\' \\'PerformedLocation\\'',\n    '    \\'0040\\' \\'0244\\' \\'DA\\' \\'PerformedProcedureStepStartDate\\'',\n    '    \\'0040\\' \\'0245\\' \\'TM\\' \\'PerformedProcedureStepStartTime\\'',\n    '    \\'0040\\' \\'0250\\' \\'DA\\' \\'PerformedProcedureStepEndDate\\'',\n    '    \\'0040\\' \\'0251\\' \\'TM\\' \\'PerformedProcedureStepEndTime\\'',\n    '    \\'0040\\' \\'0252\\' \\'CS\\' \\'PerformedProcedureStepStatus\\'',\n    '    \\'0040\\' \\'0253\\' \\'SH\\' \\'PerformedProcedureStepID\\'',\n    '    \\'0040\\' \\'0254\\' \\'LO\\' \\'PerformedProcedureStepDescription\\'',\n    '    \\'0040\\' \\'0260\\' \\'SQ\\' \\'PerformedProtocolCodeSequence\\'',\n    '    \\'0040\\' \\'0275\\' \\'SQ\\' \\'RequestAttributesSequence\\'',\n    '    \\'0040\\' \\'0280\\' \\'ST\\' \\'CommentsOnPerformedProcedureStep\\'',\n    '    \\'0040\\' \\'0321\\' \\'SQ\\' \\'FilmConsumptionSequence\\'',\n    '    \\'0040\\' \\'08EA\\' \\'SQ\\' \\'MeasurementUnitsCodeSequence\\'',\n    '    \\'0040\\' \\'1001\\' \\'SH\\' \\'RequestedProcedureID\\'',\n    '    \\'0040\\' \\'1400\\' \\'LT\\' \\'RequestedProcedureComments\\'',\n    '    \\'0040\\' \\'2400\\' \\'LT\\' \\'ImagingServiceRequestComments\\'',\n    '    \\'0040\\' \\'9096\\' \\'SQ\\' \\'RealWorldValueMappingSequence\\'',\n    '    \\'0040\\' \\'9210\\' \\'SH\\' \\'LUTLabel\\'',\n    '    \\'0040\\' \\'9211\\' \\'SS\\' \\'RealWorldValueLastValueMapped\\'',\n    '    \\'0040\\' \\'9216\\' \\'SS\\' \\'RealWorldValueFirstValueMapped\\'',\n    '    \\'0040\\' \\'9224\\' \\'FD\\' \\'RealWorldValueIntercept\\'',\n    '    \\'0040\\' \\'9225\\' \\'FD\\' \\'RealWorldValueSlope\\'',\n    '    \\'0040\\' \\'A170\\' \\'SQ\\' \\'PurposeOfReferenceCodeSequence\\'',\n    '    \\'0050\\' \\'0004\\' \\'CS\\' \\'CalibrationImage\\'',\n    '    \\'0050\\' \\'0010\\' \\'SQ\\' \\'DeviceSequence\\'',\n    '    \\'0050\\' \\'0014\\' \\'DS\\' \\'DeviceLength\\'',\n    '    \\'0050\\' \\'0016\\' \\'DS\\' \\'DeviceDiameter\\'',\n    '    \\'0050\\' \\'0017\\' \\'CS\\' \\'DeviceDiameterUnits\\'',\n    '    \\'0050\\' \\'0018\\' \\'DS\\' \\'DeviceVolume\\'',\n    '    \\'0050\\' \\'0019\\' \\'DS\\' \\'InterMarkerDistance\\'',\n    '    \\'0050\\' \\'0020\\' \\'LO\\' \\'DeviceDescription\\'',\n    '    \\'0088\\' \\'0140\\' \\'UI\\' \\'StorageMediaFileSetUID\\'',\n    '    \\'0088\\' \\'0200\\' \\'SQ\\' \\'IconImageSequence\\'',\n    '    \\'5200\\' \\'9229\\' \\'SQ\\' \\'SharedFunctionalGroupsSequence\\'',\n    '    \\'5200\\' \\'9230\\' \\'SQ\\' \\'PerFrameFunctionalGroupsSequence\\'',\n    '    \\'7FE0\\' \\'0010\\' \\'OW\\' \\'PixelData\\' };',\n    '',\n    '% Following add vendor specific tags',\n    'if strncmpi(vendor, \\'SIEMENS\\', 7)',\n    '    C = [C; {',\n    '    \\'0019\\' \\'1008\\' \\'CS\\' \\'Private_0019_10xxType\\'',\n    '    \\'0019\\' \\'1009\\' \\'LO\\' \\'Private_0019_10xxVersion\\'',\n    '    \\'0019\\' \\'100A\\' \\'US\\' \\'LocationsInAcquisition\\' % \\'NumberOfImagesInMosaic\\'',\n    '    \\'0019\\' \\'100B\\' \\'DS\\' \\'SliceMeasurementDuration\\'',\n    '    \\'0019\\' \\'100C\\' \\'IS\\' \\'B_value\\'',\n    '    \\'0019\\' \\'100D\\' \\'CS\\' \\'DiffusionDirectionality\\'',\n    '    \\'0019\\' \\'100E\\' \\'FD\\' \\'DiffusionGradientDirection\\'',\n    '    \\'0019\\' \\'100F\\' \\'SH\\' \\'GradientMode\\'',\n    '    \\'0019\\' \\'1011\\' \\'SH\\' \\'FlowCompensation\\'',\n    '    \\'0019\\' \\'1012\\' \\'SL\\' \\'TablePositionOrigin\\'',\n    '    \\'0019\\' \\'1013\\' \\'SL\\' \\'ImaAbsTablePosition\\'',\n    '    \\'0019\\' \\'1014\\' \\'IS\\' \\'ImaRelTablePosition\\'',\n    '    \\'0019\\' \\'1015\\' \\'FD\\' \\'SlicePosition_PCS\\'',\n    '    \\'0019\\' \\'1016\\' \\'DS\\' \\'TimeAfterStart\\'',\n    '    \\'0019\\' \\'1017\\' \\'DS\\' \\'SliceResolution\\'',\n    '    \\'0019\\' \\'1018\\' \\'IS\\' \\'RealDwellTime\\'',\n    '    \\'0019\\' \\'1025\\' \\'DS\\' \\'RBMoCoTrans\\'',\n    '    \\'0019\\' \\'1026\\' \\'DS\\' \\'RBMoCoRot\\'',\n    '    \\'0019\\' \\'1027\\' \\'FD\\' \\'B_matrix\\'',\n    '    \\'0019\\' \\'1028\\' \\'FD\\' \\'BandwidthPerPixelPhaseEncode\\'',\n    '    \\'0019\\' \\'1029\\' \\'FD\\' \\'MosaicRefAcqTimes\\'',\n    '    \\'0029\\' \\'1008\\' \\'CS\\' \\'CSAImageHeaderType\\'',\n    '    \\'0029\\' \\'1009\\' \\'LO\\' \\'CSAImageHeaderVersion\\'',\n    '    \\'0029\\' \\'1010\\' \\'OB\\' \\'CSAImageHeaderInfo\\'',\n    '    \\'0029\\' \\'1018\\' \\'CS\\' \\'CSASeriesHeaderType\\'',\n    '    \\'0029\\' \\'1019\\' \\'LO\\' \\'CSASeriesHeaderVersion\\'',\n    '    \\'0029\\' \\'1020\\' \\'OB\\' \\'CSASeriesHeaderInfo\\'',\n    '    \\'0029\\' \\'1110\\' \\'OB\\' \\'CSAImageHeaderInfo\\'',\n    '    \\'0029\\' \\'1120\\' \\'OB\\' \\'CSASeriesHeaderInfo\\'',\n    '    \\'0029\\' \\'1131\\' \\'LO\\' \\'PMTFInformation1\\'',\n    '    \\'0029\\' \\'1132\\' \\'UL\\' \\'PMTFInformation2\\'',\n    '    \\'0029\\' \\'1133\\' \\'UL\\' \\'PMTFInformation3\\'',\n    '    \\'0029\\' \\'1134\\' \\'CS\\' \\'PMTFInformation4\\'',\n    '    \\'0029\\' \\'1160\\' \\'LO\\' \\'SeriesWorkflowStatus\\'',\n    '    \\'0029\\' \\'1260\\' \\'LO\\' \\'SeriesWorkflowStatus\\'',\n    '    \\'0051\\' \\'1008\\' \\'CS\\' \\'Private_0051_10xx_Type\\'',\n    '    \\'0051\\' \\'1009\\' \\'LO\\' \\'Private_0051_10xx_Version\\'',\n    '    \\'0051\\' \\'100A\\' \\'LO\\' \\'TimeOfAcquisition\\'',\n    '    \\'0051\\' \\'100B\\' \\'LO\\' \\'AcquisitionMatrixText\\'',\n    '    \\'0051\\' \\'100C\\' \\'LO\\' \\'FieldOfView\\'',\n    '    \\'0051\\' \\'100D\\' \\'SH\\' \\'SlicePositionText\\'',\n    '    \\'0051\\' \\'100E\\' \\'LO\\' \\'ImageOrientation\\'',\n    '    \\'0051\\' \\'100F\\' \\'LO\\' \\'CoilString\\'',\n    '    \\'0051\\' \\'1011\\' \\'LO\\' \\'ImaPATModeText\\'',\n    '    \\'0051\\' \\'1012\\' \\'SH\\' \\'TablePositionText\\'',\n    '    \\'0051\\' \\'1013\\' \\'SH\\' \\'PositivePCSDirections\\'',\n    '    \\'0051\\' \\'1015\\' \\'SH\\' \\'DataFilterText\\' % not sure',\n    '    \\'0051\\' \\'1016\\' \\'LO\\' \\'ImageTypeText\\'',\n    '    \\'0051\\' \\'1017\\' \\'SH\\' \\'SliceThicknessText\\'',\n    '    \\'0051\\' \\'1019\\' \\'LO\\' \\'ScanOptionsText\\'',\n    '    }];',\n    '',\n    '',\n    'elseif strncmpi(vendor, \\'GE\\', 2) ',\n    '    C = [C; {',\n    '    \\'0009\\' \\'1001\\' \\'LO\\' \\'FullFidelity\\'',\n    '    \\'0009\\' \\'1002\\' \\'SH\\' \\'SuiteId\\'',\n    '    \\'0009\\' \\'1004\\' \\'SH\\' \\'ProductId\\'',\n    '    \\'0009\\' \\'1027\\' \\'SL\\' \\'ImageActualDate\\'',\n    '    \\'0009\\' \\'1030\\' \\'SH\\' \\'ServiceId\\'',\n    '    \\'0009\\' \\'1031\\' \\'SH\\' \\'MobileLocationNumber\\'',\n    '    \\'0009\\' \\'10E3\\' \\'UI\\' \\'EquipmentUID\\'',\n    '    \\'0009\\' \\'10E7\\' \\'UL\\' \\'ExamRecordChecksum\\'',\n    '    \\'0009\\' \\'10E9\\' \\'SL\\' \\'ActualSeriesDataTimeStamp\\'',\n    '    \\'0019\\' \\'100F\\' \\'DS\\' \\'HorizFrameOfRef\\'',\n    '    \\'0019\\' \\'1011\\' \\'SS\\' \\'SeriesContrast\\'',\n    '    \\'0019\\' \\'1012\\' \\'SS\\' \\'LastPseq\\'',\n    '    \\'0019\\' \\'1017\\' \\'SS\\' \\'SeriesPlane\\'',\n    '    \\'0019\\' \\'1018\\' \\'LO\\' \\'FirstScanRas\\'',\n    '    \\'0019\\' \\'1019\\' \\'DS\\' \\'FirstScanLocation\\'',\n    '    \\'0019\\' \\'101A\\' \\'LO\\' \\'LastScanRas\\'',\n    '    \\'0019\\' \\'101B\\' \\'DS\\' \\'LastScanLoc\\'',\n    '    \\'0019\\' \\'101E\\' \\'DS\\' \\'DisplayFieldOfView\\'',\n    '    \\'0019\\' \\'105A\\' \\'FL\\' \\'AcquisitionDuration\\'',\n    '    \\'0019\\' \\'107D\\' \\'DS\\' \\'SecondEcho\\'',\n    '    \\'0019\\' \\'107E\\' \\'SS\\' \\'NumberOfEchoes\\'',\n    '    \\'0019\\' \\'107F\\' \\'DS\\' \\'TableDelta\\'',\n    '    \\'0019\\' \\'1081\\' \\'SS\\' \\'Contiguous\\'',\n    '    \\'0019\\' \\'1084\\' \\'DS\\' \\'PeakSAR\\'',\n    '    \\'0019\\' \\'1085\\' \\'DS\\' \\'MonitorSAR\\'',\n    '    \\'0019\\' \\'1087\\' \\'DS\\' \\'CardiacRepetitionTime\\'',\n    '    \\'0019\\' \\'1088\\' \\'SS\\' \\'ImagesPerCardiacCycle\\'',\n    '    \\'0019\\' \\'108A\\' \\'SS\\' \\'ActualReceiveGainAnalog\\'',\n    '    \\'0019\\' \\'108B\\' \\'SS\\' \\'ActualReceiveGainDigital\\'',\n    '    \\'0019\\' \\'108D\\' \\'DS\\' \\'DelayAfterTrigger\\'',\n    '    \\'0019\\' \\'108F\\' \\'SS\\' \\'Swappf\\'',\n    '    \\'0019\\' \\'1090\\' \\'SS\\' \\'PauseInterval\\'',\n    '    \\'0019\\' \\'1091\\' \\'DS\\' \\'PauseTime\\'',\n    '    \\'0019\\' \\'1092\\' \\'SL\\' \\'SliceOffsetOnFreqAxis\\'',\n    '    \\'0019\\' \\'1093\\' \\'DS\\' \\'AutoPrescanCenterFrequency\\'',\n    '    \\'0019\\' \\'1094\\' \\'SS\\' \\'AutoPrescanTransmitGain\\'',\n    '    \\'0019\\' \\'1095\\' \\'SS\\' \\'AutoPrescanAnalogReceiverGain\\'',\n    '    \\'0019\\' \\'1096\\' \\'SS\\' \\'AutoPrescanDigitalReceiverGain\\'',\n    '    \\'0019\\' \\'1097\\' \\'SL\\' \\'BitmapdefiningCVs\\'',\n    '    \\'0019\\' \\'1098\\' \\'SS\\' \\'CenterFreqMethod\\'',\n    '    \\'0019\\' \\'109B\\' \\'SS\\' \\'PulseSequenceMode\\'',\n    '    \\'0019\\' \\'109C\\' \\'LO\\' \\'PulseSequenceName\\'',\n    '    \\'0019\\' \\'109D\\' \\'DT\\' \\'PulseSequenceDate\\'',\n    '    \\'0019\\' \\'109E\\' \\'LO\\' \\'SequenceName\\' % \\'InternalPulseSequenceName\\'',\n    '    \\'0019\\' \\'109F\\' \\'SS\\' \\'TransmittingCoilType\\'',\n    '    \\'0019\\' \\'10A0\\' \\'SS\\' \\'SurfaceCoilType\\'',\n    '    \\'0019\\' \\'10A1\\' \\'SS\\' \\'ExtremityCoilflag\\'',\n    '    \\'0019\\' \\'10A2\\' \\'SL\\' \\'RawDataRunNumber\\'',\n    '    \\'0019\\' \\'10A3\\' \\'UL\\' \\'CalibratedFieldStrength\\'',\n    '    \\'0019\\' \\'10A4\\' \\'SS\\' \\'SATFatWaterBone\\'',\n    '    \\'0019\\' \\'10A7\\' \\'DS\\' \\'UserData0\\'',\n    '    \\'0019\\' \\'10A8\\' \\'DS\\' \\'UserData1\\'',\n    '    \\'0019\\' \\'10A9\\' \\'DS\\' \\'UserData2\\'',\n    '    \\'0019\\' \\'10AA\\' \\'DS\\' \\'UserData3\\'',\n    '    \\'0019\\' \\'10AB\\' \\'DS\\' \\'UserData4\\'',\n    '    \\'0019\\' \\'10AC\\' \\'DS\\' \\'UserData5\\'',\n    '    \\'0019\\' \\'10AD\\' \\'DS\\' \\'UserData6\\'',\n    '    \\'0019\\' \\'10AE\\' \\'DS\\' \\'UserData7\\'',\n    '    \\'0019\\' \\'10AF\\' \\'DS\\' \\'UserData8\\'',\n    '    \\'0019\\' \\'10B0\\' \\'DS\\' \\'UserData9\\'',\n    '    \\'0019\\' \\'10B1\\' \\'DS\\' \\'UserData10\\'',\n    '    \\'0019\\' \\'10B2\\' \\'DS\\' \\'UserData11\\'',\n    '    \\'0019\\' \\'10B3\\' \\'DS\\' \\'UserData12\\'',\n    '    \\'0019\\' \\'10B4\\' \\'DS\\' \\'UserData13\\'',\n    '    \\'0019\\' \\'10B5\\' \\'DS\\' \\'UserData14\\'',\n    '    \\'0019\\' \\'10B6\\' \\'DS\\' \\'UserData15\\'',\n    '    \\'0019\\' \\'10B7\\' \\'DS\\' \\'UserData16\\'',\n    '    \\'0019\\' \\'10B8\\' \\'DS\\' \\'UserData17\\'',\n    '    \\'0019\\' \\'10B9\\' \\'DS\\' \\'UserData18\\'',\n    '    \\'0019\\' \\'10BA\\' \\'DS\\' \\'UserData19\\'',\n    '    \\'0019\\' \\'10BB\\' \\'DS\\' \\'DiffusionDirectionX\\' %\\'UserData20\\'',\n    '    \\'0019\\' \\'10BC\\' \\'DS\\' \\'DiffusionDirectionY\\' %\\'UserData21\\'',\n    '    \\'0019\\' \\'10BD\\' \\'DS\\' \\'DiffusionDirectionZ\\' %\\'UserData22\\'',\n    '    \\'0019\\' \\'10BE\\' \\'DS\\' \\'ProjectionAngle\\'',\n    '    \\'0019\\' \\'10C0\\' \\'SS\\' \\'SaturationPlanes\\'',\n    '    \\'0019\\' \\'10C2\\' \\'SS\\' \\'SATlocationR\\'',\n    '    \\'0019\\' \\'10C3\\' \\'SS\\' \\'SATlocationL\\'',\n    '    \\'0019\\' \\'10C4\\' \\'SS\\' \\'SATlocationA\\'',\n    '    \\'0019\\' \\'10C5\\' \\'SS\\' \\'SATlocationP\\'',\n    '    \\'0019\\' \\'10C6\\' \\'SS\\' \\'SATlocationH\\'',\n    '    \\'0019\\' \\'10C7\\' \\'SS\\' \\'SATlocationF\\'',\n    '    \\'0019\\' \\'10C8\\' \\'SS\\' \\'SATThicknessRL\\'',\n    '    \\'0019\\' \\'10C9\\' \\'SS\\' \\'SATThicknessAP\\'',\n    '    \\'0019\\' \\'10CA\\' \\'SS\\' \\'SATThicknessHF\\'',\n    '    \\'0019\\' \\'10CB\\' \\'SS\\' \\'PhaseContrastFlowAxis\\'',\n    '    \\'0019\\' \\'10CC\\' \\'SS\\' \\'VelocityEncoding\\'',\n    '    \\'0019\\' \\'10CD\\' \\'SS\\' \\'ThicknessDisclaimer\\'',\n    '    \\'0019\\' \\'10CE\\' \\'SS\\' \\'PrescanType\\'',\n    '    \\'0019\\' \\'10CF\\' \\'SS\\' \\'PrescanStatus\\'',\n    '    \\'0019\\' \\'10D2\\' \\'SS\\' \\'ProjectionAlgorithm\\'',\n    '    \\'0019\\' \\'10D5\\' \\'SS\\' \\'FractionalEcho\\'',\n    '    \\'0019\\' \\'10D7\\' \\'SS\\' \\'CardiacPhaseNumber\\'',\n    '    \\'0019\\' \\'10D8\\' \\'SS\\' \\'VariableEchoflag\\'',\n    '    \\'0019\\' \\'10D9\\' \\'DS\\' \\'ConcatenatedSAT\\'',\n    '    \\'0019\\' \\'10DF\\' \\'DS\\' \\'UserData23\\'',\n    '    \\'0019\\' \\'10E0\\' \\'DS\\' \\'NumberOfDiffusionDirection\\' %\\'UserData24\\'',\n    '    \\'0019\\' \\'10E2\\' \\'DS\\' \\'VelocityEncodeScale\\'',\n    '    \\'0019\\' \\'10F2\\' \\'SS\\' \\'FastPhases\\'',\n    '    \\'0019\\' \\'10F9\\' \\'DS\\' \\'TransmitGain\\'',\n    '    \\'0020\\' \\'9301\\' \\'DS\\' \\'ImagePositionPatient\\' % These 4 are not private',\n    '    \\'0020\\' \\'9302\\' \\'DS\\' \\'ImageOrientationPatient\\' % but seems used only by GE',\n    '    \\'0020\\' \\'930E\\' \\'SQ\\' \\'PlanePositionSequence\\'',\n    '    \\'0020\\' \\'930F\\' \\'SQ\\' \\'PlaneOrientationSequence\\'',\n    '    \\'0021\\' \\'1003\\' \\'SS\\' \\'SeriesFromWhichPrescribed\\'',\n    '    \\'0021\\' \\'1035\\' \\'SS\\' \\'SeriesFromWhichPrescribed\\'',\n    '    \\'0021\\' \\'1036\\' \\'SS\\' \\'ImageFromWhichPrescribed\\'',\n    '    \\'0021\\' \\'1037\\' \\'SS\\' \\'ScreenFormat\\'',\n    '    \\'0021\\' \\'104F\\' \\'SS\\' \\'LocationsInAcquisition\\'',\n    '    \\'0021\\' \\'1050\\' \\'SS\\' \\'GraphicallyPrescribed\\'',\n    '    \\'0021\\' \\'1051\\' \\'DS\\' \\'RotationFromSourceXRot\\'',\n    '    \\'0021\\' \\'1052\\' \\'DS\\' \\'RotationFromSourceYRot\\'',\n    '    \\'0021\\' \\'1053\\' \\'DS\\' \\'RotationFromSourceZRot\\'',\n    '    \\'0021\\' \\'1056\\' \\'SL\\' \\'Num3DSlabs\\'',\n    '    \\'0021\\' \\'1057\\' \\'SL\\' \\'LocsPer3DSlab\\'',\n    '    \\'0021\\' \\'1058\\' \\'SL\\' \\'Overlaps\\'',\n    '    \\'0021\\' \\'1059\\' \\'SL\\' \\'ImageFiltering\\'',\n    '    \\'0021\\' \\'105A\\' \\'SL\\' \\'DiffusionDirection\\'',\n    '    \\'0021\\' \\'105B\\' \\'DS\\' \\'TaggingFlipAngle\\'',\n    '    \\'0021\\' \\'105C\\' \\'DS\\' \\'TaggingOrientation\\'',\n    '    \\'0021\\' \\'105D\\' \\'DS\\' \\'TagSpacing\\'',\n    '    \\'0021\\' \\'105E\\' \\'DS\\' \\'RTIA_timer\\'',\n    '    \\'0021\\' \\'105F\\' \\'DS\\' \\'Fps\\'',\n    '    \\'0021\\' \\'1081\\' \\'DS\\' \\'AutoWindowLevelAlpha\\'',\n    '    \\'0021\\' \\'1082\\' \\'DS\\' \\'AutoWindowLevelBeta\\'',\n    '    \\'0021\\' \\'1083\\' \\'DS\\' \\'AutoWindowLevelWindow\\'',\n    '    \\'0021\\' \\'1084\\' \\'DS\\' \\'AutoWindowLevelLevel\\'',\n    '    \\'0023\\' \\'1070\\' \\'FD\\' \\'StartTimeInFirstAxial\\'',\n    '    \\'0023\\' \\'1074\\' \\'SL\\' \\'NumberOfUpdatesToHeader\\'',\n    '    \\'0023\\' \\'107D\\' \\'SS\\' \\'IndicatesStudyHasCompleteInfo\\'',\n    '    \\'0025\\' \\'1006\\' \\'SS\\' \\'LastPulseSequenceUsed\\'',\n    '    \\'0025\\' \\'1007\\' \\'SL\\' \\'ImagesInSeries\\'',\n    '    \\'0025\\' \\'1010\\' \\'SL\\' \\'LandmarkCounter\\'',\n    '    \\'0025\\' \\'1011\\' \\'SS\\' \\'NumberOfAcquisitions\\'',\n    '    \\'0025\\' \\'1014\\' \\'SL\\' \\'IndicatesNumberOfUpdatesToHeader\\'',\n    '    \\'0025\\' \\'1017\\' \\'SL\\' \\'SeriesCompleteFlag\\'',\n    '    \\'0025\\' \\'1018\\' \\'SL\\' \\'NumberOfImagesArchived\\'',\n    '    \\'0025\\' \\'1019\\' \\'SL\\' \\'LastImageNumberUsed\\'',\n    '    \\'0025\\' \\'101A\\' \\'SH\\' \\'PrimaryReceiverSuiteAndHost\\'',\n    '    \\'0025\\' \\'101B\\' \\'OB\\' \\'ProtocolDataBlock\\'',\n    '    \\'0027\\' \\'1006\\' \\'SL\\' \\'ImageArchiveFlag\\'',\n    '    \\'0027\\' \\'1010\\' \\'SS\\' \\'ScoutType\\'',\n    '    \\'0027\\' \\'1031\\' \\'SS\\' \\'ImagingMode\\'',\n    '    \\'0027\\' \\'1032\\' \\'SS\\' \\'PulseSequence\\'',\n    '    \\'0027\\' \\'1033\\' \\'UL\\' \\'ImagingOptions\\'',\n    '    \\'0027\\' \\'1035\\' \\'SS\\' \\'PlaneType\\'',\n    '    \\'0027\\' \\'1040\\' \\'SH\\' \\'RASletterOfImageLocation\\'',\n    '    \\'0027\\' \\'1041\\' \\'FL\\' \\'ImageLocation\\'',\n    '    \\'0027\\' \\'1042\\' \\'FL\\' \\'CenterRCoordOfPlaneImage\\'',\n    '    \\'0027\\' \\'1043\\' \\'FL\\' \\'CenterACoordOfPlaneImage\\'',\n    '    \\'0027\\' \\'1044\\' \\'FL\\' \\'CenterSCoordOfPlaneImage\\'',\n    '    \\'0027\\' \\'1045\\' \\'FL\\' \\'NormalRCoord\\'',\n    '    \\'0027\\' \\'1046\\' \\'FL\\' \\'NormalACoord\\'',\n    '    \\'0027\\' \\'1047\\' \\'FL\\' \\'NormalSCoord\\'',\n    '    \\'0027\\' \\'1060\\' \\'FL\\' \\'ImageDimensionX\\'',\n    '    \\'0027\\' \\'1061\\' \\'FL\\' \\'ImageDimensionY\\'',\n    '    \\'0027\\' \\'1062\\' \\'FL\\' \\'NumberOfExcitations\\'',\n    '    \\'0029\\' \\'1015\\' \\'SL\\' \\'LowerRangeOfPixels1\\'',\n    '    \\'0029\\' \\'1016\\' \\'SL\\' \\'UpperRangeOfPixels1\\'',\n    '    \\'0029\\' \\'1017\\' \\'SL\\' \\'LowerRangeOfPixels2\\'',\n    '    \\'0029\\' \\'1018\\' \\'SL\\' \\'UpperRangeOfPixels2\\'',\n    '    \\'0029\\' \\'1026\\' \\'SS\\' \\'VersionOfTheHdrStruct\\'',\n    '    \\'0029\\' \\'1034\\' \\'SL\\' \\'AdvantageCompOverflow\\'',\n    '    \\'0029\\' \\'1035\\' \\'SL\\' \\'AdvantageCompUnderflow\\'',\n    '    \\'0043\\' \\'1001\\' \\'SS\\' \\'BitmapOfPrescanOptions\\'',\n    '    \\'0043\\' \\'1002\\' \\'SS\\' \\'GradientOffsetInX\\'',\n    '    \\'0043\\' \\'1003\\' \\'SS\\' \\'GradientOffsetInY\\'',\n    '    \\'0043\\' \\'1004\\' \\'SS\\' \\'GradientOffsetInZ\\'',\n    '    \\'0043\\' \\'1006\\' \\'SS\\' \\'NumberOfEPIShots\\'',\n    '    \\'0043\\' \\'1007\\' \\'SS\\' \\'ViewsPerSegment\\'',\n    '    \\'0043\\' \\'1008\\' \\'SS\\' \\'RespiratoryRate\\'',\n    '    \\'0043\\' \\'1009\\' \\'SS\\' \\'RespiratoryTriggerPoint\\'',\n    '    \\'0043\\' \\'100A\\' \\'SS\\' \\'TypeOfReceiverUsed\\'',\n    '    \\'0043\\' \\'100B\\' \\'DS\\' \\'DB_dtPeakRateOfChangeOfGradientField\\'',\n    '    \\'0043\\' \\'100C\\' \\'DS\\' \\'dB_dtLimitsInUnitsOfPercent\\'',\n    '    \\'0043\\' \\'100D\\' \\'DS\\' \\'PSDEstimatedLimit\\'',\n    '    \\'0043\\' \\'100E\\' \\'DS\\' \\'PSDEstimatedLimitInTeslaPerSecond\\'',\n    '    \\'0043\\' \\'1010\\' \\'SS\\' \\'WindowValue\\'',\n    '    \\'0043\\' \\'101C\\' \\'SS\\' \\'GEImageIntegrity\\'',\n    '    \\'0043\\' \\'101D\\' \\'SS\\' \\'LevelValue\\'',\n    '    \\'0043\\' \\'100F\\' \\'DS\\' \\'Saravghead\\'',\n    '    \\'0043\\' \\'1028\\' \\'OB\\' \\'UniqueImageIden\\'',\n    '    \\'0043\\' \\'1029\\' \\'OB\\' \\'HistogramTables\\'',\n    '    \\'0043\\' \\'102A\\' \\'OB\\' \\'UserDefineData\\'',\n    '    \\'0043\\' \\'102B\\' \\'SS\\' \\'PrivateScanOptions\\'',\n    '    \\'0043\\' \\'102C\\' \\'SS\\' \\'EffectiveEchoSpacing\\'',\n    '    \\'0043\\' \\'102D\\' \\'SH\\' \\'FilterMode\\'',\n    '    \\'0043\\' \\'102F\\' \\'SS\\' \\'PrivateImageType\\'',\n    '    \\'0043\\' \\'1030\\' \\'SS\\' \\'VasCollapseFlag\\'',\n    '    \\'0043\\' \\'1032\\' \\'SS\\' \\'VasFlags\\'',\n    '    \\'0043\\' \\'1033\\' \\'FL\\' \\'Neg_scanspacing\\'',\n    '    \\'0043\\' \\'1034\\' \\'IS\\' \\'OffsetFrequency\\'',\n    '    \\'0043\\' \\'1035\\' \\'UL\\' \\'User_usage_tag\\'',\n    '    \\'0043\\' \\'1036\\' \\'UL\\' \\'User_fill_map_MSW\\'',\n    '    \\'0043\\' \\'1037\\' \\'UL\\' \\'User_fill_map_LSW\\'',\n    '    \\'0043\\' \\'1038\\' \\'FL\\' \\'UserData_25_48\\'',\n    '    \\'0043\\' \\'1039\\' \\'IS\\' \\'SlopInt_6_9\\'',\n    '    \\'0043\\' \\'1060\\' \\'IS\\' \\'SlopInt_10_17\\'',\n    '    \\'0043\\' \\'1061\\' \\'UI\\' \\'ScannerStudyEntityUID\\'',\n    '    \\'0043\\' \\'1062\\' \\'SH\\' \\'ScannerStudyID\\'',\n    '    \\'0043\\' \\'106F\\' \\'DS\\' \\'ScannerTableEntry\\'',\n    '    \\'0043\\' \\'1070\\' \\'LO\\' \\'ParadigmName\\'',\n    '    \\'0043\\' \\'1071\\' \\'ST\\' \\'ParadigmDescription\\'',\n    '    \\'0043\\' \\'1072\\' \\'UI\\' \\'ParadigmUID\\'',\n    '    \\'0043\\' \\'1073\\' \\'US\\' \\'ExperimentType\\'',\n    '    \\'0043\\' \\'1074\\' \\'US\\' \\'NumberOfRestVolumes\\'',\n    '    \\'0043\\' \\'1075\\' \\'US\\' \\'NumberOfActiveVolumes\\'',\n    '    \\'0043\\' \\'1076\\' \\'US\\' \\'NumberOfDummyScans\\'',\n    '    \\'0043\\' \\'1079\\' \\'US\\' \\'LocationsInAcquisition\\' % \\'SlicesPerVolume\\'',\n    '    \\'0043\\' \\'107A\\' \\'US\\' \\'ExpectedTimePoints\\'',\n    '    \\'0043\\' \\'107B\\' \\'FL\\' \\'RegressorValues\\'',\n    '    \\'0043\\' \\'107C\\' \\'FL\\' \\'DelayAfterSliceGroup\\'',\n    '    \\'0043\\' \\'107D\\' \\'US\\' \\'ReconModeFlagWord\\'',\n    '    \\'0043\\' \\'1080\\' \\'LO\\' \\'CoilIDData\\'',\n    '    \\'0043\\' \\'1081\\' \\'LO\\' \\'GECoilName\\'',\n    '    \\'0043\\' \\'1082\\' \\'LO\\' \\'SystemConfigurationInformation\\'',\n    '    \\'0043\\' \\'1083\\' \\'DS\\' \\'AssetRFactors\\'',\n    '    \\'0043\\' \\'1084\\' \\'LO\\' \\'AdditionalAssetData\\'',\n    '    \\'0043\\' \\'1088\\' \\'UI\\' \\'PUREAcquisitionCalibrationSeriesUID\\'',\n    '    \\'0043\\' \\'1089\\' \\'LO\\' \\'GoverningBodydB_dtAndSARDefinition\\'',\n    '    \\'0043\\' \\'108A\\' \\'CS\\' \\'InPlanePhaseEncodingDirection\\'',\n    '    \\'0043\\' \\'108B\\' \\'OB\\' \\'FMRIBinaryDataBlock\\'',\n    '    \\'0043\\' \\'1090\\' \\'LO\\' \\'SARDefinition\\'',\n    '    \\'0043\\' \\'1091\\' \\'DS\\' \\'SARValue\\'',\n    '    \\'0043\\' \\'1095\\' \\'LO\\' \\'PrescanReuseString\\'',\n    '    \\'0043\\' \\'1096\\' \\'CS\\' \\'ContentQualification\\'',\n    '    \\'0043\\' \\'1097\\' \\'LO\\' \\'ImageFilteringParameters\\'',\n    '    \\'0043\\' \\'1098\\' \\'UI\\' \\'ASSETAcquisitionCalibrationSeriesUID\\'',\n    '    \\'0043\\' \\'109A\\' \\'IS\\' \\'RxStackIdentification\\'',\n    '    \\'0043\\' \\'10AA\\' \\'LO\\' \\'AdditionalFilteringParameters\\'',\n    '    \\'0043\\' \\'10B3\\' \\'DS\\' \\'AdvancedEddyCorrection\\' }];',\n    '    % SlopInt:',\n    '    % 6: b_value 7: private imaging options 2  8: ihtagging  9: ihtagspc',\n    '    % 10: ihfcineim  11: ihfcinent  12: Reserved  13: oprtarr ',\n    '    % 14: averages  15: Current Station #  16: Total # of Stations ',\n    '    % 17: private imaging options 3',\n    '',\n    '    % ScannerTableEntry:',\n    '    % 1: table entry, 2: table swing angle, 3: table lateral offset, ',\n    '    % 4: gradient coil selected (multiple gradient systems only)',\n    'elseif strncmpi(vendor, \\'Philips\\', 7)',\n    '    C = [C; {',\n    '    \\'2001\\' \\'1001\\' \\'FL\\' \\'ChemicalShift\\'',\n    '    \\'2001\\' \\'1002\\' \\'IS\\' \\'ChemicalShiftNumberMR\\'',\n    '    \\'2001\\' \\'1003\\' \\'FL\\' \\'B_factor\\'',\n    '    \\'2001\\' \\'1004\\' \\'CS\\' \\'DiffusionDirection\\'',\n    '    \\'2001\\' \\'1006\\' \\'CS\\' \\'ImageEnhanced\\'',\n    '    \\'2001\\' \\'1007\\' \\'CS\\' \\'ImageTypeEDES\\'',\n    '    \\'2001\\' \\'1008\\' \\'IS\\' \\'PhaseNumber\\'',\n    '    \\'2001\\' \\'1009\\' \\'FL\\' \\'ImagePrepulseDelay\\'',\n    '    \\'2001\\' \\'100A\\' \\'IS\\' \\'SliceNumberMR\\'',\n    '    \\'2001\\' \\'100B\\' \\'CS\\' \\'SliceOrientation\\'',\n    '    \\'2001\\' \\'100C\\' \\'CS\\' \\'ArrhythmiaRejection\\'',\n    '    \\'2001\\' \\'100E\\' \\'CS\\' \\'CardiacCycled\\'',\n    '    \\'2001\\' \\'100F\\' \\'SS\\' \\'CardiacGateWidth\\'',\n    '    \\'2001\\' \\'1010\\' \\'CS\\' \\'CardiacSync\\'',\n    '    \\'2001\\' \\'1011\\' \\'FL\\' \\'DiffusionEchoTime\\'',\n    '    \\'2001\\' \\'1012\\' \\'CS\\' \\'DynamicSeries\\'',\n    '    \\'2001\\' \\'1013\\' \\'SL\\' \\'EPIFactor\\'',\n    '    \\'2001\\' \\'1014\\' \\'SL\\' \\'NumberOfEchoes\\'',\n    '    \\'2001\\' \\'1015\\' \\'SS\\' \\'NumberOfLocations\\'',\n    '    \\'2001\\' \\'1016\\' \\'SS\\' \\'NumberOfPCDirections\\'',\n    '    \\'2001\\' \\'1017\\' \\'SL\\' \\'NumberOfPhasesMR\\'',\n    '    \\'2001\\' \\'1018\\' \\'SL\\' \\'LocationsInAcquisition\\'  % \\'NumberOfSlicesMR\\'',\n    '    \\'2001\\' \\'1019\\' \\'CS\\' \\'PartialMatrixScanned\\'',\n    '    \\'2001\\' \\'101A\\' \\'FL\\' \\'PCVelocity\\'',\n    '    \\'2001\\' \\'101B\\' \\'FL\\' \\'PrepulseDelay\\'',\n    '    \\'2001\\' \\'101C\\' \\'CS\\' \\'PrepulseType\\'',\n    '    \\'2001\\' \\'101D\\' \\'IS\\' \\'ReconstructionNumberMR\\'',\n    '    \\'2001\\' \\'101F\\' \\'CS\\' \\'RespirationSync\\'',\n    '    \\'2001\\' \\'1020\\' \\'LO\\' \\'ScanningSequence\\' % ScanningTechnique',\n    '    \\'2001\\' \\'1021\\' \\'CS\\' \\'SPIR\\'',\n    '    \\'2001\\' \\'1022\\' \\'FL\\' \\'WaterFatShift\\'',\n    '    \\'2001\\' \\'1023\\' \\'DS\\' \\'MRSeriesFlipAngle\\' % duplicate',\n    '    \\'2001\\' \\'1024\\' \\'CS\\' \\'SeriesIsInteractive\\' ',\n    '    \\'2001\\' \\'1025\\' \\'SH\\' \\'EchoTimeDisplay\\' ',\n    '    \\'2001\\' \\'102D\\' \\'SS\\' \\'StackNumberOfSlices\\'',\n    '    \\'2001\\' \\'1032\\' \\'FL\\' \\'StackRadialAngle\\'',\n    '    \\'2001\\' \\'1033\\' \\'CS\\' \\'StackRadialAxis\\'',\n    '    \\'2001\\' \\'1035\\' \\'SS\\' \\'StackSliceNumber\\'',\n    '    \\'2001\\' \\'1036\\' \\'CS\\' \\'StackType\\'',\n    '    \\'2001\\' \\'105F\\' \\'SQ\\' \\'Stack\\' ',\n    '    \\'2001\\' \\'1060\\' \\'SL\\' \\'NumberOfStacks\\'',\n    '    \\'2001\\' \\'1061\\' \\'CS\\' \\'SeriesTransmitted\\'',\n    '    \\'2001\\' \\'1062\\' \\'CS\\' \\'SeriesCommitted\\'',\n    '    \\'2001\\' \\'1063\\' \\'CS\\' \\'ExaminationSource\\'',\n    '    \\'2001\\' \\'106E\\' \\'SH\\' \\'SeriesType\\'',\n    '    \\'2001\\' \\'107B\\' \\'IS\\' \\'MRSeriesAcquisitionNumber\\'',\n    '    \\'2001\\' \\'1081\\' \\'IS\\' \\'NumberOfDynamicScans\\'',\n    '    \\'2001\\' \\'1082\\' \\'IS\\' \\'MRSeriesEchoTrainLength\\' % duplicate',\n    '    \\'2001\\' \\'1083\\' \\'DS\\' \\'MRSeriesImagingFrequency\\' % duplicate',\n    '    \\'2001\\' \\'1084\\' \\'DS\\' \\'MRSeriesInversionTime\\' % duplicate',\n    '    \\'2001\\' \\'1085\\' \\'DS\\' \\'MRSeriesMagneticFieldStrength\\' % duplicate, seems wrong',\n    '    \\'2001\\' \\'1086\\' \\'IS\\' \\'MRSeriesNrOfPhaseEncodingSteps\\' % duplicate, seems wrong',\n    '    \\'2001\\' \\'1087\\' \\'SH\\' \\'MRSeriesNucleus\\' % duplicate',\n    '    \\'2001\\' \\'1088\\' \\'DS\\' \\'MRSeriesNumberOfAverages\\' % duplicate',\n    '    \\'2001\\' \\'1089\\' \\'DS\\' \\'MRSeriesPercentPhaseFieldOfView\\' % duplicate, wrong',\n    '    \\'2001\\' \\'108A\\' \\'DS\\' \\'MRSeriesPercentSampling\\' % duplicate, wrong',\n    '    \\'2001\\' \\'108B\\' \\'SH\\' \\'MRSeriesTransmittingCoil\\' % duplicate',\n    '    \\'2001\\' \\'10C8\\' \\'LO\\' \\'ExamCardName\\'',\n    '    \\'2001\\' \\'10F1\\' \\'FL\\' \\'ProspectiveMotionCorrection\\'',\n    '    \\'2001\\' \\'10F2\\' \\'FL\\' \\'RetrospectiveMotionCorrection\\'',\n    '    \\'2005\\' \\'1000\\' \\'FL\\' \\'MRImageAngulationAP\\' ',\n    '    \\'2005\\' \\'1001\\' \\'FL\\' \\'MRImageAngulationFH\\' ',\n    '    \\'2005\\' \\'1002\\' \\'FL\\' \\'MRImageAngulationRL\\'',\n    '    \\'2005\\' \\'1004\\' \\'CS\\' \\'MRImageDisplayOrientation\\'',\n    '    \\'2005\\' \\'1008\\' \\'FL\\' \\'MRImageOffCentreAP\\'',\n    '    \\'2005\\' \\'1009\\' \\'FL\\' \\'MRImageOffCentreFH\\'',\n    '    \\'2005\\' \\'100A\\' \\'FL\\' \\'MRImageOffCentreRL\\'',\n    '    \\'2005\\' \\'100B\\' \\'FL\\' \\'MRMaxFP\\'',\n    '    \\'2005\\' \\'100C\\' \\'FL\\' \\'MRMinFP\\'',\n    '    \\'2005\\' \\'100D\\' \\'FL\\' \\'MRScaleIntercept\\'',\n    '    \\'2005\\' \\'100E\\' \\'FL\\' \\'MRScaleSlope\\'',\n    '    \\'2005\\' \\'100F\\' \\'DS\\' \\'WindowCenterOriginal\\'',\n    '    \\'2005\\' \\'1010\\' \\'DS\\' \\'WindowWidthOriginal\\'',\n    '    \\'2005\\' \\'1011\\' \\'CS\\' \\'MRImageTypeMR\\'',\n    '    \\'2005\\' \\'1012\\' \\'CS\\' \\'MRCardiacGating\\'',\n    '    \\'2005\\' \\'1013\\' \\'CS\\' \\'MRSeriesDevelopmentMode\\'',\n    '    \\'2005\\' \\'1014\\' \\'CS\\' \\'MRSeriesDiffusion\\'',\n    '    \\'2005\\' \\'1015\\' \\'CS\\' \\'MRFatSaturationTechnique\\'',\n    '    \\'2005\\' \\'1016\\' \\'CS\\' \\'MRFlowCompensation\\'',\n    '    \\'2005\\' \\'1017\\' \\'CS\\' \\'MRFourierInterpolation\\'',\n    '    \\'2005\\' \\'1019\\' \\'CS\\' \\'MRInverseReconstructed\\'',\n    '    \\'2005\\' \\'101A\\' \\'SS\\' \\'MRLabelSyntax\\'',\n    '    \\'2005\\' \\'101B\\' \\'CS\\' \\'MRMagnetiPrepared\\'',\n    '    \\'2005\\' \\'101C\\' \\'CS\\' \\'MRMagnetTransferConst\\'',\n    '    \\'2005\\' \\'101D\\' \\'SS\\' \\'MRMeasurementScanResolution\\'',\n    '    \\'2005\\' \\'101E\\' \\'SH\\' \\'MIPProtocol\\' ',\n    '    \\'2005\\' \\'101F\\' \\'SH\\' \\'MPRProtocol\\' ',\n    '    \\'2005\\' \\'1020\\' \\'SL\\' \\'NumberOfChemicalShift\\'',\n    '    \\'2005\\' \\'1021\\' \\'SS\\' \\'MRNumberOfMixes\\'',\n    '    \\'2005\\' \\'1022\\' \\'IS\\' \\'MRNumberOfReferences\\'',\n    '    \\'2005\\' \\'1023\\' \\'SS\\' \\'MRNumberOfSlabs\\'',\n    '    \\'2005\\' \\'1025\\' \\'SS\\' \\'MRNumberOfVolumes\\'',\n    '    \\'2005\\' \\'1026\\' \\'CS\\' \\'MROverSampleingPhase\\'',\n    '    \\'2005\\' \\'1027\\' \\'CS\\' \\'MRPackageMode\\'',\n    '    \\'2005\\' \\'1028\\' \\'CS\\' \\'MRPartialFourierFrequency\\'',\n    '    \\'2005\\' \\'1029\\' \\'CS\\' \\'MRPartialFourierPhase\\'',\n    '    \\'2005\\' \\'102A\\' \\'IS\\' \\'MRPatientReferenceID\\'',\n    '    \\'2005\\' \\'102B\\' \\'SS\\' \\'MRPercentScanComplete\\'',\n    '    \\'2005\\' \\'102C\\' \\'CS\\' \\'MRPhaseEncodedRecording\\'',\n    '    \\'2005\\' \\'102D\\' \\'IS\\' \\'MRPlanScanSurveyNumberOfImages\\'',\n    '    \\'2005\\' \\'102E\\' \\'CS\\' \\'MRPPGPPUGating\\'',\n    '    \\'2005\\' \\'102F\\' \\'CS\\' \\'MRSpatialPresaturation\\'',\n    '    \\'2005\\' \\'1030\\' \\'FL\\' \\'MRSeriesRepetitionTime\\' % duplicate',\n    '    \\'2005\\' \\'1031\\' \\'CS\\' \\'MRRespiratoryGating\\'',\n    '    \\'2005\\' \\'1033\\' \\'FL\\' \\'MRSeriesScanDuration\\'',\n    '    \\'2005\\' \\'1034\\' \\'CS\\' \\'MRSegmentedKSpace\\'',\n    '    \\'2005\\' \\'1035\\' \\'CS\\' \\'MRSeriesDataType\\'',\n    '    \\'2005\\' \\'1036\\' \\'CS\\' \\'MRSeriesIsCardiac\\'',\n    '    \\'2005\\' \\'1037\\' \\'CS\\' \\'MRSeriesIsSpectro\\'',\n    '    \\'2005\\' \\'1038\\' \\'CS\\' \\'MRSpoiled\\'',\n    '    \\'2005\\' \\'1039\\' \\'CS\\' \\'MRSteadyState\\'',\n    '    \\'2005\\' \\'103A\\' \\'SH\\' \\'MRSubAnatomy\\'',\n    '    \\'2005\\' \\'103B\\' \\'CS\\' \\'MRTimeReversedSteadyState\\'',\n    '    \\'2005\\' \\'103C\\' \\'CS\\' \\'MRSeriesTone\\'',\n    '    \\'2005\\' \\'103D\\' \\'SS\\' \\'MRNumberOfRRIntervalRanges\\'',\n    '    \\'2005\\' \\'103E\\' \\'SL\\' \\'MRRRIntervalsDistribution\\'',\n    '    \\'2005\\' \\'103F\\' \\'SL\\' \\'MRPlanScanAcquisitionNo\\'',\n    '    \\'2005\\' \\'1040\\' \\'SL\\' \\'MRChemicalShiftNo\\'',\n    '    \\'2005\\' \\'1041\\' \\'SL\\' \\'MRPlanScanDynamicScanNo\\'',\n    '    \\'2005\\' \\'1042\\' \\'SL\\' \\'MRPlanScanSurveyEchoNo\\'',\n    '    \\'2005\\' \\'1043\\' \\'CS\\' \\'MRPlanScanImageType\\'',\n    '    \\'2005\\' \\'1044\\' \\'SL\\' \\'MRPlanScanPhaseNo\\'',\n    '    \\'2005\\' \\'1045\\' \\'SL\\' \\'MRPlanScanReconstructionNo\\'',\n    '    \\'2005\\' \\'1046\\' \\'CS\\' \\'MRPlanScanScanningSequence\\'',\n    '    \\'2005\\' \\'1047\\' \\'SL\\' \\'MRPlanScanSliceNo\\'',\n    '    \\'2005\\' \\'1054\\' \\'FL\\' \\'MRVolumeAngulationAP\\'',\n    '    \\'2005\\' \\'1055\\' \\'FL\\' \\'MRVolumeAngulationFH\\'',\n    '    \\'2005\\' \\'1056\\' \\'FL\\' \\'MRVolumeAngulationRL\\'',\n    '    \\'2005\\' \\'1057\\' \\'FL\\' \\'MRVolumeFovAP\\'',\n    '    \\'2005\\' \\'1058\\' \\'FL\\' \\'MRVolumeFovFH\\'',\n    '    \\'2005\\' \\'1059\\' \\'FL\\' \\'MRVolumeFovRL\\'',\n    '    \\'2005\\' \\'105A\\' \\'FL\\' \\'MRVolumeOffcentreAP\\'',\n    '    \\'2005\\' \\'105B\\' \\'FL\\' \\'MRVolumeOffcentreFH\\'',\n    '    \\'2005\\' \\'105C\\' \\'FL\\' \\'MRVolumeOffcentreRL\\'',\n    '    \\'2005\\' \\'105D\\' \\'CS\\' \\'MRVolumeType\\'',\n    '    \\'2005\\' \\'105E\\' \\'CS\\' \\'MRVolumeViewAxis\\'',\n    '    \\'2005\\' \\'105F\\' \\'CS\\' \\'MRStudyOrigin\\'',\n    '    \\'2005\\' \\'1060\\' \\'IS\\' \\'MRStudySequenceNumber\\'',\n    '    \\'2005\\' \\'1061\\' \\'CS\\' \\'MRImagePrepulseType\\'',\n    '    \\'2005\\' \\'1063\\' \\'SS\\' \\'MRfMRIStatusIndication\\'',\n    '    \\'2005\\' \\'106E\\' \\'CS\\' \\'MRImageScanningSequencePrivate\\'',\n    '    \\'2005\\' \\'106F\\' \\'CS\\' \\'MRAcquisitionType\\' % \\'MRSeriesAcquisitionTypePrivate\\'',\n    '    \\'2005\\' \\'1071\\' \\'FL\\' \\'MRStackAngulationAP\\'',\n    '    \\'2005\\' \\'1072\\' \\'FL\\' \\'MRStackAngulationFH\\'',\n    '    \\'2005\\' \\'1073\\' \\'FL\\' \\'MRStackAngulationRL\\'',\n    '    \\'2005\\' \\'1074\\' \\'FL\\' \\'MRStackFovAP\\'',\n    '    \\'2005\\' \\'1075\\' \\'FL\\' \\'MRStackFovFH\\'',\n    '    \\'2005\\' \\'1076\\' \\'FL\\' \\'MRStackFovRL\\'',\n    '    \\'2005\\' \\'1078\\' \\'FL\\' \\'MRStackOffcentreAP\\'',\n    '    \\'2005\\' \\'1079\\' \\'FL\\' \\'MRStackOffcentreFH\\'',\n    '    \\'2005\\' \\'107A\\' \\'FL\\' \\'MRStackOffcentreRL\\'',\n    '    \\'2005\\' \\'107B\\' \\'CS\\' \\'MRStackPreparationDirection\\'',\n    '    \\'2005\\' \\'107E\\' \\'FL\\' \\'MRStackSliceDistance\\'',\n    '    \\'2005\\' \\'1080\\' \\'SQ\\' \\'SeriesPlanScan\\'',\n    '    \\'2005\\' \\'1081\\' \\'CS\\' \\'MRStackViewAxis\\'',\n    '    \\'2005\\' \\'1083\\' \\'SQ\\' \\'SeriesSlab\\'',\n    '    \\'2005\\' \\'1084\\' \\'SQ\\' \\'SeriesReference\\'',\n    '    \\'2005\\' \\'1085\\' \\'SQ\\' \\'SeriesVolume\\'',\n    '    \\'2005\\' \\'1086\\' \\'SS\\' \\'MRNumberOfGeometry\\'',\n    '    \\'2005\\' \\'109E\\' \\'SQ\\' \\'SeriesGeom\\'',\n    '    \\'2005\\' \\'109F\\' \\'CS\\' \\'MRSeriesSpectralSelectiveExcitationPulse\\'',\n    '    \\'2005\\' \\'10A0\\' \\'FL\\' \\'MRImageDynamicScanBeginTime\\'',\n    '    \\'2005\\' \\'10A1\\' \\'CS\\' \\'SyncraScanType\\'',\n    '    \\'2005\\' \\'10A2\\' \\'CS\\' \\'MRIsCOCA\\'',\n    '    \\'2005\\' \\'10A3\\' \\'IS\\' \\'MRStackCoilID\\'',\n    '    \\'2005\\' \\'10A4\\' \\'IS\\' \\'MRStackCBBCoil1\\'',\n    '    \\'2005\\' \\'10A5\\' \\'IS\\' \\'MRStackCBBCoil2\\'',\n    '    \\'2005\\' \\'10A6\\' \\'IS\\' \\'MRStackChannelCombi\\'',\n    '    \\'2005\\' \\'10A7\\' \\'CS\\' \\'MRStackCoilConn\\'',\n    '    \\'2005\\' \\'10A8\\' \\'DS\\' \\'MRPrivateInversionTime\\'',\n    '    \\'2005\\' \\'10A9\\' \\'CS\\' \\'MRSeriesGeometryCorrection\\'',\n    '    \\'2005\\' \\'10B0\\' \\'FL\\' \\'DiffusionDirectionX\\' % degrees',\n    '    \\'2005\\' \\'10B1\\' \\'FL\\' \\'DiffusionDirectionY\\'',\n    '    \\'2005\\' \\'10B2\\' \\'FL\\' \\'DiffusionDirectionZ\\' ',\n    '    \\'2005\\' \\'10C0\\' \\'CS\\' \\'SequenceVariant\\' % \\'SeriesScanSequence\\' % duplicate',\n    '    \\'2005\\' \\'1134\\' \\'LT\\' \\'SeriesTransactionUID\\'',\n    '    \\'2005\\' \\'1199\\' \\'UL\\' \\'MRNumberOfRequestExcerpts\\'',\n    '    \\'2005\\' \\'1200\\' \\'UL\\' \\'MRNumberOfSOPCommon\\'',\n    '    \\'2005\\' \\'1201\\' \\'UL\\' \\'MRNoOfFilmConsumption\\'',\n    '    \\'2005\\' \\'1213\\' \\'UL\\' \\'MRNumberOfCodes\\'',\n    '    \\'2005\\' \\'1243\\' \\'SS\\' \\'MRNoDateOfLastCalibration\\'',\n    '    \\'2005\\' \\'1244\\' \\'SS\\' \\'MRNoTimeOfLastCalibration\\'',\n    '    \\'2005\\' \\'1245\\' \\'SS\\' \\'MRNrOfSoftwareVersion\\'',\n    '    \\'2005\\' \\'1247\\' \\'SS\\' \\'MRNrOfPatientOtherNames\\'',\n    '    \\'2005\\' \\'1248\\' \\'SS\\' \\'MRNrOfReqRecipeOfResults\\'',\n    '    \\'2005\\' \\'1249\\' \\'SS\\' \\'MRNrOfSeriesOperatorsName\\'',\n    '    \\'2005\\' \\'1250\\' \\'SS\\' \\'MRNrOfSeriesPerfPhysiName\\'',\n    '    \\'2005\\' \\'1251\\' \\'SS\\' \\'MRNrOfStudyAdmittingDiagnosticDescr\\'',\n    '    \\'2005\\' \\'1252\\' \\'SS\\' \\'MRNrOfStudyPatientContrastAllergies\\'',\n    '    \\'2005\\' \\'1253\\' \\'SS\\' \\'MRNrOfStudyPatientMedicalAlerts\\'',\n    '    \\'2005\\' \\'1254\\' \\'SS\\' \\'MRNrOfStudyPhysiciansOfRecord\\'',\n    '    \\'2005\\' \\'1255\\' \\'SS\\' \\'MRNrOfStudyPhysiReadingStudy\\'',\n    '    \\'2005\\' \\'1325\\' \\'CS\\' \\'MRSpectroSIB0Correction\\'',\n    '    \\'2005\\' \\'1326\\' \\'FL\\' \\'MRSpectroB0EchoTopPosition\\'',\n    '    \\'2005\\' \\'1327\\' \\'CS\\' \\'MRSpectroComplexComponent\\'',\n    '    \\'2005\\' \\'1328\\' \\'CS\\' \\'MRSpectroDataOrigin\\'',\n    '    \\'2005\\' \\'1329\\' \\'FL\\' \\'MRSpectroEchoTopPosition\\'',\n    '    \\'2005\\' \\'1330\\' \\'CS\\' \\'MRInPlaneTransforms\\'',\n    '    \\'2005\\' \\'1331\\' \\'SS\\' \\'MRNumberOfSpectraAcquired\\'',\n    '    \\'2005\\' \\'1333\\' \\'FL\\' \\'MRPhaseEncodingEchoTopPositions\\'',\n    '    \\'2005\\' \\'1334\\' \\'CS\\' \\'MRPhysicalQuantityForChemicalShift\\'',\n    '    \\'2005\\' \\'1335\\' \\'CS\\' \\'MRPhysicalQuantitySpatial\\'',\n    '    \\'2005\\' \\'1336\\' \\'FL\\' \\'MRReferenceFrequency\\'',\n    '    \\'2005\\' \\'1337\\' \\'FL\\' \\'MRSampleOffset\\'',\n    '    \\'2005\\' \\'1338\\' \\'FL\\' \\'MRSamplePitch\\'',\n    '    \\'2005\\' \\'1339\\' \\'SS\\' \\'MRSearchIntervalForPeaks\\'',\n    '    \\'2005\\' \\'1340\\' \\'CS\\' \\'MRSignalDomainForChemicalShift\\'',\n    '    \\'2005\\' \\'1341\\' \\'CS\\' \\'MRSignalDomainSpatial\\'',\n    '    \\'2005\\' \\'1342\\' \\'CS\\' \\'MRSignalType\\'',\n    '    \\'2005\\' \\'1343\\' \\'CS\\' \\'MRSpectroAdditionalRotations\\'',\n    '    \\'2005\\' \\'1344\\' \\'SS\\' \\'MRSpectroDisplayRanges\\'',\n    '    \\'2005\\' \\'1345\\' \\'CS\\' \\'MRSpectroEchoAcquisition\\'',\n    '    \\'2005\\' \\'1346\\' \\'CS\\' \\'MRSpectroFrequencyUnit\\'',\n    '    \\'2005\\' \\'1347\\' \\'FL\\' \\'MRSpectroGamma\\'',\n    '    \\'2005\\' \\'1348\\' \\'CS\\' \\'MRSpectroHiddenLineRemoval\\'',\n    '    \\'2005\\' \\'1349\\' \\'FL\\' \\'MRSpectroHorizontalShift\\'',\n    '    \\'2005\\' \\'1350\\' \\'FL\\' \\'MRSpectroHorizontalWindow\\'',\n    '    \\'2005\\' \\'1351\\' \\'SS\\' \\'MRSpectroNumberOfDisplayRanges\\'',\n    '    \\'2005\\' \\'1352\\' \\'SS\\' \\'MRSpectroNumberOfEchoPulses\\'',\n    '    \\'2005\\' \\'1353\\' \\'LO\\' \\'MRSpectroProcessingHistory\\'',\n    '    \\'2005\\' \\'1354\\' \\'CS\\' \\'MRSpectroScanType\\'',\n    '    \\'2005\\' \\'1355\\' \\'FL\\' \\'MRSpectroSICSIntervals\\'',\n    '    \\'2005\\' \\'1356\\' \\'CS\\' \\'MRSpectroSIMode\\'',\n    '    \\'2005\\' \\'1357\\' \\'SS\\' \\'MRSpectroSpectralBW\\'',\n    '    \\'2005\\' \\'1358\\' \\'LO\\' \\'MRSpectroTitleLine\\'',\n    '    \\'2005\\' \\'1359\\' \\'FL\\' \\'MRSpectroTurboEchoSpacing\\'',\n    '    \\'2005\\' \\'1360\\' \\'FL\\' \\'MRSpectroVerticalShift\\'',\n    '    \\'2005\\' \\'1361\\' \\'FL\\' \\'MRSpectroVerticalWindow\\'',\n    '    \\'2005\\' \\'1362\\' \\'FL\\' \\'MRSpectroOffset\\'',\n    '    \\'2005\\' \\'1363\\' \\'FL\\' \\'MRSpectrumPitch\\'',\n    '    \\'2005\\' \\'1364\\' \\'CS\\' \\'MRVolumeSelection\\'',\n    '    \\'2005\\' \\'1370\\' \\'SS\\' \\'MRNoMixesSpectro\\'',\n    '    \\'2005\\' \\'1371\\' \\'SQ\\' \\'MRSeriesSPMix\\'',\n    '    \\'2005\\' \\'1381\\' \\'IS\\' \\'MRScanoGramSurveyNumberOfImages\\'',\n    '    \\'2005\\' \\'1382\\' \\'UL\\' \\'MRNumberOfProcedureCodes\\'',\n    '    \\'2005\\' \\'1390\\' \\'CS\\' \\'MRStackCoilFunction\\'',\n    '    \\'2005\\' \\'1392\\' \\'IS\\' \\'MRGeolinkID\\'',\n    '    \\'2005\\' \\'1393\\' \\'IS\\' \\'MRStationNo\\'',\n    '    \\'2005\\' \\'1396\\' \\'CS\\' \\'MRFlowImagesPresent\\'',\n    '    \\'2005\\' \\'1397\\' \\'LO\\' \\'AnatomicRegCodeValue\\'',\n    '    \\'2005\\' \\'1398\\' \\'CS\\' \\'MRMobiviewEnabled\\'',\n    '    \\'2005\\' \\'1399\\' \\'CS\\' \\'MRIViewBoldEnabled\\'',\n    '    \\'2005\\' \\'1400\\' \\'CS\\' \\'MRVolumeViewEnabled\\'',\n    '    \\'2005\\' \\'1401\\' \\'UL\\' \\'MRNumberOfStudyReference\\'',\n    '    \\'2005\\' \\'1402\\' \\'SQ\\' \\'SPSCode\\'',\n    '    \\'2005\\' \\'1403\\' \\'UL\\' \\'MRNumberOfSPSCodes\\'',\n    '    \\'2005\\' \\'1407\\' \\'SS\\' \\'MRNrOfSpecificCharacterSet\\'',\n    '    \\'2005\\' \\'1409\\' \\'DS\\' \\'RescaleInterceptOriginal\\'',\n    '    \\'2005\\' \\'140A\\' \\'DS\\' \\'RescaleSlopeOriginal\\'',\n    '    \\'2005\\' \\'140B\\' \\'LO\\' \\'RescaleTypeOriginal\\'',\n    '    \\'2005\\' \\'140E\\' \\'SQ\\' \\'PrivateSharedSq\\'',\n    '    \\'2005\\' \\'140F\\' \\'SQ\\' \\'PrivatePerFrameSq\\'',\n    '    \\'2005\\' \\'1411\\' \\'UI\\' \\'MFPrivateReferencedSOPInstanceUID\\'',\n    '    \\'2005\\' \\'1412\\' \\'IS\\' \\'MRImageDiffBValueNumber\\'',\n    '    \\'2005\\' \\'1413\\' \\'IS\\' \\'MRImageGradientOrientationNumber\\'',\n    '    \\'2005\\' \\'1414\\' \\'SL\\' \\'MRSeriesNrOfDiffBValues\\'',\n    '    \\'2005\\' \\'1415\\' \\'SL\\' \\'MRSeriesNrOfDiffGradOrients\\'',\n    '    \\'2005\\' \\'1416\\' \\'CS\\' \\'MRSeriesPlanMode\\'',\n    '    \\'2005\\' \\'1417\\' \\'FD\\' \\'B_matrix\\' % DiffusionBMatrix',\n    '    \\'2005\\' \\'1418\\' \\'CS\\' \\'PrivOperatingModeType\\'',\n    '    \\'2005\\' \\'1419\\' \\'CS\\' \\'PrivOperatingMode\\'',\n    '    \\'2005\\' \\'141A\\' \\'CS\\' \\'MRFatSaturationTechnique\\'',\n    '    \\'2005\\' \\'141B\\' \\'IS\\' \\'MRVersionNumberDeletedImages\\'',\n    '    \\'2005\\' \\'141C\\' \\'IS\\' \\'MRVersionNumberDeletedSpectra\\'',\n    '    \\'2005\\' \\'141D\\' \\'IS\\' \\'MRVersionNumberDeletedBlobsets\\'',\n    '    \\'2005\\' \\'1426\\' \\'CS\\' \\'ViewingHardcopyOnly\\'',\n    '    \\'2005\\' \\'1428\\' \\'SL\\' \\'MRSeriesNrOfLabelTypes\\'',\n    '    \\'2005\\' \\'142A\\' \\'CS\\' \\'ExamPrintStatus\\'',\n    '    \\'2005\\' \\'142B\\' \\'CS\\' \\'ExamExportStatus\\'',\n    '    \\'2005\\' \\'142C\\' \\'CS\\' \\'ExamStorageCommitStatus\\'',\n    '    \\'2005\\' \\'142D\\' \\'CS\\' \\'ExamMediaWriteStatus\\'',\n    '    \\'2005\\' \\'1432\\' \\'CS\\' \\'MRSeriesSafetyOverrideMode\\'',\n    '    \\'2005\\' \\'1435\\' \\'CS\\' \\'SpectroExamcard\\'',\n    '    \\'2005\\' \\'143A\\' \\'LT\\' \\'DataDictionaryContentsVersion\\'',\n    '    \\'2005\\' \\'143B\\' \\'CS\\' \\'MRIsCoilSurvey\\'',\n    '    \\'2005\\' \\'143C\\' \\'FL\\' \\'MRStackTablePosLong\\'',\n    '    \\'2005\\' \\'143D\\' \\'FL\\' \\'MRStackTablePosLat\\'',\n    '    \\'2005\\' \\'143E\\' \\'FL\\' \\'MRStackPosteriorCoilPos\\'',\n    '    \\'2005\\' \\'143F\\' \\'CS\\' \\'AIMDLimitsApplied\\'',\n    '    \\'2005\\' \\'1440\\' \\'FL\\' \\'AIMDHeadSARLimit\\'',\n    '    \\'2005\\' \\'1441\\' \\'FL\\' \\'AIMDWholeBodySARLimit\\'',\n    '    \\'2005\\' \\'1442\\' \\'FL\\' \\'AIMDB1RMSLimit\\'',\n    '    \\'2005\\' \\'1443\\' \\'FL\\' \\'AIMDdbDtLimit\\'',\n    '    \\'2005\\' \\'1444\\' \\'IS\\' \\'TFEFactor\\'',\n    '    \\'2005\\' \\'1445\\' \\'CS\\' \\'AttenuationCorrection\\'',\n    '    \\'2005\\' \\'1447\\' \\'FL\\' \\'PowerOptimization\\'',\n    '    \\'2005\\' \\'144A\\' \\'FL\\' \\'DataWindowDuration\\'',\n    '    \\'2005\\' \\'144B\\' \\'FL\\' \\'MixingTime\\'',\n    '    \\'2005\\' \\'144C\\' \\'FL\\' \\'FirstEchoTime\\'',\n    '    \\'2005\\' \\'144D\\' \\'CS\\' \\'IsB0Series\\'',\n    '    \\'2005\\' \\'144E\\' \\'CS\\' \\'IsB1Series\\'',\n    '    \\'2005\\' \\'144F\\' \\'CS\\' \\'VolumeSelect\\'',\n    '    \\'2005\\' \\'1450\\' \\'SS\\' \\'MRNrOfPatientOtherIDs\\'',\n    '    \\'2005\\' \\'1455\\' \\'FD\\' \\'ImageVelocityEncodingDirection\\'',\n    '    \\'2050\\' \\'0020\\' \\'CS\\' \\'PresentationLUTShape\\' }];',\n    '% elseif strncmpi(vendor, \\'OtherVendor\\', n)',\n    'end',\n    '',\n    'dict.tag = uint32(hex2dec(strcat(C(:,1), C(:,2))));',\n    'dict.vr = C(:,3); % for implicit VR and some problematic explicit VR',\n    'dict.name = C(:,4);',\n    '',\n    'if nargin>1 && ~isempty(flds) % use only provided fields',\n    '    flds = cellstr(flds);',\n    '    ind = false(size(dict.tag,1), 1);',\n    '    for i = 1:length(flds)',\n    '        ind = ind | strcmp(flds{i}, dict.name); % include duplicate',\n    '    end',\n    '    dict.fields = flds; % remember the requested fields',\n    '    dict.tag  = dict.tag(ind);',\n    '    dict.vr   = dict.vr(ind);',\n    '    dict.name = dict.name(ind);',\n    'end',\n    '',\n    '[dict.tag, ind] = unique(dict.tag); % sort by tag',\n    'dict.vr = dict.vr(ind);',\n    'dict.name = dict.name(ind);'\n  )\n\n  dicm_hdr <- c(\n    'function [s, info, dict] = dicm_hdr(fname, dict, iFrames)',\n    '% Return header of a dicom file in a struct.',\n    '% ',\n    '% [s, err] = dicm_hdr(dicomFileName, dict, iFrames);',\n    '% ',\n    '% The mandatory 1st input is the dicom file name. The optional 2nd input can be',\n    '% a dicom dict, which may have only part of the full dict. The partial dict can',\n    '% be returned by dict = dicm_dict(vendor, fieldNames). The use of partial dict',\n    '% may speed up header read considerably. See rename_dicm for example.',\n    '% ',\n    '% The optional 3rd intput is only needed for multi-frame dicom files. When there',\n    '% are many frames, it may be very slow to read all items in',\n    '% PerFrameFunctionalGroupsSequence for all frames. The 3rd input can be used to',\n    '% specify the frames to read. By default, items for only 1st, 2nd and last',\n    '% frames are read.',\n    '% ',\n    '% The optional 2nd output contains information in case of error, and will be',\n    '% empty if there is no error.',\n    '% ',\n    '% DICM_HDR is like dicominfo from Matlab, but is independent of Image Processing',\n    '% Toolbox. The limitation is it can deal with only little endian data for',\n    '% popular vendors. The advantage is that it decodes most private and shadow tags',\n    '% for Siemens, GE and Philips dicom, and runs faster, especially for partial',\n    '% header and multi-frame dicom.',\n    '% ',\n    '% This can also read Philips PAR file and AFNI HEAD file, and return needed',\n    '% fields for dicm2nii to convert into nifti.',\n    '% ',\n    '% See also DICM_DICT, DICM2NII, DICM_IMG, RENAME_DICM, SORT_DICM',\n    '',\n    '% The method used here:',\n    '% Check 4 bytes at 128 to make sure it is \\'DICM\\';',\n    '% Find PixelData; Get its location;',\n    '% Loop through each item:',\n    '%      Read tag: group and element, each 1 uint16;',\n    '%        Find name in dictionary by the tag; if not exists,',\n    '%        assign it as Private_xxxx_xxxx;',\n    '%      Get VR:',\n    '%        Read VR (2 char) if explicit VR; ',\n    '%        Get VR from dict if implicit;',\n    '%      Decode item length type:',\n    '%        implicit VR, always uint32;',\n    '%        explicit VR: uint16/uint32(skip 2 bytes) based on VR; ',\n    '%      Decode data type by VR;',\n    '%      if VR == \\'SQ\\', deal in special way;',\n    '%      Read the item according to the length and data type;',\n    '%        Process the item if needed;',\n    '%      Assign to field.',\n    '',\n    '% History (yymmdd):',\n    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com).',\n    '% 130912 Extend private tags, automatically detect vendor.',\n    '% 130923 Call philips_par, so make dicm2nii easier. ',\n    '% 131001 Decode SQ, useful for multiframe dicom and Philips Stack. ',\n    '% 131008 Load then typecast. Faster than multiple fread.',\n    '% 131009 Work for implicit VR.',\n    '% 131010 Decode Siemens CSA header (slow), so it is human readable.',\n    '% 131019 PAR file: read image col labels, and use it for indexing.',\n    '% 131023 Implement afni_hdr.',\n    '% 131102 Use last tag for partial hdr, so return if it is non-exist fld.',\n    '% 131107 Search tags if only a few fields: faster than regular way.',\n    '% 131114 Add 3rd input: only 1,2,last frames hdr read. 0.4 vs 38 seconds!',\n    '%        Store needed fields in LastFile for PAR MIXED image type.',\n    '% 140123 Support dicom without meta info (thanks Paul).',\n    '% 140213 afni_head: IJK_TO_DICOM_REAL replaces IJK_TO_DICOM.',\n    '% 140502 philips_par: don\\'t use FOV for PixelSpacing and SpacingBetweenSlices.',\n    '% 140506 philips_par: use PAR file name as SeriesDescription.',\n    '% 140512 decode GE ProtocolDataBlock (gz compressed).',\n    '% 140611 No re-do if there are <16 extra bytes after image data.',\n    '% 140724 Ignore PAR/HEAD ext case; fix philips_par: Patient Position.',\n    '% 140924 Use dict VR if VR==OB/UN (thx Macro R). Could be bad in theory.',\n    '% 141006 philips_par: take care of char(13 10) issue (thx Hye).',\n    '% 141021 Store fields in dict, so it can be used for changed vendor.',\n    '% 141023 checkManufacturer for fast search approach too.',\n    '% 141128 Minor tweaks (len-1 in read_csa) for Octave 3.8.1.',\n    '% 150114 Siemens CSA str is not always len=1. Fix it (runs slower).',\n    '% 150128 Use memory gunzip for GE ProtocolDataBlock (0.5 vs 43 ms).',\n    '% 150222 philips_par: fix slice dir in R using \\'image offcentre\\';',\n    '%        Avoid repeatedly reading .REC .BRIK file for hdr. ',\n    '% 150227 Avoid error due to empty file (thx Kushal).',\n    '% 150316 Avoid error due to empty item dat for search method (thx VG).',\n    '% 150324 philips_par/afni_head: make up SeriesInstanceUID for dicm2nii.',\n    '% 150405 Implement bv_file to read non-transformed BV fmr/vmr/dmr.',\n    '% 150504 bv_file: fix multiple STCdata; bug fix for VMRData.',\n    '% 150513 return dict as 3rd output for dicm2nii in case of vendor change.',\n    '% 150517 fix manufacturer check problem for Octave: no re-read.',\n    '% 150522 PerFrameSQ ind: fix the case if numel(ind)~=nFrame.',\n    '% 150526 read_sq: use ItemDelimitationItem instead of empty dat1 as SQ end.',\n    '',\n    'persistent dict_full;',\n    's = []; info = \\'\\';',\n    'fullHdr = false;',\n    'if nargin<2 || isempty(dict)',\n    '    if isempty(dict_full), dict_full = dicm_dict; end',\n    '    fullHdr = true;',\n    '    dict = dict_full; ',\n    'end',\n    'if nargin<3, iFrames = []; end',\n    '',\n    'fid = fopen(fname);',\n    'if fid<0, info = [\\'File not exists: \\' fname]; return; end',\n    'cln = onCleanup(@() fclose(fid));',\n    'empty = fseek(fid, 128, -1);',\n    'if empty',\n    '    info = [\\'Invalid file: \\' fname];',\n    '    return;',\n    'end',\n    'sig = fread(fid, 4, \\'*char\\')\\';',\n    'isDicm = strcmp(sig, \\'DICM\\');',\n    'isTruncated = false;',\n    'if ~isDicm',\n    '    fseek(fid, 0, -1);',\n    '    a = fread(fid, 1, \\'uint16\\');',\n    '    if a==2 || a==8 % not safe, but no better way',\n    '        fseek(fid, 0, -1);',\n    '        isTruncated = true;',\n    '    end',\n    'end',\n    'if ~isDicm && ~isTruncated % may be PAR or HEAD file',\n    '    [~, ~, ext] = fileparts(fname);',\n    '    try',\n    '        if strcmpi(ext, \\'.PAR\\') % || strcmpi(ext, \\'.REC\\')',\n    '            [s, info] = philips_par(fname);',\n    '        elseif strcmpi(ext, \\'.HEAD\\') % || strcmpi(ext, \\'.BRIK\\')',\n    '            [s, info] = afni_head(fname);',\n    '        elseif any(strcmpi(ext, {\\'.vmr\\' \\'.fmr\\' \\'.dmr\\'})) % BrainVoyager',\n    '            [s, info] = bv_file(fname);',\n    '        else',\n    '            info = [\\'Unknown file type: \\' fname];',\n    '            return;',\n    '        end',\n    '    catch me',\n    '        info = me.message;',\n    '        return;',\n    '    end',\n    '    if ~isempty(s), return; end',\n    '    if isempty(info), info = [\\'Not dicom file: \\' fname]; end',\n    '    return; ',\n    'end',\n    '',\n    '% This is the trick to make partial hdr faster.',\n    'b = [];',\n    'tag_7fe00010 = char([224 127 16 0]); % PixelData, can\\'t add VR',\n    'for nb = [120000 2e6 20e6 Inf] % if not enough, read more',\n    '    b = [b fread(fid, nb, \\'*uint8\\')\\']; %#ok',\n    '    allRead = feof(fid);',\n    '    i = strfind(char(b), tag_7fe00010);',\n    '    if ~isempty(i)',\n    '        break;',\n    '    elseif allRead',\n    '        % i = strfind(char(b), char([225 127 16 16])); % DTI tensor file',\n    '        % if ~isempty(i), break; end',\n    '        i = strfind(char(b), char([127 224 0 16]));',\n    '        if isempty(i)',\n    '            info = [\\'No PixelData in \\' fname]; ',\n    '        else',\n    '            info = [\\'Likely big-endian file (not supported): \\' fname]; ',\n    '        end',\n    '        return; ',\n    '    end',\n    'end',\n    's.Filename = fopen(fid);',\n    '',\n    '% iPixelData could be in header or data. Using full hdr can correct this',\n    'iPixelData = i(end); % start of PixelData tag with 132 offset',\n    'b = typecast(b, \\'uint16\\'); % hope this makes the code faster',\n    '',\n    'i = 1; len = numel(b)-6; % 6 less avoid missing next tag',\n    'expl = false; explVR = false; % default for truncated dicom',\n    'toSearch = numel(dict.tag) < 10;',\n    '',\n    'if toSearch % search each tag if only a few fields',\n    '    b8 = char(typecast(b, \\'uint8\\'));',\n    '    tg = char([2 0 16 0 \\'UI\\']); % TransferSyntaxUID',\n    '    i = (strfind(b8, tg)+1) / 2; % i for uint16',\n    '    if ~isempty(i) % empty for truncated ',\n    '        [dat, name] = read_item(i(1));',\n    '        s.(name) = dat;',\n    '        expl = ~strcmp(dat, \\'1.2.840.10008.1.2\\');',\n    '    end',\n    '    for k = 1:numel(dict.tag)',\n    '        tg = char(typecast(dict.tag(k), \\'uint8\\'));',\n    '        tg = tg([3 4 1 2]);',\n    '        i = (strfind(b8, tg)+1) / 2;',\n    '        if isempty(i), continue;',\n    '        elseif numel(i)>1 % +1 tags found. use non-search method',\n    '            if expl, tg = [tg uint8(dict.vr{k})]; end %#ok add vr',\n    '            i = (strfind(b8, tg)+1) / 2;',\n    '            if isempty(i), continue;',\n    '            elseif numel(i)>1 % +1 tags found. use non-search method',\n    '                i = 1;',\n    '                toSearch = false;',\n    '                break; % re-do in regular way',\n    '            end',\n    '        end',\n    '        [dat, name, info] = read_item(i);',\n    '        if isnumeric(name) || isempty(dat), continue; end',\n    '        s.(name) = dat;',\n    '        if strcmp(name, \\'Manufacturer\\') && ~strncmpi(dat, dict.vendor, 2)',\n    '            updateManufacturer(dat);',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'while ~toSearch',\n    '    if i>=len',\n    '        if strcmp(name, \\'PixelData\\') % if PixelData in SQ/data was caught',\n    '            iPixelData = iPre*2-1; % start of PixelData tag in bytes',\n    '            break; % done',\n    '        end',\n    '        if allRead',\n    '            info = [\\'End of file reached: likely error: \\' s.Filename];  ',\n    '            break; % give up',\n    '        else % in case PixelData in SQ was caught',\n    '            b = [b fread(fid, inf, \\'*uint16\\')\\']; %#ok read all',\n    '            len = numel(b)-6; % update length',\n    '            i = iPre; % re-do the previous item',\n    '            allRead = true;',\n    '        end',\n    '    end',\n    '    iPre = i; % backup it, also useful for PixelData',\n    '    ',\n    '    [dat, name, info, i, tg] = read_item(i);',\n    '    if ~fullHdr && tg>dict.tag(end), break; end % done for partial hdr',\n    '    if strncmp(info, \\'Given up\\', 8), break; end',\n    '    if isnumeric(name) || isempty(dat), continue; end',\n    '    s.(name) = dat;',\n    '    if strcmp(name, \\'Manufacturer\\') && ~strncmpi(dat, dict.vendor, 2)',\n    '        updateManufacturer(dat);',\n    '    end',\n    '    if strcmp(name, \\'TransferSyntaxUID\\')',\n    '        expl = ~strcmp(dat, \\'1.2.840.10008.1.2\\'); % may be wrong for some',\n    '    end',\n    'end',\n    '',\n    'i = (iPixelData+1) / 2; % start of PixelData tag in b (uint16)',\n    'if isTruncated',\n    '    iPixelData = iPixelData +   7; i=i+2;',\n    'elseif explVR',\n    '    % s.PixelData.VR = char(typecast(b(i+2), \\'uint8\\'));',\n    '    iPixelData = iPixelData + 143; i=i+4; % extra vr(2) + pad(2) than implicitVR',\n    'else',\n    '    iPixelData = iPixelData + 139; i=i+2;',\n    'end',\n    's.PixelData.Start = uint32(iPixelData);',\n    's.PixelData.Bytes = typecast(b(i+(0:1)), \\'uint32\\');',\n    '',\n    '% if iPixelData is not right, re-do with full header',\n    'if ~fullHdr',\n    '    fseek(fid, 0, 1); % end of file',\n    '    if ftell(fid)-s.PixelData.Start-s.PixelData.Bytes > 15 % ==0 is too strict',\n    '        [s, info] = dicm_hdr(fname, [], iFrames); % full hdr',\n    '        return;',\n    '    end',\n    'end',\n    '',\n    'if isfield(s, \\'CSAImageHeaderInfo\\') % Siemens CSA image header (slow)',\n    '    s.CSAImageHeaderInfo = read_csa(s.CSAImageHeaderInfo);',\n    'end',\n    'if isfield(s, \\'CSASeriesHeaderInfo\\') % series header',\n    '    s.CSASeriesHeaderInfo = read_csa(s.CSASeriesHeaderInfo);',\n    'end',\n    'if isfield(s, \\'ProtocolDataBlock\\') % GE',\n    '    s.ProtocolDataBlock = read_ProtocolDataBlock(s.ProtocolDataBlock);',\n    'end',\n    'return;',\n    '',\n    '% Nested function: read dicom item. Called by dicm_hdr and read_sq',\n    'function [dat, name, info, i, tag] = read_item(i)',\n    'persistent len16 chDat;',\n    'if isempty(len16)',\n    '    len16 = \\'AE AS AT CS DA DS DT FD FL IS LO LT PN SH SL SS ST TM UI UL US\\';',\n    '    chDat = \\'AE AS CS DA DS DT IS LO LT PN SH ST TM UI UT\\';',\n    'end',\n    'dat = []; name = nan; info = \\'\\'; ',\n    'vr = \\'CS\\'; % CS for Manufacturer and TransferSyntaxUID',\n    '',\n    'group = b(i); i=i+1;',\n    'elmnt = b(i); i=i+1;',\n    'tag = uint32(group)*65536 + uint32(elmnt);',\n    'if tag == 4294893581 %|| tag == 4294893789 % FFFE E00D ItemDelimitationItem',\n    '    i = i+2; % skip length, in case there is another SQ Item',\n    '    name = \\'\\';',\n    '    return;',\n    'end',\n    '',\n    'explVR = expl || group==2;',\n    'if explVR, vr = char(typecast(b(i), \\'uint8\\')); i=i+1; end % 2-byte VR',\n    '',\n    'if ~explVR % implicit, length irrevalent to VR',\n    '    n = typecast(b(i+(0:1)), \\'uint32\\'); i=i+2;',\n    'elseif ~isempty(strfind(len16, vr)) % data length in uint16',\n    '    n = b(i); i=i+1;',\n    'else % length in uint32: skip 2 bytes',\n    '    n = typecast(b(i+(1:2)), \\'uint32\\'); i=i+3;',\n    'end',\n    'if n<1, return; end % empty val',\n    '',\n    '% Look up item name in dictionary',\n    'n = double(n)/2;',\n    'ind = find(dict.tag == tag, 1);',\n    'if ~isempty(ind)',\n    '    name = dict.name{ind};',\n    '    if strcmp(vr, \\'UN\\') || strcmp(vr, \\'OB\\') || ~explVR, vr = dict.vr{ind}; end',\n    'elseif tag==524400 % in case not in dict',\n    '    name = \\'Manufacturer\\';',\n    'elseif tag==131088 % can\\'t skip TransferSyntaxUID even if not in dict',\n    '    name = \\'TransferSyntaxUID\\';',\n    'elseif fullHdr',\n    '    if elmnt==0, i=i+n; return; end % skip GroupLength',\n    '    if mod(group, 2), name = sprintf(\\'Private_%04x_%04x\\', group, elmnt);',\n    '    else              name = sprintf(\\'Unknown_%04x_%04x\\', group, elmnt);',\n    '    end',\n    '    if ~explVR, vr = \\'UN\\'; end',\n    'elseif n<2147483647.5 % no skip for SQ with length 0xffffffff',\n    '    i=i+n; return;',\n    'end',\n    '% compressed PixelData, n can be 0xffffffff',\n    'if ~explVR && n==2147483647.5, vr = \\'SQ\\'; end % best guess',\n    'if (n+i>len) && (~strcmp(vr, \\'SQ\\')), i = i+n; return; end % re-do',\n    '% fprintf(\\'(%04x %04x) %s %g %s\\\\n\\', group, elmnt, vr, n*2, name);',\n    '',\n    '% Decode data length and type of an item by VR',\n    'if ~isempty(strfind(chDat, vr)) % char data',\n    '    dat = deblank(char(typecast(b(i+(0:n-1)), \\'uint8\\'))); i=i+n;',\n    '    if strcmp(vr, \\'DS\\') || strcmp(vr, \\'IS\\')',\n    '        dat = sscanf(dat, \\'%f%*c\\'); % like 1\\\\2\\\\3',\n    '    end',\n    'elseif strcmp(vr, \\'SQ\\')',\n    '    isPerFrameSQ = strcmp(name, \\'PerFrameFunctionalGroupsSequence\\');',\n    '    [dat, info, i] = read_sq(i, min(i+n,len), isPerFrameSQ);',\n    'else % numeric data, or UN',\n    '    fmt = vr2format(vr);',\n    '    if isempty(fmt)',\n    '        info = sprintf(\\'Given up: Invalid VR (%d %d) for %s\\', vr, name);',\n    '        fprintf(2, \\' %s\\\\n\\', info);',\n    '    else',\n    '        dat = typecast(b(i+(0:n-1)), fmt)\\'; i=i+n;',\n    '    end',\n    'end',\n    'end % nested func',\n    '',\n    '% Nested function: decode SQ, called by read_item (recursively)',\n    'function [rst, info, i] = read_sq(i, nEnd, isPerFrameSQ)',\n    'rst = []; info = \\'\\'; j = 0; % j is frame index',\n    '',\n    'while i<nEnd',\n    '    tag = typecast(b(i+(0:1)), \\'uint32\\'); i=i+2;',\n    '    n = typecast(b(i+(0:1)), \\'uint32\\'); i=i+2; % n may be 0xffff ffff',\n    '    if tag ~= 3758161918, return; end % only do FFFE E000, Item',\n    '    if isPerFrameSQ && ~ischar(iFrames)',\n    '        if j==0, i0 = i; j = 1; % always read 1st frame',\n    '        elseif j==1 % always read 2nd frame, and find ind for all frames',\n    '            j = 2; iItem = 2;',\n    '            tag1 = char(typecast(tag1, \\'uint8\\'));',\n    '            tag1 = tag1([3 4 1 2]);',\n    '            ind = strfind(char(typecast(b(i0:(iPixelData+1)/2), \\'uint8\\')), tag1);',\n    '            ind = (ind-1)/2 + i0;',\n    '            nInd = numel(ind);',\n    '            if isfield(s, \\'NumberOfFrames\\') && nInd~=s.NumberOfFrames',\n    '                tag1PerF = nInd / s.NumberOfFrames;',\n    '                if mod(tag1PerF, 1)>0 % not integer, read all frames',\n    '                    iFrames = \\'all\\'; rst = []; j = 0; i = i0-4; % re-do the SQ',\n    '                    fprintf(2, [\\'Failed to determine indice for frames. \\' ...',\n    '                        \\'Will read all frames.\\\\nFile: %s\\\\n\\'], s.Filename);',\n    '                    continue;',\n    '                elseif tag1PerF>1 % more than one ind for each frame',\n    '                    ind = ind(1:tag1PerF:nInd);',\n    '                    nInd = s.NumberOfFrames;',\n    '                end',\n    '            end',\n    '            iFrames = unique([1 2 round(iFrames) nInd]);',\n    '        else',\n    '            iItem = iItem + 1;',\n    '            j = iFrames(iItem);',\n    '            i = ind(j); % start of tag1 for a frame',\n    '        end',\n    '    else',\n    '        j = j + 1;',\n    '    end',\n    '    ',\n    '    Item_n = sprintf(\\'Item_%g\\', j);',\n    '    n = min(i+double(n)/2, nEnd);',\n    '    ',\n    '    while i<n',\n    '        [dat1, name1, info, i, tag] = read_item(i);',\n    '        if isnumeric(name1), continue; end % 0-length or skipped item',\n    '        if tag == 4294893581, break; end % FFFE E00D ItemDelimitationItem',\n    '        if isempty(dat1), continue; end',\n    '        if isempty(rst), tag1 = tag; end % first wanted tag in SQ',\n    '        rst.(Item_n).(name1) = dat1;',\n    '    end',\n    'end',\n    'end % nested func',\n    '',\n    'function updateManufacturer(vendor)',\n    '    dict_full = dicm_dict(vendor); % update vendor',\n    '    if ~fullHdr && isfield(dict, \\'fields\\')',\n    '        dict = dicm_dict(vendor, dict.fields);',\n    '    else',\n    '        dict = dict_full;',\n    '    end',\n    'end',\n    '',\n    'end % main func',\n    '',\n    '% subfunction: return format str for typecast according to VR',\n    'function fmt = vr2format(vr)',\n    'switch vr ',\n    '    case \\'OB\\', fmt = \\'uint8\\';',\n    '    case \\'UN\\', fmt = \\'uint8\\';',\n    '    case \\'AT\\', fmt = \\'uint16\\';',\n    '    case \\'OW\\', fmt = \\'uint16\\';',\n    '    case \\'US\\', fmt = \\'uint16\\';',\n    '    case \\'SS\\', fmt = \\'int16\\'; ',\n    '    case \\'UL\\', fmt = \\'uint32\\';',\n    '    case \\'SL\\', fmt = \\'int32\\';',\n    '    case \\'FL\\', fmt = \\'single\\'; ',\n    '    case \\'FD\\', fmt = \\'double\\';',\n    '    otherwise, fmt = \\'\\';',\n    'end',\n    'end',\n    '',\n    '% subfunction: decode Siemens CSA image and series header',\n    'function csa = read_csa(csa)',\n    'b = csa\\';',\n    'if ~strcmp(char(b(1:4)), \\'SV10\\'), return; end % no op if not SV10',\n    'chDat = \\'AE AS CS DA DT LO LT PN SH ST TM UI UN UT\\';',\n    'i = 8; % \\'SV10\\' 4 3 2 1',\n    'try %#ok in case of error, we return the original uint8',\n    '    nField = typecast(b(i+(1:4)), \\'uint32\\'); i=i+8;',\n    '    for j = 1:nField',\n    '        i=i+68; % name(64) and vm(4)',\n    '        vr = char(b(i+(1:2))); i=i+8; % vr(4), syngodt(4)',\n    '        n = typecast(b(i+(1:4)), \\'int32\\'); i=i+8;',\n    '        if n<1, continue; end % skip name decoding, faster',\n    '        ind = find(b(i-84+(1:64))==0, 1) - 1;',\n    '        name = char(b(i-84+(1:ind)));',\n    '        % fprintf(\\'%s %3g %s\\\\n\\', vr, n, name);',\n    '',\n    '        dat = [];',\n    '        for k = 1:n % n is often 6, but often only the first contains value',\n    '            len = typecast(b(i+(1:4)), \\'int32\\'); i=i+16;',\n    '            if len<1, i = i+double(n-k)*16; break; end % rest are empty too',\n    '            foo = char(b(i+(1:len-1))); % exclude nul, need for Octave',\n    '            i = i + ceil(double(len)/4)*4; % multiple 4-byte',\n    '            if isempty(strfind(chDat, vr))',\n    '                tmp = str2double(foo);',\n    '                if isnan(tmp), continue; end',\n    '                dat(end+1, 1) = tmp; %#ok numeric to double',\n    '            else',\n    '                dat{end+1, 1} = deblank(foo); %#ok',\n    '            end',\n    '        end',\n    '        if iscellstr(dat) && length(dat)<2, dat = dat{1}; end',\n    '        if ~isempty(dat), rst.(name) = dat; end',\n    '    end',\n    '    csa = rst;',\n    'end',\n    'end',\n    '',\n    '% subfunction: decode GE ProtocolDataBlock',\n    'function ch = read_ProtocolDataBlock(ch)',\n    'n = typecast(ch(1:4), \\'int32\\') + 4; % nBytes, zeros may be padded to make 4x',\n    'if ~all(ch(5:6) == [31 139]\\') || n>numel(ch), return; end % gz signature',\n    '',\n    'b = gunzip_mem(ch(5:n));',\n    'if isempty(b), return; end % guzip faild, we give up',\n    'b = char(b\\');',\n    '',\n    'try %#ok',\n    '    i = 1; n = numel(b);',\n    '    while i<n',\n    '        nam = strtok(b(i:n), \\' \"\\'); i = i + numel(nam) + 2; % VIEWORDER \"1\"',\n    '        val = strtok(b(i:n),  \\'\"\\'); i = i + numel(val) + 2;',\n    '        if strcmp(val(end), \\';\\'), val(end) = []; end',\n    '        foo = str2double(val);',\n    '        if ~isnan(foo), val = foo; end % convert into num if possible',\n    '        rst.(nam) = val;',\n    '    end',\n    '    ch = rst;',\n    'end',\n    'end',\n    '',\n    '%% subfunction: read PAR file, return struct like that from dicm_hdr.',\n    'function [s, err] = philips_par(fname)',\n    'err = \\'\\';',\n    'if numel(fname)>4 && strcmpi(fname(end+(-3:0)), \\'.REC\\')',\n    '    fname(end+(-3:0)) = \\'.PAR\\';',\n    '    if ~exist(fname, \\'file\\'), fname(end+(-3:0)) = \\'.par\\'; end',\n    'end',\n    'fid = fopen(fname);',\n    'if fid<0, s = []; err = [\\'File not exist: \\' fname]; return; end',\n    'str = fread(fid, inf, \\'*char\\')\\'; % read all as char',\n    'fname = fopen(fid); % name with full path',\n    'fclose(fid);',\n    '',\n    'str = strrep(str, char(13), char(10)); % make carriage return single char(10)',\n    'while true',\n    '    ind = strfind(str, char([10 10]));',\n    '    if isempty(ind), break; end',\n    '    str(ind) = []; ',\n    'end',\n    '',\n    '% In V4, offcentre and Angulation labeled as y z x, but actually x y z. We',\n    '% try not to use these info',\n    'key = \\'image export tool\\';',\n    'i = strfind(lower(str), key) + numel(key);',\n    'if isempty(i), err = \\'Not PAR file\\'; s = []; return; end',\n    'C = textscan(str(i:end), \\'%s\\', 1);',\n    's.SoftwareVersion = C{1}{1};',\n    'if strncmpi(s.SoftwareVersion, \\'V3\\', 2)',\n    '    err = \\'V3 PAR file is not supported\\';',\n    '    fprintf(2, \\' %s.\\\\n\\', err);',\n    '    s = []; return;',\n    'end',\n    '',\n    '% s.IsPhilipsPAR = true;',\n    's.PatientName = par_key(\\'Patient name\\', \\'%c\\');',\n    's.StudyDescription = par_key(\\'Examination name\\', \\'%c\\');',\n    '[pth, nam] = fileparts(fname);',\n    's.SeriesDescription = nam;',\n    's.ProtocolName = par_key(\\'Protocol name\\', \\'%c\\');',\n    'foo = par_key(\\'Examination date/time\\', \\'%s\\');',\n    'foo = foo(isstrprop(foo, \\'digit\\'));',\n    's.AcquisitionDateTime = foo;',\n    '% s.SeriesType = strkey(str, \\'Series Type\\', \\'%c\\');',\n    's.SeriesNumber = par_key(\\'Acquisition nr\\');',\n    's.SeriesInstanceUID = sprintf(\\'%g.%s.%09.0f\\', s.SeriesNumber, ...',\n    '    datestr(now, \\'yymmdd.HHMMSS.fff\\'), rand*1e9);',\n    '% s.SamplesPerPixel = 1; % make dicm2nii.m happy',\n    '% s.ReconstructionNumberMR = strkey(str, \\'Reconstruction nr\\', \\'%g\\');',\n    '% s.MRSeriesScanDuration = strkey(str, \\'Scan Duration\\', \\'%g\\');',\n    's.NumberOfEchoes = par_key(\\'Max. number of echoes\\');',\n    'nSL = par_key(\\'Max. number of slices/locations\\');',\n    's.LocationsInAcquisition = nSL;',\n    's.NumberOfTemporalPositions = par_key(\\'Max. number of dynamics\\');',\n    'foo = par_key(\\'Patient position\\', \\'%c\\');',\n    'if isempty(foo), foo = par_key(\\'Patient Position\\', \\'%c\\'); end',\n    'if ~isempty(foo)',\n    '    if numel(foo)>4, s.PatientPosition = foo(regexp(foo, \\'\\\\<.\\')); ',\n    '    else s.PatientPosition = foo; ',\n    '    end',\n    'end',\n    's.MRAcquisitionType = par_key(\\'Scan mode\\', \\'%s\\');',\n    's.ScanningSequence = par_key(\\'Technique\\', \\'%s\\'); % ScanningTechnique',\n    's.ImageType = [\\'PhilipsPAR\\\\\\' s.ScanningSequence];',\n    '% foo = strkey(str, \\'Scan resolution\\', \\'%g\\'); % before reconstruction',\n    '% s.AcquisitionMatrix = [foo(1) 0 0 foo(2)]\\'; % depend on slice ori',\n    's.RepetitionTime = par_key(\\'Repetition time\\');',\n    '% FOV = par_key(\\'FOV\\'); % (ap,fh,rl) [mm] ',\n    '% FOV = FOV([3 1 2]); % x y z',\n    's.WaterFatShift = par_key(\\'Water Fat shift\\');',\n    'rotAngle = par_key(\\'Angulation midslice\\'); % (ap,fh,rl) deg',\n    'rotAngle = rotAngle([3 1 2]);',\n    'posMid = par_key(\\'Off Centre midslice\\'); % (ap,fh,rl) [mm]',\n    's.Stack.Item_1.MRStackOffcentreAP = posMid(1);',\n    's.Stack.Item_1.MRStackOffcentreFH = posMid(2);',\n    's.Stack.Item_1.MRStackOffcentreRL = posMid(3);',\n    'posMid = posMid([3 1 2]); % better precision than those in the table',\n    'if par_key(\\'MTC\\') % motion correction?',\n    '    s.ImageType = [s.ImageType \\'\\\\MOCO\\\\\\'];',\n    'end',\n    's.EPIFactor = par_key(\\'EPI factor\\');',\n    '% s.DynamicSeries = strkey(str, \\'Dynamic scan\\', \\'%g\\'); % 0 or 1',\n    'isDTI = par_key(\\'Diffusion\\')>0;',\n    'if isDTI',\n    '    s.ImageType = [s.ImageType \\'\\\\DIFFUSION\\\\\\'];',\n    '    s.DiffusionEchoTime = par_key(\\'Diffusion echo time\\'); % ms',\n    'end',\n    '',\n    'foo = par_key(\\'Preparation direction\\', \\'%s\\'); % Anterior-Posterior',\n    'if ~isempty(foo)',\n    '    foo = foo(regexp(foo, \\'\\\\<.\\')); % \\'AP\\'',\n    '    s.Stack.Item_1.MRStackPreparationDirection = foo;',\n    '    iPhase = strfind(\\'LRAPFH\\', foo(1));',\n    '    iPhase = ceil(iPhase/2); % 1/2/3',\n    'end',\n    '',\n    '% Get list of para meaning for the table, and col index of each para',\n    'i1 = strfind(str, \\'= IMAGE INFORMATION DEFINITION =\\'); i1 = i1(end);',\n    'ind = strfind(str(i1:end), [char(10) \\'#\\']) + i1;',\n    'for i = 1:9 % find the empty line before column descrip',\n    '    [~, foo] = strtok(str(ind(i):ind(i+1)-2)); % remove # and char(10)',\n    '    if isempty(foo), break; end ',\n    'end',\n    'j = 1; ',\n    'for i = i+1:numel(ind)',\n    '    [~, foo] = strtok(str(ind(i):ind(i+1)-2));',\n    '    if isempty(foo), break; end % the end of the col label',\n    '    foo = strtrim(foo);',\n    '    i3 = strfind(foo, \\'<\\');',\n    '    i2 = strfind(foo, \\'(\\');',\n    '    if isempty(i3), i3 = i2(1); end',\n    '    colLabel{j} = strtrim(foo(1:i3(1)-1)); %#ok para name',\n    '    nCol = sscanf(foo(i2(end)+1:end), \\'%g\\');',\n    '    if isempty(nCol), nCol = 1; end',\n    '    iColumn(j) = nCol; %#ok number of columns in the table for this para',\n    '    j = j + 1;',\n    'end',\n    'iColumn = cumsum([1 iColumn]); % col start ind for corresponding colLabel',\n    'keyInLabel = @(key)strcmp(colLabel, key);',\n    'colIndex = @(key)iColumn(keyInLabel(key));',\n    '',\n    'i1 = strfind(str, \\'= IMAGE INFORMATION =\\'); i1 = i1(end);',\n    'ind = strfind(str(i1:end), char(10)) + i1 + 1; % start of a line',\n    'for i = 1:9',\n    '    foo = sscanf(str(ind(i):end), \\'%g\\', 1);',\n    '    if ~isempty(foo), break; end % get the first number',\n    'end',\n    'while str(ind(i))==10, i = i+1; end % skip empty lines (only one)',\n    'str = str(ind(i):end); % now start of the table',\n    'i1 = strfind(str, char(10));',\n    'para = sscanf(str(1:i1(1)), \\'%g\\'); % 1st row',\n    'n = numel(para); % number of items each row, 41 for V4',\n    'para = sscanf(str, \\'%g\\'); % read all numbers',\n    'nImg = floor(numel(para) / n); ',\n    'para = reshape(para(1:n*nImg), n, nImg)\\'; % whole table now',\n    's.NumberOfFrames = nImg;',\n    '',\n    's.Dim3IsVolume = (diff(para(1:2, colIndex(\\'slice number\\'))) == 0);',\n    'if s.Dim3IsVolume, iVol = 1:(nImg/nSL);',\n    'else iVol = 1:nSL:nImg;',\n    'end',\n    '',\n    'imgType = para(iVol, colIndex(\\'image_type_mr\\')); % 0 mag; 3, phase?',\n    'if any(diff(imgType) ~= 0) % more than 1 type of image',\n    '    s.ComplexImageComponent = \\'MIXED\\';',\n    '    s.VolumeIsPhase = (imgType==3); % one for each vol',\n    '    s.LastFile.RescaleIntercept = para(end, colIndex(\\'rescale intercept\\'));',\n    '    s.LastFile.RescaleSlope = para(end, colIndex(\\'rescale slope\\'));',\n    'elseif imgType(1)==0, s.ComplexImageComponent = \\'MAGNITUDE\\';',\n    'elseif imgType(1)==3, s.ComplexImageComponent = \\'PHASE\\';',\n    'end',\n    '',\n    '% These columns should be the same for all images: ',\n    'cols = {\\'image pixel size\\' \\'recon resolution\\' \\'image angulation\\' ...',\n    '    \\'slice thickness\\' \\'slice gap\\' \\'slice orientation\\' \\'pixel spacing\\'};',\n    'if ~strcmp(s.ComplexImageComponent, \\'MIXED\\')',\n    '    cols = [cols {\\'rescale intercept\\' \\'rescale slope\\'}];',\n    'end',\n    'ind = [];',\n    'for i = 1:numel(cols)',\n    '    j = find(keyInLabel(cols{i}));',\n    '    if isempty(j), continue; end',\n    '    ind = [ind iColumn(j):iColumn(j+1)-1]; %#ok',\n    'end',\n    'foo = para(:, ind);',\n    'foo = abs(diff(foo));',\n    'if any(foo(:) > 1e-5)',\n    '    err = sprintf(\\'Inconsistent image size, bits etc: %s\\', fname);',\n    '    fprintf(2, \\' %s. \\\\n\\', err);',\n    '    s = []; return;',\n    'end',\n    '',\n    '% getTableVal(\\'echo number\\', \\'EchoNumber\\', 1:nImg);',\n    '% getTableVal(\\'dynamic scan number\\', \\'TemporalPositionIdentifier\\', 1:nImg);',\n    'getTableVal(\\'image pixel size\\', \\'BitsAllocated\\');',\n    'getTableVal(\\'recon resolution\\', \\'Columns\\');',\n    's.Rows = s.Columns(2); s.Columns = s.Columns(1);',\n    'getTableVal(\\'rescale intercept\\', \\'RescaleIntercept\\');',\n    'getTableVal(\\'rescale slope\\', \\'RescaleSlope\\');',\n    'getTableVal(\\'window center\\', \\'WindowCenter\\', 1:nImg);',\n    'getTableVal(\\'window width\\', \\'WindowWidth\\', 1:nImg);',\n    'mx = max(s.WindowCenter + s.WindowWidth/2);',\n    'mn = min(s.WindowCenter - s.WindowWidth/2);',\n    's.WindowCenter = round((mx+mn)/2);',\n    's.WindowWidth = ceil(mx-mn);',\n    'getTableVal(\\'slice thickness\\', \\'SliceThickness\\');',\n    'getTableVal(\\'echo_time\\', \\'EchoTime\\');',\n    '% getTableVal(\\'dyn_scan_begin_time\\', \\'TimeOfAcquisition\\', 1:nImg);',\n    'if isDTI',\n    '    getTableVal(\\'diffusion_b_factor\\', \\'B_value\\', iVol);',\n    '    fld = \\'bvec_original\\';',\n    '    getTableVal(\\'diffusion\\', fld, iVol);',\n    '    if isfield(s, fld), s.(fld) = s.(fld)(:, [3 1 2]); end',\n    'end',\n    'getTableVal(\\'TURBO factor\\', \\'TurboFactor\\');',\n    '',\n    '% Rotation order and signs are figured out by try and err, not 100% sure',\n    'ca = cosd(rotAngle); sa = sind(rotAngle);',\n    'rx = [1 0 0; 0 ca(1) -sa(1); 0 sa(1) ca(1)]; % 3D rotation',\n    'ry = [ca(2) 0 sa(2); 0 1 0; -sa(2) 0 ca(2)];',\n    'rz = [ca(3) -sa(3) 0; sa(3) ca(3) 0; 0 0 1];',\n    'R = rx * ry * rz; % seems right for Philips',\n    '',\n    'getTableVal(\\'slice orientation\\', \\'SliceOrientation\\'); % 1/2/3 for TRA/SAG/COR',\n    'iOri = mod(s.SliceOrientation+1, 3) + 1; % [1 2 3] to [3 1 2]',\n    'if iOri == 1 % Sag',\n    '    s.SliceOrientation = \\'SAGITTAL\\';',\n    '    ixyz = [2 3 1];',\n    '    R(:,[1 3]) = -R(:,[1 3]); % change col sign according to iOri',\n    'elseif iOri == 2 % Cor',\n    '    s.SliceOrientation = \\'CORONAL\\';',\n    '    ixyz = [1 3 2];',\n    '    R(:,3) = -R(:,3);',\n    'else % Tra',\n    '    s.SliceOrientation = \\'TRANSVERSAL\\';',\n    '    ixyz = [1 2 3];',\n    'end',\n    '% bad precision for some PAR, \\'pixel spacing\\' and \\'slice gap\\', but it is wrong',\n    '% to use FOV, maybe due to partial Fourier?',\n    'getTableVal(\\'pixel spacing\\', \\'PixelSpacing\\');',\n    's.PixelSpacing = s.PixelSpacing(:);',\n    'getTableVal(\\'slice gap\\', \\'SpacingBetweenSlices\\');',\n    '',\n    's.SpacingBetweenSlices = s.SpacingBetweenSlices + s.SliceThickness;',\n    '% s.PixelSpacing = FOV(ixyz(1:2)) ./ [s.Columns s.Rows]\\';',\n    '% s.SpacingBetweenSlices = FOV(ixyz(3)) ./ nSL;',\n    '',\n    'if exist(\\'iPhase\\', \\'var\\')',\n    '    foo = \\'COL\\';',\n    '    if iPhase == ixyz(1), foo = \\'ROW\\'; end',\n    '    s.InPlanePhaseEncodingDirection = foo;',\n    'end',\n    '',\n    'R = R(:, ixyz); % dicom rotation matrix',\n    's.ImageOrientationPatient = R(1:6)\\';',\n    'R = R * diag([s.PixelSpacing; s.SpacingBetweenSlices]);',\n    'R = [R posMid; 0 0 0 1]; % 4th col is mid slice center position',\n    '% x = ([s.Columns s.Rows nSL] -1) / 2; % some V4.2 seem to use this',\n    'x = [s.Columns s.Rows nSL-1] / 2; % ijk of mid slice center ',\n    '',\n    'c0 = R(iOri,3:4) * [-x(3) 1]\\'; % 1st slice center loc based on current slice dir',\n    'if sign(R(iOri,3)) ~= sign(posMid(iOri)-c0)',\n    '    R(:,3) = -R(:,3);',\n    'end',\n    '',\n    'R(:,4) = R * [-x 1]\\'; % dicom xform matrix',\n    'y = R * [0 0 nSL-1 1]\\'; % last slice position',\n    's.ImagePositionPatient = R(1:3,4);',\n    's.LastFile.ImagePositionPatient = y(1:3);',\n    's.Manufacturer = \\'Philips\\';',\n    's.Filename = fullfile(pth, [nam \\'.REC\\']); % for dicm_img',\n    's.PixelData.Start = 0; % for dicm_img.m',\n    's.PixelData.Bytes = s.Rows * s.Columns * nImg * s.BitsAllocated / 8;',\n    '',\n    '    % nested function: set field if the key is in colTable',\n    '    function getTableVal(key, fldname, iRow)',\n    '        if nargin<3, iRow = 1; end',\n    '        iCol = find(keyInLabel(key));',\n    '        if isempty(iCol), return; end',\n    '        s.(fldname) = para(iRow, iColumn(iCol):iColumn(iCol+1)-1);',\n    '    end',\n    '',\n    '    % nested subfunction: return value specified by key in PAR file',\n    '    function val = par_key(key, fmt)',\n    '        if nargin<2 || isempty(fmt), fmt = \\'%g\\';  end',\n    '        i1 = regexp(str, [\\'\\\\n.\\\\s{1,}\\' key \\'\\\\s{0,}[(<\\\\[:]\\']);',\n    '        if isempty(i1)',\n    '            if strcmp(fmt, \\'%g\\'), val = [];',\n    '            else val = \\'\\';',\n    '            end',\n    '            return; ',\n    '        end',\n    '        i1 = i1(1) + 1; % skip \\'\\\\n\\'',\n    '        i2 = find(str(i1:end)==char(10), 1, \\'first\\') + i1 - 2;',\n    '        ln = str(i1:i2); % the line',\n    '        i1 = strfind(ln, \\':\\') + 1;',\n    '        val = sscanf(ln(i1(1):end), fmt); % convert based on fmt, re-use fmt',\n    '        if isnumeric(val), val = double(val);',\n    '        else val = strtrim(val);',\n    '        end',\n    '    end',\n    'end',\n    '',\n    '%% subfunction: read AFNI HEAD file, return struct like that from dicm_hdr.',\n    'function [s, err] = afni_head(fname)',\n    'persistent SN;',\n    'if isempty(SN), SN = 1; end',\n    'err = \\'\\';',\n    'if numel(fname)>5 && strcmp(fname(end+(-4:0)), \\'.BRIK\\')',\n    '    fname(end+(-4:0)) = \\'.HEAD\\';',\n    'end',\n    'fid = fopen(fname);',\n    'if fid<0, s = []; err = [\\'File not exist: \\' fname]; return; end',\n    'str = fread(fid, inf, \\'*char\\')\\';',\n    'fname = fopen(fid);',\n    'fclose(fid);',\n    '',\n    'i = strfind(str, \\'DATASET_DIMENSIONS\\');',\n    'if isempty(i), s = []; err = \\'Not brik header file\\'; return; end',\n    '',\n    '% these make dicm_nii.m happy',\n    '[~, foo] = fileparts(fname);',\n    '% s.IsAFNIHEAD = true;',\n    's.ProtocolName = foo;',\n    's.SeriesNumber = SN; SN = SN+1; % make it unique for multilple files',\n    's.SeriesInstanceUID = sprintf(\\'%g.%s.%09.0f\\', s.SeriesNumber, ...',\n    '    datestr(now, \\'yymmdd.HHMMSS.fff\\'), rand*1e9);',\n    's.ImageType = [\\'AFNIHEAD\\\\\\' afni_key(\\'TYPESTRING\\')];',\n    '',\n    'foo = afni_key(\\'BYTEORDER_STRING\\');',\n    'if strcmp(foo(1), \\'M\\'), err = \\'BYTEORDER_STRING not supported\\'; s = []; return; end',\n    '',\n    'foo = afni_key(\\'BRICK_FLOAT_FACS\\');',\n    'if any(diff(foo)~=0), err = \\'Inconsistent BRICK_FLOAT_FACS\\'; ',\n    '    s = []; return; ',\n    'end',\n    'if foo(1)==0, foo = 1; end',\n    's.RescaleSlope = foo(1);',\n    's.RescaleIntercept = 0;',\n    '',\n    'foo = afni_key(\\'BRICK_TYPES\\');',\n    'if any(diff(foo)~=0), err = \\'Inconsistent DataType\\'; s = []; return; end',\n    'foo = foo(1);',\n    'if foo == 0',\n    '    s.BitsAllocated =  8; s.PixelData.Format = \\'*uint8\\';',\n    'elseif foo == 1',\n    '    s.BitsAllocated = 16; s.PixelData.Format = \\'*int16\\';',\n    'elseif foo == 3',\n    '    s.BitsAllocated = 32; s.PixelData.Format = \\'*single\\';',\n    'else',\n    '    error(\\'Unsupported BRICK_TYPES: %g\\', foo);',\n    'end',\n    '',\n    'hist = afni_key(\\'HISTORY_NOTE\\');',\n    'i = strfind(hist, \\'Time:\\') + 6;',\n    'if ~isempty(i)',\n    '    dat = sscanf(hist(i:end), \\'%11c\\', 1); % Mar  1 2010',\n    '    dat = datenum(dat, \\'mmm dd yyyy\\');',\n    '    s.AcquisitionDateTime = datestr(dat, \\'yyyymmdd\\');',\n    'end',\n    'i = strfind(hist, \\'Sequence:\\') + 9;',\n    'if ~isempty(i), s.ScanningSequence = strtok(hist(i:end), \\' \\'); end',\n    'i = strfind(hist, \\'Studyid:\\') + 8;',\n    'if ~isempty(i), s.StudyID = strtok(hist(i:end), \\' \\'); end',\n    '% i = strfind(hist, \\'Dimensions:\\') + 11;',\n    '% if ~isempty(i)',\n    '%     dimStr = strtok(hist(i:end), \\' \\') % 64x64x35x92',\n    '% end',\n    '% i = strfind(hist, \\'Orientation:\\') + 12;',\n    '% if ~isempty(i)',\n    '%     oriStr = strtok(hist(i:end), \\' \\') % LAI',\n    '% end',\n    'i = strfind(hist, \\'TE:\\') + 3;',\n    'if ~isempty(i), s.EchoTime = sscanf(hist(i:end), \\'%g\\', 1) * 1000; end',\n    '',\n    '% foo = afni_key(\\'TEMPLATE_SPACE\\'); % ORIG/TLRC',\n    '% INT_CMAP',\n    'foo = afni_key(\\'SCENE_DATA\\');',\n    's.TemplateSpace = foo(1)+1; %[0] 0=+orig, 1=+acpc, 2=+tlrc',\n    'if foo(2)==9, s.ImageType = [s.ImageType \\'\\\\DIFFUSION\\\\\\']; end',\n    '% ori = afni_key(\\'ORIENT_SPECIFIC\\')+1;',\n    '% orients = [1 -1 -2 2 3 -3]; % RL LR PA AP IS SI',\n    '% ori = orients(ori) % in dicom/afni LPS, ',\n    '% seems always [1 2 3], meaning AFNI re-oriented the volome',\n    '',\n    '% no read/phase/slice dim info, so following 3D info are meaningless',\n    'dim = afni_key(\\'DATASET_DIMENSIONS\\');',\n    's.Columns = dim(1); s.Rows = dim(2); s.LocationsInAcquisition = dim(3);',\n    'R = afni_key(\\'IJK_TO_DICOM_REAL\\'); % IJK_TO_DICOM is always straight?',\n    'if isempty(R), R = afni_key(\\'IJK_TO_DICOM\\'); end',\n    'R = reshape(R, [4 3])\\';',\n    's.ImagePositionPatient = R(:,4); % afni_key(\\'ORIGIN\\') can be wrong',\n    'y = [R; 0 0 0 1] * [0 0 dim(3)-1 1]\\';',\n    's.LastFile.ImagePositionPatient = y(1:3);',\n    'R = R(1:3, 1:3);',\n    'R = R ./ (ones(3,1) * sqrt(sum(R.^2)));',\n    's.ImageOrientationPatient = R(1:6)\\';',\n    'foo = afni_key(\\'DELTA\\');',\n    's.PixelSpacing = foo(1:2);',\n    '% s.SpacingBetweenSlices = foo(3);',\n    's.SliceThickness = foo(3);',\n    'foo = afni_key(\\'BRICK_STATS\\');',\n    'foo = reshape(foo, [2 numel(foo)/2]);',\n    'mn = min(foo(1,:)); mx = max(foo(2,:));',\n    's.WindowCenter = (mx+mn)/2;',\n    's.WindowWidth = mx-mn;',\n    'foo = afni_key(\\'TAXIS_FLOATS\\'); %[0]:0; ',\n    'if ~isempty(foo), s.RepetitionTime = foo(2)*1000; end',\n    '',\n    'foo = afni_key(\\'TAXIS_NUMS\\'); % [0]:nvals; [1]: 0 or nSL normally',\n    'if ~isempty(foo)',\n    '    inMS = foo(3)==77001;',\n    '    foo = afni_key(\\'TAXIS_OFFSETS\\');',\n    '    if inMS, foo = foo/1000; end',\n    '    if ~isempty(foo), s.MosaicRefAcqTimes = foo; end',\n    'end',\n    '',\n    'foo = afni_key(\\'DATASET_RANK\\'); % [3 nvals]',\n    'dim(4) = foo(2);',\n    's.NumberOfTemporalPositions = dim(4);',\n    '% s.NumberOfFrames = dim(4)*dim(3);',\n    ' ',\n    's.Manufacturer = \\'\\';',\n    's.Filename = strrep(fname, \\'.HEAD\\', \\'.BRIK\\');',\n    's.PixelData.Start = 0; % make it work for dicm_img.m',\n    's.PixelData.Bytes = prod(dim(1:4)) * s.BitsAllocated / 8;',\n    '',\n    '    % subfunction: return value specified by key in afni header str',\n    '    function val = afni_key(key)',\n    '    i1 = regexp(str, [\\'\\\\nname\\\\s{0,}=\\\\s{0,}\\' key \\'\\\\n\\']); % line \\'name = key\\'',\n    '    if isempty(i1), val = []; return; end',\n    '    i1 = i1(1) + 1;',\n    '    i2 = regexp(str(1:i1), \\'type\\\\s{0,}=\\\\s{0,}\\\\w*-attribute\\\\n\\');',\n    '    keyType = sscanf(str(i2(end):i1), \\'type%*c=%*c%s\\', 1); %\\'string-attribute\\'',\n    '    i1 = find(str(i1:end)==char(10), 1, \\'first\\') + i1;',\n    '    count = sscanf(str(i1:end), \\'count%*c=%*c%g\\', 1);',\n    '    if strcmp(keyType, \\'string-attribute\\')',\n    '        i1 = find(str(i1:end)==\\'\\'\\'\\', 1, \\'first\\') + i1;',\n    '        val = str(i1+(0:count-2));',\n    '    else',\n    '        i1 = find(str(i1:end)==char(10), 1, \\'first\\') + i1;',\n    '        val = sscanf(str(i1:end), \\'%g\\', count);',\n    '    end',\n    '    end',\n    'end',\n    '',\n    '%% gunzip data in memory if possible.',\n    '% For a GE ProtocolDataBlock, memory / file approaches take 0.5 / 43 ms.',\n    '% When gz_bytes is large, pigz will be faster. The reversing point is about 8M.',\n    'function bytes = gunzip_mem(gz_bytes)',\n    'bytes = [];',\n    'try',\n    '    import com.mathworks.mlwidgets.io.*',\n    '    streamCopier = InterruptibleStreamCopier.getInterruptibleStreamCopier;',\n    '    baos = java.io.ByteArrayOutputStream;',\n    '    b = typecast(gz_bytes, \\'int8\\');',\n    '    bais = java.io.ByteArrayInputStream(b);',\n    '    gzis = java.util.zip.GZIPInputStream(bais);',\n    '    streamCopier.copyStream(gzis, baos);',\n    '    bytes = typecast(baos.toByteArray, \\'uint8\\'); % int8 to uint8',\n    'catch',\n    '    try %#ok',\n    '        tmp = tempname; % temp gz file',\n    '        fid = fopen([tmp \\'.gz\\'], \\'w\\');',\n    '        if fid<0, return; end',\n    '        cln = onCleanup(@() delete([tmp \\'*\\'])); % delete gz and unziped files',\n    '        fwrite(fid, gz_bytes, \\'uint8\\');',\n    '        fclose(fid);',\n    '        ',\n    '        gunzipOS = nii_tool(\\'func_handle\\', \\'gunzipOS\\');',\n    '        gunzipOS([tmp \\'.gz\\']);',\n    '        ',\n    '        fid = fopen(tmp);',\n    '        bytes = fread(fid, \\'*uint8\\');',\n    '        fclose(fid);',\n    '    end',\n    'end',\n    'end',\n    '',\n    '%% Subfunction: read BrainVoyager vmr/fmr/dmr. Call BVQXfile',\n    'function [s, err] = bv_file(fname)',\n    's = []; err = \\'\\';',\n    'try ',\n    '    bv = BVQXfile(fname);',\n    'catch me',\n    '    err = me.message;',\n    '    if strfind(me.identifier, \\'UndefinedFunction\\')',\n    '        fprintf(2, \\'Please download BVQXtools at \\\\n%s\\\\n\\', ...',\n    '        \\'http://support.brainvoyager.com/available-tools/52-matlab-tools-bvxqtools.html\\');',\n    '    end',\n    '    return;',\n    'end',\n    '',\n    'if ~isempty(bv.Trf)',\n    '    for i = 1:length(bv.Trf)',\n    '        if ~isequal(diag(bv.Trf(i).TransformationValues), [1 1 1 1]\\')',\n    '            err = \\'Data has been transformed: skipped.\\';',\n    '            return;',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'persistent SN subj folder % folder is used to update subj',\n    'if isempty(SN), SN = 1; subj = \\'\\'; folder = \\'\\'; end',\n    's.Filename = bv.FilenameOnDisk;',\n    'fType = bv.filetype;',\n    's.ImageType = [\\'BrainVoyagerFile\\\\\\' fType];',\n    '',\n    '% Find a fmr/dmr, and get subj based on dicom file name in BV format.',\n    '% Suppose BV files in the folder are for the same subj',\n    '[pth, nam] = fileparts(s.Filename);',\n    's.SeriesDescription = nam;',\n    'if isempty(folder) || ~strcmp(folder, pth)',\n    '    folder = pth;',\n    '    subj = \\'\\';',\n    '    if strcmp(fType, \\'fmr\\') || strcmp(fType, \\'dmr\\')',\n    '        [~, nam] = fileparts(bv.FirstDataSourceFile);',\n    '        nam = strtok(nam, \\'-\\');',\n    '        if ~isempty(nam), subj = nam; end',\n    '    else',\n    '        fnames = dir([pth \\'/*.fmr\\']);',\n    '        if isempty(fnames), fnames = dir([pth \\'/*.dmr\\']); end',\n    '        if ~isempty(fnames)',\n    '            bv1 = BVQXfile(fullfile(pth, fnames(1).name));',\n    '            [~, nam] = fileparts(bv1.FirstDataSourceFile);',\n    '            bv1.ClearObject;',\n    '            nam = strtok(nam, \\'-\\');',\n    '            if ~isempty(nam), subj = nam; end',\n    '        end',\n    '    end',\n    'end',\n    'if ~isempty(subj), s.PatientName = subj; end',\n    '',\n    's.Columns = bv.NCols;',\n    's.Rows = bv.NRows;',\n    's.SliceThickness = bv.SliceThickness;',\n    'R = [bv.RowDirX bv.RowDirY bv.RowDirZ; bv.ColDirX bv.ColDirY bv.ColDirZ]\\';',\n    's.ImageOrientationPatient = R(:);',\n    'R(:,3) = cross(R(:,1), R(:,2));',\n    '[~, ixyz] = max(abs(R)); iSL =ixyz(3);',\n    '',\n    'try ',\n    '    s.TemplateSpace = bv.ReferenceSpace; % 0/2/3: Scanner/ACPC/TAL',\n    '    if s.TemplateSpace==0, s.TemplateSpace = 1; end',\n    'catch',\n    '    s.TemplateSpace = 1;',\n    'end',\n    'pos = [bv.Slice1CenterX bv.Slice1CenterY bv.Slice1CenterZ',\n    '       bv.SliceNCenterX bv.SliceNCenterY bv.SliceNCenterZ]\\'; % for real slices',\n    '',\n    'if strcmpi(fType, \\'vmr\\')',\n    '    s.SpacingBetweenSlices = s.SliceThickness + bv.GapThickness;',\n    '    s.PixelSpacing = [bv.VoxResX bv.VoxResY]\\';',\n    '    if ~isempty(bv.VMRData16)',\n    '        nSL = bv.DimZ;',\n    '        s.PixelData = bv.VMRData16; % no padded zeros',\n    '    else',\n    '        v16 = [s.Filename(1:end-3) \\'v16\\'];',\n    '        if exist(v16, \\'file\\')',\n    '            bv16 = BVQXfile(v16);',\n    '            nSL = bv16.DimZ;',\n    '            s.PixelData = bv16.VMRData; % no padded zeros',\n    '            bv16.ClearObject;',\n    '        else % fall back the 8-bit data, and deal with padded zeros',\n    '            ix = floor((bv.DimX - s.Columns)/2);',\n    '            iy = floor((bv.DimY - s.Rows)/2);',\n    '            R3 = abs(R(iSL,3)) * s.SpacingBetweenSlices;',\n    '            nSL = round(abs(diff(pos(iSL,:))) / R3) + 1;',\n    '            iz = floor((bv.DimZ - nSL)/2);',\n    '            s.PixelData = bv.VMRData(ix+(1:s.Columns), iy+(1:s.Rows), iz+(1:nSL), :);',\n    '        end',\n    '    end',\n    '    s.LocationsInAcquisition = nSL;',\n    '    s.MRAcquisitionType = \\'3D\\'; % for dicm2nii to re-orient',\n    'elseif strcmpi(fType, \\'fmr\\') || strcmpi(fType, \\'dmr\\')',\n    '    s.SpacingBetweenSlices = s.SliceThickness + bv.SliceGap;',\n    '    s.PixelSpacing = [bv.InplaneResolutionX bv.InplaneResolutionY]\\';',\n    '    nSL = bv.NrOfSlices;',\n    '    s.LocationsInAcquisition = nSL;',\n    '    s.NumberOfTemporalPositions = bv.NrOfVolumes;',\n    '    s.RepetitionTime = bv.TR;',\n    '    s.EchoTime = bv.TE;',\n    '    if bv.TimeResolutionVerified',\n    '        switch bv.SliceAcquisitionOrder % the same as NIfTI?',\n    '            case 1, ind = 1:nSL;',\n    '            case 2, ind = nSL:-1:1;',\n    '            case 3, ind = [1:2:nSL 2:2:nSL];',\n    '            case 4, ind = [nSL:-2:1 nSL-1:-2:1];',\n    '            case 5, ind = [2:2:nSL 1:2:nSL];',\n    '            case 6, ind = [nSL-1:-2:1 nSL:-2:1];',\n    '            otherwise, ind = []; err = \\'Unknown SliceAcquisitionOrder\\';',\n    '        end',\n    '        if ~isempty(ind)',\n    '            t = (0:s.LocationsInAcquisition-1)\\' * bv.InterSliceTime; % ms',\n    '            t(ind) = t;',\n    '            s.SliceTiming = t;',\n    '        end',\n    '    end',\n    '    if strcmpi(fType, \\'fmr\\')',\n    '        bv.LoadSTC;',\n    '        s.PixelData = permute(bv.Slice(1).STCData , [1 2 4 3]);',\n    '        for i = 2:length(bv.Slice)',\n    '            s.PixelData(:,:,i,:) = permute(bv.Slice(i).STCData , [1 2 4 3]);',\n    '        end',\n    '    else % dmr',\n    '        s.ImageType = [s.ImageType \\'\\\\DIFFUSION\\\\\\'];',\n    '        bv.LoadDWI;',\n    '        s.PixelData = bv.DWIData;',\n    '        if strncmpi(bv.GradientInformationAvailable, \\'Y\\', 1)',\n    '            a = bv.GradientInformation; % nDir by 4',\n    '            s.B_value = a(:,4);',\n    '            a = a(:,1:3); % bvec',\n    '            % Following should be right in theory, but I would trust the grd',\n    '            % table which should be in dicom coodinate system, rather than the',\n    '            % confusing Gradient?DirInterpretation ',\n    '%             % 1:6 for LR RL AP PA IS SI. Default [2 3 5] by dicom LPS',\n    '%             i1_6 = [bv.GradientXDirInterpretation ...',\n    '%                     bv.GradientYDirInterpretation ...',\n    '%                     bv.GradientZDirInterpretation];',\n    '%             [xyz, ind] = sort(i1_6);',\n    '%             if isequal(ceil(xyz/2), 1:3) % perm of 1/2/3',\n    '%                 a = a(:,ind);',\n    '%                 flip = xyz == [1 4 6]; % negative by dicom ',\n    '%                 a(:,flip) = -a(:,flip);',\n    '%             else',\n    '%                 str = sprintf([\\'Wrong Interpretation of gradient found: %s\\\\n\\' ... ',\n    '%                        \\'Please check bvec and its sign.\\\\n\\'], fname);',\n    '%                 fprintf(2, str);',\n    '%                 err = [err str];',\n    '%             end',\n    '            s.bvec_original = a;',\n    '        end',\n    '    end',\n    '    ',\n    '    % fmr/dmr are normally converted from uint16 to single',\n    '    if isfloat(s.PixelData) && isequal(floor(s.PixelData), s.PixelData) ...',\n    '            && max(s.PixelData(:))<32768 && min(s.PixelData(:))>=-32768',\n    '        s.PixelData = int16(s.PixelData);',\n    '    end',\n    'else',\n    '    err = [\\'Unknown BV file type: \\' fType];',\n    '    s = [];',\n    '    return;',\n    'end',\n    '',\n    'pos = pos - R(:,1:2) * diag(s.PixelSpacing) * [s.Columns s.Rows]\\'/2 * [1 1];',\n    's.ImagePositionPatient = pos(:,1);',\n    's.LastFile.ImagePositionPatient = pos(:,2);',\n    '',\n    '% Following make dicm2nii happy',\n    'try %#ok',\n    '    [~, nam] = fileparts(bv.FirstDataSourceFile);',\n    '    [~, nam] = strtok(nam, \\'-\\');',\n    '    serN = str2double(strtok(nam, \\'-\\'));',\n    '    if ~isempty(serN), SN = serN; end',\n    'end',\n    's.SeriesNumber = SN; SN = SN+1; % make it unique for multilple files',\n    's.SeriesInstanceUID = sprintf(\\'%g.%s.%09.0f\\', s.SeriesNumber, ...',\n    '    datestr(now, \\'yymmdd.HHMMSS.fff\\'), rand*1e9);',\n    'c = class(s.PixelData);',\n    'if strcmp(c, \\'double\\') %#ok',\n    '    s.BitsAllocated = 64;',\n    'elseif strcmp(c, \\'single\\') %#ok',\n    '    s.BitsAllocated = 32;',\n    'else',\n    '    ind = find(isstrprop(c, \\'digit\\'), 1);',\n    '    s.BitsAllocated = sscanf(c(ind:end), \\'%g\\');',\n    'end',\n    'end'\n  )\n\n  dicm_img <- c(\n    'function img = dicm_img(s, xpose)',\n    '% Read image of a dicom file.',\n    '% ',\n    '% img = dicm_img(metaStructOrFilename, xpose);',\n    '% ',\n    '% The mandatory first input is the dicom file name, or the struct returned by',\n    '% dicm_hdr. The output keeps the data type in dicom file.',\n    '% ',\n    '% The second input is for special purpose. When it is provided and is false, the',\n    '% returned img won\\'t be transposed. This is likely only useful for dicm2nii.m,',\n    '% where the Columns and Rows parameters become counter-intuitive.',\n    '% ',\n    '% DICM_IMG is like dicomread from Matlab, but is independent of Image Processing',\n    '% Toolbox.',\n    '% ',\n    '% Limitation: DICM_IMG reads only little endian format, and can deal with only',\n    '% JPEG compression.',\n    '%',\n    '% See also DICM_HDR, DICM_DICT, DICM2NII',\n    '',\n    '% TO DO: take care of BitsAllocated, BitsStored and HighBit related issue.',\n    '% Now we assume',\n    '%   HighBit is BitsStored-1;',\n    '%   extra bits beyond BitsStored are zeros.',\n    '',\n    '% History (yymmdd):',\n    '% 130823 Write it for dicm2nii.m (xiangrui.li@gmail.com)',\n    '% 130914 Use PixelData.Bytes rather than nPixels;',\n    '%        Use PixelRepresentation to determine signed data.',\n    '% 130923 Use BitsAllocated for bits. Make it work for multiframe.',\n    '% 131018 Add jpeg de-compression part.',\n    '% 141023 Use memmapfile for temp file: ~25% speedup.',\n    '% 150109 Transpose img by default. dicm2nii needs xpose=0 to avoid transpose.',\n    '% 150115 SamplesPerPixel>1 works: put it as dim3, and push rest to dim4.',\n    '% 150211 dim3 reserved for RGB, even if SamplesPerPixel=1 (like dicomread). ',\n    '% 150404 Add \\'if\\' block for numeric s.PixelData (BVfile). ',\n    '',\n    'persistent flds dict;',\n    'if isempty(flds)',\n    '    flds = {\\'Columns\\' \\'Rows\\' \\'BitsAllocated\\'};',\n    '    dict = dicm_dict(\\'\\', [flds \\'SamplesPerPixel\\' \\'PixelRepresentation\\' ...',\n    '                         \\'PlanarConfiguration\\' \\'BitsStored\\' \\'HighBit\\']);',\n    'end',\n    'if isstruct(s) && ~all(isfield(s, flds)), s = s.Filename; end',\n    'if ischar(s), [s, err] = dicm_hdr(s, dict); end % input is file name',\n    'if isempty(s), error(err); end',\n    'if isfield(s, \\'SamplesPerPixel\\'), spp = double(s.SamplesPerPixel);',\n    'else spp = 1;',\n    'end',\n    '',\n    'if isnumeric(s.PixelData) % data already in hdr',\n    '    img = s.PixelData;',\n    '    return;',\n    'end',\n    '',\n    'if all(isfield(s, {\\'BitsStored\\' \\'HighBit\\'})) && s.BitsStored ~= s.HighBit+1',\n    '    error(\\'Please report to author: HighBit+1 ~= BitsStored, %s\\', s.Filename);',\n    'end',\n    '',\n    'fid = fopen(s.Filename);',\n    'if fid<0',\n    '    if exist([s.Filename \\'.gz\\'], \\'file\\')',\n    '        gunzip([s.Filename \\'.gz\\']);',\n    '        fid = fopen(s.Filename);',\n    '    end',\n    '    if fid<0, error([\\'File not exists: \\' s.Filename]); end',\n    'end',\n    'closeFile = onCleanup(@() fclose(fid));',\n    'fseek(fid, s.PixelData.Start, -1);',\n    'if ~isfield(s.PixelData, \\'Format\\')',\n    '    fmt = sprintf(\\'*uint%g\\', s.BitsAllocated);',\n    'else',\n    '    fmt =  s.PixelData.Format;',\n    'end',\n    '',\n    'if nargin<2 || isempty(xpose), xpose = true; end % same as dicomread by default',\n    '',\n    'if ~isfield(s, \\'TransferSyntaxUID\\') || ... % maybe PAR or AFNI file',\n    '        strcmp(s.TransferSyntaxUID, \\'1.2.840.10008.1.2.1\\') || ...',\n    '        strcmp(s.TransferSyntaxUID, \\'1.2.840.10008.1.2\\')',\n    '    n = s.PixelData.Bytes / double(s.BitsAllocated) * 8;',\n    '    img = fread(fid, n, fmt);',\n    '    dim = double([s.Columns s.Rows]);',\n    '    if ~isfield(s, \\'PlanarConfiguration\\') || s.PlanarConfiguration==0',\n    '        img = reshape(img, [spp dim n/spp/dim(1)/dim(2)]);',\n    '        img = permute(img, [2 3 1 4]);',\n    '    else',\n    '        img = reshape(img, [dim spp n/spp/dim(1)/dim(2)]);',\n    '    end',\n    '    if xpose, img = permute(img, [2 1 3 4]); end',\n    'else % rely on imread for decompression',\n    '    b = fread(fid, inf, \\'*uint8\\'); % read all as bytes',\n    '    nEnd = numel(b) - 8; % terminator 0xFFFE E0DD and its zero length',\n    '    n = typecast(b(5:8), \\'uint32\\'); i = 8+n; % length of offset table',\n    '    if n>0',\n    '        nFrame = n/4; % # of elements in offset table ',\n    '    else % empty offset table',\n    '        ind = strfind(b\\', uint8([254 255 0 224])); % 0xFFFE E000',\n    '        nFrame = numel(ind) - 1; % one more for offset table, even if empty',\n    '    end',\n    '    img = zeros(s.Rows, s.Columns, spp, nFrame, fmt(2:end)); % pre-allocate',\n    '    ',\n    '    useMemmapfile = ~isempty(which(\\'memmapfile\\'));',\n    '    fname = tempname;',\n    '    if useMemmapfile',\n    '        fid = fopen(fname, \\'w\\');',\n    '        n = double(s.Columns) * double(s.Rows) * double(s.BitsAllocated) / 8 * spp;',\n    '        fwrite(fid, zeros(n, 1, \\'uint8\\')); % large enough: 1 frame w/o compression',\n    '        fclose(fid); ',\n    '        m = memmapfile(fname, \\'Writable\\', true);',\n    '    end',\n    '    deleteTemp = onCleanup(@() delete(fname)); % after memmapfile',\n    '    ',\n    '    for j = 1:nFrame',\n    '        i = i+4; % delimiter: FFFE E000',\n    '        n = typecast(b(i+uint32(1:4)), \\'uint32\\'); i = i+4;',\n    '        if useMemmapfile',\n    '            m.Data(1:n) = b(i+(1:n)); i = i + n;',\n    '        else',\n    '            fid = fopen(fname, \\'w\\');',\n    '            fwrite(fid, b(i+(1:n)), \\'uint8\\'); i = i + n;',\n    '            fclose(fid); ',\n    '        end',\n    '        img(:,:,:,j) = imread(fname); % take care of decompression',\n    '        if i>nEnd % in case false delimiter in data was counted',\n    '            img(:,:,:,j+1:end) = [];',\n    '            break;',\n    '        end',\n    '    end',\n    '    if ~xpose, img = permute(img, [2 1 3 4]); end',\n    'end',\n    '',\n    'if isfield(s, \\'PixelRepresentation\\') && s.PixelRepresentation>0',\n    '    img = reshape(typecast(img(:), fmt(3:end)), size(img)); % signed',\n    'end'\n  )\n\n  rename_dict <- c(\n    'function rename_dicm(files, fmt)',\n    '% Rename dicom files so the names are human readable.',\n    '% ',\n    '% rename_dicm(files, outputNameFormat)',\n    '% ',\n    '% The first input is the dicom file(s) or a folder containing dicom files.',\n    '% The second input is the format for the result file names. Support format',\n    '% include:',\n    '% ',\n    '% 1: Protocol_#####.dcm, such as run1_00001.dcm. If there is MoCo series,',\n    '%    or users did not change run names, there will be name conflict.',\n    '%   ',\n    '% 2: Subj-Ser#-Acq#-Inst#.dcm, such as 2334ZL-0004-0001-00001.dcm. This is',\n    '%    the BrainVoyager format. It won\\'t have any name confict, but it is',\n    '%    long and less descriptive. Note that BrainVoyager itself has problem',\n    '%    to distinguish the two series of images for Siemens fieldmap, while',\n    '%    this code can avoid this problem.',\n    '% ',\n    '% 3: Protocol_Se#_Inst#, such as run1_004_00001.dcm. This gives short names,',\n    '%    while it is descriptive and there is no name conflict most of time.',\n    '% ',\n    '% 4: Subj_Protocol_In#, such as 2334ZL_run1_00001.dcm. This is useful if',\n    '%    files for different subjects are in the same folder.',\n    '% ',\n    '% 5: Protocol_Ser#-Acq#-Inst#, such as run1_003_001_00001.dcm. This ensures ',\n    '%    no name conflict, and is the default.',\n    '% ',\n    '% Whenever there is name confict, you will see red warning and the latter',\n    '% files won\\'t be renamed.',\n    '% ',\n    '% If the first input is not provided or empty, you will be asked to pick up',\n    '% a folder.',\n    '% ',\n    '% See also DICM_HDR SORT_DICM',\n    ' ',\n    '% History (yymmdd):',\n    '% 0710?? Write it (Xiangrui Li)',\n    '% 1304?? Add more options for output format',\n    '% 1306?? Exclude PhoenixZIPReport files to avoid error',\n    '% 1306?? Fix problem if illegal char in ProtocolName',\n    '% 1309?? Use dicm_hdr to replace dicominfo, so it runs much faster',\n    '% 1309?? Use 5-digit InstanceNumber, so works better for GE/Philips',\n    '% 1402?? Add Manufacturer to flds (bug caused by dicm_hdr update)',\n    '% 140506 Use SeriesDescription to replace ProtocolName non-Siemens',\n    '',\n    'curFolder = pwd;',\n    'clnObj = onCleanup(@() cd(curFolder));',\n    'if nargin<1 || isempty(files)',\n    '    folder = uigetdir(pwd, \\'Select a folder containing DICOM files\\');',\n    '    if folder==0, return; end',\n    '    cd(folder);',\n    '    files = dir;',\n    '    files([files.isdir]) = [];',\n    '    files = {files.name};',\n    '    ',\n    '    str = sprintf([\\'Choose Output format: \\\\n\\\\n\\' ...',\n    '                   \\'1: run1_00001.dcm\\\\n\\' ...',\n    '                   \\'2: BrainVoyager format\\\\n\\' ...',\n    '                   \\'3: run1_001_00001.dcm\\\\n\\' ...',\n    '                   \\'4: subj_run1_00001.dcm\\\\n\\' ...',\n    '                   \\'5: run1_001_001_00001.dcm\\\\n\\']);',\n    '    fmt = inputdlg(str, \\'Rename Dicom\\', 1, {\\'5\\'});',\n    '    if isempty(fmt), return; end',\n    '    fmt = str2double(fmt{1});',\n    'else',\n    '    if exist(files, \\'dir\\') % input is folder',\n    '        cd(files);',\n    '        files = dir;',\n    '        files([files.isdir]) = [];',\n    '        files = {files.name};',\n    '    else % files',\n    '        if ~iscell(files), files = {files}; end',\n    '        folder = fileparts(files{1});',\n    '        if ~isempty(folder), cd(folder); end',\n    '    end',\n    '    if nargin<2 || isempty(fmt), fmt = 5; end',\n    'end',\n    '',\n    'if ispc, ren = \\'rename\\';',\n    'else ren = \\'mv\\';',\n    'end % matlab movefile is too slow',\n    '',\n    'flds = {\\'InstanceNumber\\' \\'AcquisitionNumber\\' \\'SeriesNumber\\' \\'EchoNumber\\' \\'ProtocolName\\' ...',\n    '        \\'SeriesDescription\\' \\'PatientName\\' \\'PatientID\\' \\'Manufacturer\\'};',\n    'dict = dicm_dict(\\'\\', flds);',\n    '',\n    'nFile = length(files);',\n    'if nFile<1, return; end',\n    'err = \\'\\';',\n    'str = sprintf(\\'%g/%g\\', 1, nFile);',\n    'fprintf(\\' Renaming DICOM files: %s\\', str);',\n    '',\n    'for i = 1:nFile',\n    '    fprintf(repmat(\\'\\\\b\\', [1 length(str)]));',\n    '    str = sprintf(\\'%g/%g\\', i, nFile);',\n    '    fprintf(\\'%s\\', str);',\n    '    s = dicm_hdr(files{i}, dict);',\n    '    try % skip if no these fields',\n    '        sN = s.SeriesNumber;',\n    '        aN = s.AcquisitionNumber;',\n    '        iN = s.InstanceNumber;',\n    '        if strncmp(s.Manufacturer, \\'SIEMENS\\', 7)',\n    '            pName = strtrim(s.ProtocolName);',\n    '        else',\n    '            pName = strtrim(s.SeriesDescription);',\n    '        end',\n    '        if isfield(s, \\'PatientName\\')',\n    '            sName = s.PatientName;',\n    '        else',\n    '            sName = s.PatientID;',\n    '        end',\n    '    catch me %#ok',\n    '        continue;',\n    '    end',\n    '    ',\n    '    pName(~isstrprop(pName, \\'alphanum\\')) = \\'_\\'; % make str valid for file name',\n    '    while 1',\n    '        ind = strfind(pName, \\'__\\');',\n    '        if isempty(ind), break; end',\n    '        pName(ind) = [];',\n    '    end',\n    '    sName(~isstrprop(sName, \\'alphanum\\')) = \\'_\\'; % make str valid for file name',\n    '    while 1',\n    '        ind = strfind(sName, \\'__\\');',\n    '        if isempty(ind), break; end',\n    '        sName(ind) = [];',\n    '    end',\n    '    ',\n    '    if strncmpi(s.Manufacturer, \\'Philips\\', 7) % SeriesNumber is useless',\n    '        sN = aN;',\n    '    elseif strncmpi(s.Manufacturer, \\'SIEMENS\\', 7)',\n    '        if isfield(s, \\'EchoNumber\\') && s.EchoNumber>1',\n    '            aN = s.EchoNumber; % fieldmap phase image',\n    '        end',\n    '    end',\n    '    ',\n    '    if fmt == 1 % pN_001',\n    '        name = sprintf(\\'%s_%05g.dcm\\', pName, iN);',\n    '    elseif fmt == 2 % BrainVoyager',\n    '        name = sprintf(\\'%s-%04g-%04g-%05g.dcm\\', sName, sN, aN, iN);',\n    '    elseif fmt == 3 % pN_03_00001',\n    '        name = sprintf(\\'%s_%02g_%05g.dcm\\', pName, s.SeriesNumber, iN);',\n    '    elseif fmt == 4 % 2322ZL_pN_001',\n    '        name = sprintf(\\'%s_%s_%05g.dcm\\', sName, pName, iN); ',\n    '    elseif fmt == 5 % pN_003_001_001',\n    '        name = sprintf(\\'%s_%03g_%03g_%05g.dcm\\', pName, sN, aN, iN); ',\n    '    else',\n    '        error(\\'Invalid format.\\');',\n    '    end',\n    '    ',\n    '    if strcmpi(files{i}, name), continue; end % done already',\n    '    [er, foo] = system([ren \\' \"\\' files{i} \\'\" \\' name]);',\n    '    if er, err = [err files{i} \\': \\' foo]; end %#ok',\n    'end',\n    'fprintf(\\'\\\\n\\');',\n    'if ~isempty(err), fprintf(2, \\'\\\\n%s\\\\n\\', err); end'\n  )\n\n  sort_dicm <- c(\n    'function varargout = sort_dicm(srcDir)',\n    '% Sort dicom files for different subjects into subject folders. ',\n    '% ',\n    '% subjects = SORT_DICM(dicmFolder);',\n    '% The optional input is the top folder containing dicom file and/or subfodlers',\n    '% which may contain dicom files and/or subfolders.',\n    '% ',\n    '% Optionally, it returns subfolder names for the dicom files.',\n    '% ',\n    '% It is suggested not to mix dicom files for different subjects into a folder.',\n    '% However if, for any reason, a folder contains dicom files for multiple',\n    '% subjects, this function will create a subfolder under the dicom folder for',\n    '% each subject, and move corresponding files into each subject folder. If a',\n    '% subject has more than one studies, each study will have a subfolder.',\n    '% ',\n    '% See also DICM2NII, DICM_HDR, RENAME_DICM ',\n    '',\n    '% History (yymmdd):',\n    '% 141016 Wrote it (Xiangrui Li).',\n    '% 141017 Take care of StudyID, return sub-folders.',\n    '',\n    'if nargin<1 || isempty(srcDir)',\n    '    srcDir = uigetdir(pwd, \\'Select a folder containing DICOM files\\');',\n    '    if ~ischar(srcDir), return; end % user cancelled',\n    'end',\n    'if ~exist(srcDir, \\'dir\\'), error([srcDir \\' not exists.\\']); end',\n    '',\n    'dirs = genpath(srcDir);',\n    'dirs = textscan(dirs, \\'%s\\', \\'Delimiter\\', pathsep);',\n    'dirs = dirs{1}; % cell str',\n    'fnames = {};',\n    'for i = 1:length(dirs)',\n    '    curFolder = [dirs{i} filesep];',\n    '    foo = dir(curFolder); % all files and folders',\n    '    foo([foo.isdir]) = []; % remove folders',\n    '    foo = strcat(curFolder, {foo.name});',\n    '    fnames = [fnames foo]; %#ok<*AGROW>',\n    'end',\n    '',\n    'dict = dicm_dict(\\'\\', {\\'PatientName\\' \\'PatientID\\' \\'StudyID\\'});',\n    'h = struct;',\n    'n = length(fnames);',\n    'nDicm = 0;',\n    'for i = 1:n',\n    '    s = dicm_hdr(fnames{i}, dict);',\n    '    if isempty(s), continue; end',\n    '',\n    '    if isfield(s, \\'PatientName\\'), subj = s.PatientName;',\n    '    elseif isfield(s, \\'PatientID\\'), subj = s.PatientID;',\n    '    else continue;',\n    '    end',\n    '    if ~isfield(s, \\'StudyID\\'), s.StudyID = \\'1\\'; end',\n    '    ',\n    '    P = genvarname([\\'P\\' subj]);',\n    '    if ~isfield(h, P), h.(P) = []; end',\n    '    S = genvarname([\\'S\\' s.StudyID]);',\n    '    if ~isfield(h.(P), S), h.(P).(S) = {}; end',\n    '    ',\n    '    h.(P).(S){end+1} = s.Filename;',\n    '    nDicm = nDicm + 1;',\n    'end',\n    '',\n    'sep = filesep;',\n    'folders = {};',\n    'subjs = fieldnames(h);',\n    'for i = 1:length(subjs)',\n    '    sub = h.(subjs{i});',\n    '    S = fieldnames(sub);',\n    '    nS = length(S);',\n    '    for j = 1:nS',\n    '        dstDir = [srcDir sep subjs{i}(2:end)];',\n    '        if nS>1, dstDir = [dstDir \\'_study\\' S{j}(2:end)]; end',\n    '        if ~exist(dstDir, \\'dir\\'), mkdir(dstDir); end',\n    '        folders{end+1} = dstDir;',\n    '        ',\n    '        for k = 1:length(sub.(S{j}))',\n    '            fname = sub.(S{j}){k};',\n    '            [~, nam, ext] = fileparts(fname);',\n    '            dstName = [dstDir sep nam ext];',\n    '            if ~exist(dstName, \\'file\\'), movefile(fname, dstName); end',\n    '        end',\n    '    end',\n    'end',\n    '',\n    'if nargout',\n    '    varargout = {folders\\'};',\n    'else',\n    '    fprintf(\\' %g of %g files sorted into %g subfolders:\\\\n\\', ...',\n    '        nDicm, n, length(folders));',\n    '    fprintf(\\'  %s\\\\n\\', folders{:});',\n    'end'\n\n  )\n\n  writeLines(nii_tool,'nii_tool.m')\n  writeLines(dicm2nii,'dicm2nii.m')\n  writeLines(dicm_dict,'dicm_dict.m')\n  writeLines(dicm_hdr,'dicm_hdr.m')\n  writeLines(dicm_img,'dicm_img.m')\n  writeLines(rename_dict,'rename_dict.m')\n  writeLines(sort_dicm,'sort_dicm.m')\n\n\n\n\n  #source('matlabcode.R')\n  #if (!suppressWarnings(require(\"R.matlab\", quietly=TRUE))) {\n  #  install.packages(\"R.matlab\");\n  #  suppressPackageStartupMessages (require(\"R.matlab\", quietly=TRUE))\n  #} else {\n  #  suppressPackageStartupMessages (require(\"R.matlab\", quietly=TRUE))    \n  #}   \n  \n  #Matlab$startServer()   #start a matlab server\n  #[1] 0\n  #matlab <- Matlab()\n  #isOpen <- open(matlab) #connect to matlab\n  #if (!isOpen)\n  #  stop('failure: connect to Matlab Server!')\n  OutputDir <- 'nii_tmp/'\n  #setVariable(matlab,src = src);\n  #setVariable(matlab,dataFolder = outputPath);\n  #setVariable(matlab,outputFormat = outputFormat);\n  #setVariable(matlab,dataFolder = OutputDir);\n  commandlines <- paste(c(\"matlab -nodesktop -nosplash -wait -r \\\"dicm2nii(\\'\",src,\"\\',\",\"\\'\",OutputDir,\"\\',0,0); exit\\\"\"),collapse = '')\n  system(commandlines)\n  #evaluate(matlab,'dicm2nii(src,dataFolder,0,0)')\n  \n  #close(matlab)\n\n  target <- paste(OutputDir,list.files(OutputDir,'*.nii'),sep=\"\")\n  object <- read.nii(object,target)\n  file.remove(paste(OutputDir,list.files(OutputDir,'dcm*'),sep=\"\"))\n  file.remove(target)\n  file.remove('nii_tool.m')\n  file.remove('dicm2nii.m')\n  file.remove('dicm_dict.m')\n  file.remove('dicm_hdr.m')\n  file.remove('dicm_img.m')\n  file.remove('rename_dict.m')\n  file.remove('sort_dicm.m')\n  #file.remove(OutputDir)\n  #file.remove('InputStreamByteWrapper.class')\n  #file.remove('MatlabServer.m')\n  object@file_type <- \"DICOM\"\n  object\n}\n)\n\nread.DICOM.dcm <- function(inputPath)\n{\n  a <- new(\"NIdata\")\n  read.dcm(a, inputPath)\n}\n",
    "created" : 1457576542651.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "913926192",
    "id" : "E9D4E325",
    "lastKnownWriteTime" : 1457803938,
    "path" : "~/GitHub/BrainConductor/Brainbase/R/readDICOM.R",
    "project_path" : "R/readDICOM.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}